[{"categories":["graduate"],"contents":"ì½ì€ ë…¼ë¬¸ ë¦¬ìŠ¤íŠ¸  Caterpillar: A business process execution engine on the Ethereum Blockchain  ìƒˆë¡­ê²Œ ì•Œê²Œëœ ê°œë…  bpmn - business process management notation bpmn ê°œë…  ê·¸ ì™¸ ì§„í–‰ ë‚´ìš©  golang - basic syntax, method, pointer, closure, etc - (ìŠ¤í„°ë”” ë‚´ìš© ì •ë¦¬) í™©ìš©í™˜ ë‹˜ê³¼ ëŒ€í™” ë¸”ë¡ì²´ì¸ í”Œë«í¼ ì¡°ì‚¬ -\u0026gt; ì†”ë¼ë‚˜, ì•„ì´ì˜¤íƒ€, í™€ë¡œì²´ì¸  ì¡°ê±´1: DID method ê°€ëŠ¥í•œê°€ ì¡°ê±´2: Smart Contract ê°€ëŠ¥í•œê°€   ì œ6íšŒ ê¸°ì—…ì„¤ëª…íšŒ(ë¡¯ë°ì •ë³´í†µì‹ ,ë¸”ë¡ì²´ì¸ë©ìŠ¤,ì½”ì¸í”ŒëŸ¬ê·¸) - ì´ë…¸ë² ì´ì…˜ ì•„ì¹´ë°ë¯¸(42seoul)  ë³´ê³  ì‹¶ì€ ë…¼ë¬¸  Addressing Distributed Ledger Transaction Processing Limitations for the Internet-of-Things - IEEE Engineering Management Review -\u0026gt; IOTA ê´€ë ¨ ë…¼ë¬¸ Thinking Out of the Blocks: Holochain for Distributed Security in IoT Healthcare - IEEE INTERNET OF THINGS JOURNAL -\u0026gt; Holochain ê´€ë ¨ ë…¼ë¬¸  ì¶”í›„ ì§„í–‰ ì˜ˆì •  golang ì€ íŠœí† ë¦¬ì–¼ ê¹Œì§€ë§Œ ì§„í–‰ rust ì–¸ì–´ í•™ìŠµ (ë§¤ì£¼ 1ì‹œ í™”ë©´ ê³µìœ ë¡œ ì§„í–‰)  ê¸°íƒ€ ì°¸ê³  ìë£Œ  í† í° ê²½ì œì™€ ë¸”ë¡ì²´ì¸ì˜ ë¯¸ë˜ - ì´ìŠˆ ë¦¬í¬íŠ¸ ì½ê¸°(BPM ê´€ë ¨ í•œêµ­ì–´ ê¸€) Caterpillar: A Blockchain-Based Business Process Management System  ","date":"2021-07-25T21:03:02+09:00","permalink":"https://wadro.github.io/slide/graduate/dcc/%EC%A7%84%ED%96%89%EC%83%81%ED%99%A9-2021-jul-25/","tags":["dcc"],"title":"ì§„í–‰ìƒí™© 2021 Jul 25"},{"categories":["Computer Engineering"],"contents":"Go tutorials  ğŸ“”ğŸ“ë³¸ ë‚´ìš©ì€ tour.golang.org ì— ìˆëŠ” ë‚´ìš©ì„ ì •ë¦¬í•œ ê¸€ì…ë‹ˆë‹¤.  Hello, Go world! 3 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func say(s string) { for i := 0; i \u0026lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(\u0026quot;goroutine0\u0026quot;) say(\u0026quot;main0\u0026quot;) // ìˆœì°¨ ì‹¤í–‰ë¼ë¦¬ëŠ” ìˆœì„œ ë§ì¶°ì„œ ì‹¤í–‰ë¨ say(\u0026quot;main1\u0026quot;) // goroutine ë¼ë¦¬ëŠ” ë…ë¦½ì ìœ¼ë¡œ ë¹„ë™ê¸°ì‹ìœ¼ë¡œ ì²˜ë¦¬ë¨ () go say(\u0026quot;goroutine2\u0026quot;) // ë‚˜ì¤‘ì— ë‚˜ì˜¤ëŠ” ìˆœì°¨ ì‹¤í–‰ê³¼ í•¨ê»˜ ì‹¤í–‰ë¨ go say(\u0026quot;goroutine1\u0026quot;) // ì—¬ê¸°ì„œëŠ” say(\u0026quot;main2\u0026quot;) say(\u0026quot;main2\u0026quot;) }  output main0 goroutine0 goroutine0 main0 main0 goroutine0 goroutine0 main0 main0 goroutine0 main1 main1 main1 main1 main1 goroutine1 main2 goroutine2 main2 goroutine1 goroutine2 goroutine1 main2 goroutine2 main2 goroutine1 goroutine2 goroutine1 main2  ","date":"2021-07-25T14:03:14+09:00","permalink":"https://wadro.github.io/memo/cs/go/lab-golang-study-tutorials-03/","tags":["golang","go"],"title":"lab golang study tutorials 03"},{"categories":["Computer Engineering"],"contents":"Go tutorials  ğŸ“”ğŸ“ë³¸ ë‚´ìš©ì€ tour.golang.org ì— ìˆëŠ” ë‚´ìš©ì„ ì •ë¦¬í•œ ê¸€ì…ë‹ˆë‹¤. method ë¶€í„° concurrency ì „ê¹Œì§€  Go method! package main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) type Vertex struct { X, Y float64 } func (v Vertex) AbsMethod() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func AbsFunc(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } type MyFloat float64 // ë©”ì†Œë“œ ë§Œë“¤ë•Œ ì£¼ì˜ì‚¬í•­, ì¼ë°˜ íƒ€ì… ì•ˆë˜ê³  custom íƒ€ì…ë§Œ ê°€ëŠ¥í•¨. ê°™ì€ íŒ¨í‚¤ì§€ ë‚´ì— ì„ ì–¸ë˜ì–´ ìˆì–´ì•¼í•¨. ~~(ì‹«ì–´í•˜ëŠ” ì´ìœ ê°€ ê³„ì† ëŠ˜ì–´ë‚œë‹¤!)~~ func (f MyFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } func (v *Vertex) AbsPointer(n float64) float64 { v.X = v.X * n v.Y = v.Y * n return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (v Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) fmt.Println(Abs(v)) f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) v := Vertex{3, 4} fmt.Println(v.AbsPointer(2)) // í¬ì¸í„°ë¥¼ ì•ˆì“°ë©´ ê°ê° ë‹¤ë¥¸ ê°ì²´(ë³µì‚¬ëœ ê°’ ì‚¬ìš©) // í¬ì¸í„°ë¥¼ ì“°ë©´ ê°™ì€ ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì°¸ì¡°í•˜ë‹ˆê¹Œ ê°™ì€ ê°ì²´ v.Scale(10) fmt.Println(v.AbsPointer(2)) }  ë…¸íŠ¸   ë©”ì†Œë“œ ì£¼ì˜ì‚¬í•­\n  í•¨ìˆ˜ëŠ” ì¸ì ë„£ì„ë•Œ í¬ì¸í„° êµ¬ë¶„í•¨(\u0026amp;ë¶™ì—¬ì•¼ë¨) ë©”ì†Œë“œëŠ” ì¸ì ë„£ì„ë•Œ í¬ì¸í„° ì•Œì•„ì„œ íŒë‹¨í•¨ ì§„ì§œ ì°¸ ì¼ê´€ì ìœ¼ë¡œ ì†í¸í•œ ì–¸ì–´\u0026hellip; ì–¸ì–´ëŠ” ì†ì´ í¸í•œë° ê°œë°œìê°€ ë¶ˆí¸\u0026hellip; v.Scale(5) == (\u0026amp;v).Scale(5)\në‹¤í–‰íˆ ì°¸ì¡°ì™€ ì—­ì°¸ì¡° ë‘˜ë‹¤ ê°™ì€ íŠ¹ì§•ì„ ê°€ì§ p.Abs() ë¼ëŠ” ë©”ì„œë“œëŠ” (*p).Abs() ë¡œë„ ì‚¬ìš©ê°€ëŠ¥ ê·¸ë‹ˆê¹Œ value receiverì´ë“  reference receiver ì´ë“  ë©”ì†Œë“œëŠ” ì•„ë¬´ ì‹ ê²½ì•ˆì”€ ëŒ€ì‹  ë°˜ë“œì‹œ ì£¼ì˜í• ì ì€, ë ˆí¼ëŸ°ìŠ¤ ë¦¬ì‹œë²„ëŠ” ê°’ì„ ë°”ê¾¸ê³ , ê°’ ë¦¬ì‹œë²„ëŠ” ë³µì‚¬ë³¸ì„ ë§Œë“¬\nì¼ë°˜ì ìœ¼ë¡œ íŠ¹ì • ìœ í˜•ì˜ ëª¨ë“  ë°©ë²•ì—ëŠ” ê°’ì´ë‚˜ í¬ì¸í„° ë¦¬ì‹œë²„ê°€ ìˆì–´ì•¼ í•˜ì§€ë§Œ ë‘˜ ë‹¤ í˜¼í•©ë˜ì–´ì„œëŠ” ì•ˆë©ë‹ˆë‹¤.\ntype Abser interface { Abs() float64 } func main() { var a Abser f := MyFloat(-math.Sqrt2) v := Vertex{3, 4} a = f // a MyFloat implements Abser fmt.Println(a.Abs()) //1.4142135623730951 a = \u0026amp;v // a *Vertex implements Abser // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. // a = v fmt.Println(a.Abs()) // 5 } type MyFloat float64 func (f MyFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) }  ì—¬ê¸°ì„œ ë˜ ì• ë§¤í•œ ì‚¬ì‹¤ì€,\nfunc (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) }  ì´ë ‡ê²Œ í•˜ë©´ redeclared ë¼ê³  í•˜ë©´ì„œ, ì•„ê¹Œ ì˜ˆì œì˜ ìƒí™©ì—ì„œëŠ”\nfunc main() { a = \u0026amp;v // a *Vertex implements Abser fmt.Println(a.Abs()) // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. a = v fmt.Println(a.Abs()) } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) }  ì´ê±´ ë˜ ì˜ ì‹¤í–‰ ëœë‹¤\u0026hellip; ê°’ ë¦¬ì‹œë²„ì—ì„œëŠ” ì£¼ì†Œ ë„£ì–´ë„ ë˜ê³ , ê°’ ë„£ì–´ë„ ë˜ëŠ”ë°, ì£¼ì†Œ ë¦¬ì‹œë²„ì—ì„œëŠ” ê¼­ ì£¼ì†Œë§Œ ë„£ì–´ì•¼ ëœë‹¤. ì´ê²Œ ë­ì•¼?\n    ìë°”ë¥¼ ì˜ëª°ë¼ì„œ\u0026hellip; ë¬´ìŠ¨ ëœ»ì´ì§€?\n ì¸í„°í˜ì´ìŠ¤ì˜ ì•”ì‹œì  êµ¬í˜„  type implementsëŠ” ë©”ì†Œë“œë¥¼ ì‹¤í–‰í•¨ìœ¼ë¡œì¨ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.\nëª…ì‹œì  intentì˜ ì„ ì–¸ë„, \u0026ldquo;implementation\u0026quot;ì˜ í‚¤ì›Œë“œë„ ì—†ìŠµë‹ˆë‹¤.\nì•”ì‹œì  ì¸í„°í˜ì´ìŠ¤ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ ì •ì˜ë¥¼ êµ¬í˜„ìœ¼ë¡œë¶€í„° ë¶„ë¦¬í•˜ë©°,\nì´ëŠ” ì‚¬ì „ ì •ë ¬ ì—†ì´ ì–´ë– í•œ íŒ¨í‚¤ì§€ì— ë“±ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n?      ì•„ë˜ ë‚˜ì˜¨ main ì€ íŒ¨í‚¤ì§€ ì´ë¦„ì¼ë“¯? ({Hello}, main.T) Hello (3.141592653589793, main.F)\n  ì˜ì–´ê³µë¶€\n Under the hood : ë‚´ë¶€ concrete type? êµ¬ì²´ì ì¸ íƒ€ì… ì´ë¦„ì„ ë§í•˜ëŠ” ê±°ê² ì§€? ì¶”ìƒ íƒ€ì…ë„ ìˆë‚˜? auto ê°™ì€ê±°? íŠœí”Œì´ë¼ê³  í•˜ë‹ˆê¹Œ (value, type) ì§ê´€ì ìœ¼ë¡œëŠ” ë¬´ìŠ¨ ë§ì„ í•˜ë ¤ê³  í•˜ëŠ”ì§€ ì˜ë„ëŠ” ì•Œê² ëŠ”ë°, ë§ì€ ëª¨ë¥´ê² ë‹¤. ì•„ë¬´íŠ¼ ì´ë¦„ ê°™ì•„ë„ íƒ€ì… ë‹¤ë¥´ë©´ ë‹¤ë¥¸ê±°ë¼ëŠ” ê±°ì§€.    nil receiver ê°€ ì¢‹ë‹¤ê³  í•˜ë˜ë°\ntype I interface { M() } type T struct { S string } func (t *T) M() { // if t == nil { // fmt.Println(\u0026quot;this is\u0026quot;,t) // return // } fmt.Println(t) } /* ì£¼ì„ ì²˜ë¦¬ í•˜ë©´ (\u0026lt;nil\u0026gt;, *main.T) \u0026lt;nil\u0026gt; (\u0026amp;{hello}, *main.T) \u0026amp;{hello} ì£¼ì„ í’€ë©´ (\u0026lt;nil\u0026gt;, *main.T) this is \u0026lt;nil\u0026gt; (\u0026amp;{hello}, *main.T) \u0026amp;{hello} t ë¥¼ *t ë¡œ í•˜ë©´ t.S ì™€ ê°™ì€ ì—ëŸ¬ ë°œìƒ panic: runtime error: invalid memory address or nil pointer dereference ë‹ˆ ë©‹ëŒ€ë¡œ í•´ë¼... ì•„ë˜ëŠ” ì‹¤í–‰ ì˜ë¨. func (t *T) M() { if t == nil { fmt.Println(\u0026quot;this is\u0026quot;,t) return } fmt.Println(*t) } */ func main() { var i I var t *T i = t describe(i) i.M() i = \u0026amp;T{\u0026quot;hello\u0026quot;} describe(i) i.M() } func describe(i I) { fmt.Printf(\u0026quot;(%v, %T)\\n\u0026quot;, i, i) }    type assertion\nvar i interface{} = \u0026quot;hello\u0026quot; s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // panic fmt.Println(f)    type switch\nfunc do(i interface{}) { switch v := i.(type) { case int: fmt.Printf(\u0026quot;Twice %v(%T) is %v\\n\u0026quot;, v,v, v*2) case string: fmt.Printf(\u0026quot;%q(%T) is %v bytes long\\n\u0026quot;, v,v, len(v)) default: fmt.Printf(\u0026quot;I don't know about type %T!\\n\u0026quot;, v) } } func main() { do(21) do(\u0026quot;hello\u0026quot;) do(true) }    Stringers í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ë†“ìœ¼ë©´ printí• ë•Œ ì„¤ì •í•œê²ƒ ì²˜ëŸ¼ ë‚˜ì˜´ í•¨ìˆ˜ ì£¼ì„ì²˜ë¦¬í•˜ë©´ ê·¸ëƒ¥ ê°ì²´ë§Œ ë‚˜ì˜´(ì•„ë˜ ì„¤ì •í•œ ë¬¸ì¥ì´ ì•„ë‹ˆë¼)\ntype Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(\u0026quot;%v (%v years)\u0026quot;, p.Name, p.Age) } func main() { a := Person{\u0026quot;Arthur Dent\u0026quot;, 42} z := Person{\u0026quot;Zaphod Beeblebrox\u0026quot;, 9001} fmt.Println(a, z) }    io.Reader ì˜ íƒ€ì…? ì•„ë§ˆ ë‹¤ë¥¸ ì¸í„°í˜ì´ìŠ¤ (*strings.Reader)\nerror, io.EOF ì˜ íƒ€ì…ì€ (*errors.errorString)\n// ì§„ë„ëŠ” stringsê¹Œì§€ í–ˆìŒ image ê¹Œì§€ í•˜ê¸´ í–ˆëŠ”ë°,\nimage ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ë‚˜ì¤‘ì— ì‚¬ìš©í•˜ê²Œ ë˜ë©´ ë‹¤ì‹œ ë³´ëŠ”ê²Œ ë‚˜ì„ë“¯\n","date":"2021-07-22T19:55:35+09:00","permalink":"https://wadro.github.io/memo/cs/go/lab-golang-study-tutorials-02/","tags":["golang","go"],"title":"lab golang study tutorials 02"},{"categories":[""],"contents":"ë…¼ë¬¸ ë ˆí¼ëŸ°ìŠ¤ ì •ë¦¬ (ì•„ë˜ ë§í¬ë¥¼ í•œêµ­ì–´ë¡œ ë²ˆì—­í•˜ì˜€ìŠµë‹ˆë‹¤.)\nread://https_blockchain.intellectsoft.net/?url=https%3A%2F%2Fblockchain.intellectsoft.net%2Fblog%2Fconsensus-protocols-that-meet-different-business-demands%2F\nhttps://blockchain.intellectsoft.net/blog/consensus-protocols-that-meet-different-business-demands/\noverview In our our previous post we described different types of blockchain. However, they only characterize the environment in which blockchain can operate. The heart of distributed ledger technology (DLT) is the consensus protocol.\nì´ì „ ê²Œì‹œë¬¼ì—ì„œ ë‹¤ì–‘í•œ ìœ í˜•ì˜ ë¸”ë¡ì²´ì¸ì— ëŒ€í•´ ì„¤ëª…í–ˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ê·¸ê²ƒë“¤ì€ ë¸”ë¡ì²´ì¸ì´ ì‘ë™í•  ìˆ˜ ìˆëŠ” í™˜ê²½ë§Œì„ íŠ¹ì§•ì§“ìŠµë‹ˆë‹¤. ë¶„ì‚° ì›ì¥ ê¸°ìˆ (DLT)ì˜ í•µì‹¬ì€ í•©ì˜ í”„ë¡œí† ì½œì…ë‹ˆë‹¤.\nInterestingly, mathematicians and engineers have been developing distributed networks and consensensus protocols for decades but only with the emergence of Bitcoin has this technology made a leap forward. It doesnâ€™t give any sign of stopping either, and itâ€™s this leap forward that has allowed the variants of new rules for machine consensus to evolve. We invite you to take a glance at the most important of them.\ní¥ë¯¸ë¡­ê²Œë„ ìˆ˜í•™ìì™€ ì—”ì§€ë‹ˆì–´ëŠ” ìˆ˜ì‹­ ë…„ ë™ì•ˆ ë¶„ì‚° ë„¤íŠ¸ì›Œí¬ì™€ í•©ì˜ í”„ë¡œí† ì½œì„ ê°œë°œí•´ ì™”ì§€ë§Œ ë¹„íŠ¸ì½”ì¸ì´ ë“±ì¥í•˜ë©´ì„œ ì´ ê¸°ìˆ ì´ ë„ì•½í–ˆìŠµë‹ˆë‹¤. ë©ˆì¶œ ê¸°ë¯¸ë„ ë³´ì´ì§€ ì•Šìœ¼ë©°, ì´ëŸ¬í•œ ë„ì•½ ë•ë¶„ì— ê¸°ê³„ í•©ì˜ì— ëŒ€í•œ ìƒˆë¡œìš´ ê·œì¹™ì˜ ë³€í˜•ì´ ì§„í™”í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤. ê·¸ ì¤‘ ê°€ì¥ ì¤‘ìš”í•œ ê²ƒì„ í•œ ëˆˆì— ë³¼ ìˆ˜ ìˆë„ë¡ ì´ˆëŒ€í•©ë‹ˆë‹¤.\nWhy Consensus Algorithm What is \u0026ldquo;consensus\u0026rdquo; anyway? To give a broad definition, consensus is an agreement that satisfies each of the parties involved. Itâ€™s a key to democracy and decentralization in general and DLTs in particular. Look at Bitcoin: despite having a mysterious founder in Satoshi Nakamoto, he has no power over the community whatsoever. Bitcoin as a blockchain is fully transparent and open-source, and every node is equal on the network.\nì–´ì¨Œë“  \u0026ldquo;í•©ì˜\u0026quot;ë€ ë¬´ì—‡ì…ë‹ˆê¹Œ? ë„“ì€ ì˜ë¯¸ë¡œ, í•©ì˜ë€ ë§Œì¡±í•˜ëŠ” ê´€ì—¬ëœ ê° ë‹¹ì‚¬ì ë“¤ì„ ë§Œì¡±ì‹œí‚¤ëŠ” ë™ì˜ì´ë‹¤. ê·¸ê²ƒì€ íŠ¹íˆ ë¯¼ì£¼ì£¼ì˜ì™€ ì¼ë°˜ì ì¸ ì§€ë°© ë¶„ê¶Œ(íƒˆì¤‘ì•™í™”) ë° DLTs ì˜ í•µì‹¬ì…ë‹ˆë‹¤. ë¹„íŠ¸ì½”ì¸ì„ ë³´ì„¸ìš”: ì‚¬í† ì‹œ ë‚˜ì¹´ëª¨í† ë¼ëŠ” ì‹ ë¹„í•œ ì°½ë¦½ìê°€ ìˆìŒì—ë„ ë¶ˆêµ¬í•˜ê³  ê·¸ëŠ” ì»¤ë®¤ë‹ˆí‹°ì— ëŒ€í•œ ê¶Œí•œì´ ì „í˜€ ì—†ìŠµë‹ˆë‹¤. ë¸”ë¡ì²´ì¸ìœ¼ë¡œì„œì˜ ë¹„íŠ¸ì½”ì¸ì€ ì™„ì „íˆ íˆ¬ëª…í•˜ê³  ì˜¤í”ˆ ì†ŒìŠ¤ì´ë©° ëª¨ë“  ë…¸ë“œëŠ” ë„¤íŠ¸ì›Œí¬ì—ì„œ í‰ë“±í•©ë‹ˆë‹¤.\nIn the narrow meaning that we apply to cryptography, consensus is a voting procedure. Its goal is to ensure that all members of the network agree on its current state even after the addition of a new block or a package of transactions. In other words, a consensus protocol guarantees that the chain is true and that there are incentives to keep participants fair. Itâ€™s a major framework for preventing a single entity from controlling the entire system and makes sure everybody follows the rules.\ní•©ì˜ë¥¼ ì•”í˜¸ì— ì ìš©ì‹œì¼°ì„ë•Œ ì¢ì€ ì˜ë¯¸ë¡œì„œì˜ í•©ì˜ë€, íˆ¬í‘œ ì ˆì°¨ì…ë‹ˆë‹¤. ê·¸ ëª©í‘œëŠ” ìƒˆë¡œìš´ ë¸”ë¡ì´ë‚˜ íŠ¸ëœì­ì…˜ íŒ¨í‚¤ì§€ë¥¼ ì¶”ê°€í•œ í›„ì—ë„ ë„¤íŠ¸ì›Œí¬ì˜ ëª¨ë“  êµ¬ì„±ì›ì´ í˜„ì¬ ìƒíƒœì— ë™ì˜í•˜ë„ë¡ í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ë‹¤ë¥´ê²Œ ë§í•˜ë©´, í•©ì˜ í”„ë¡œí† ì½œì€ ì²´ì¸ì´ ì‚¬ì‹¤ì´ê³  ì°¸ê°€ìë¥¼ ê³µì •í•˜ê²Œ ìœ ì§€í•˜ê¸° ìœ„í•œ ì¸ì„¼í‹°ë¸Œê°€ ìˆìŒì„ ë³´ì¥í•©ë‹ˆë‹¤. ì´ê²ƒì´ ë‹¨ì¼ ê°œì²´ê°€ ì „ì²´ ì‹œìŠ¤í…œì„ ì œì–´í•˜ì§€ ëª»í•˜ë„ë¡ ë°©ì§€í•˜ê³  ëª¨ë“  ì‚¬ëŒì´ ê·œì¹™ì„ ë”°ë¥´ë„ë¡ í•˜ëŠ” ì£¼ìš”í•œ íŠ¹ì§•ì…ë‹ˆë‹¤.\nQuick Review Protocol = a set of rules\nProtocols help to:\n â€¢ ensure the viability of transactions in the network â€¢ eliminate double spending â€¢ alidate that participants are honest  A protocol is the sum of:\n the deterministic logical conditions of the framework cryptographic encryption as a basis of security social encouragement to maintain the given protocol  So what are some of these protocols?\ní”„ë¡œí† ì½œ = ì¼ë ¨ì˜ ê·œì¹™\ní”„ë¡œí† ì½œì€ ë‹¤ìŒì„ ì§€ì›í•©ë‹ˆë‹¤.\n â€¢ ë„¤íŠ¸ì›Œí¬ì—ì„œ íŠ¸ëœì­ì…˜ì˜ ì‹¤í–‰ ê°€ëŠ¥ì„± ë³´ì¥ â€¢ ì´ì¤‘ ì§€ì¶œì„ ì—†ì• ë‹¤ â€¢ ì°¸ê°€ìë“¤ì´ ì •ì§í•˜ë‹¤ëŠ” ê²ƒì„ ê°•ì¡°  í”„ë¡œí† ì½œì€ ë‹¤ìŒì˜ í•©ê³„ì…ë‹ˆë‹¤.\n â€¢ í”„ë ˆì„ì›Œí¬ì˜ ê²°ì •ë¡ ì  ë…¼ë¦¬ì  ì¡°ê±´ â€¢ ë³´ì•ˆ ê¸°ë°˜ìœ¼ë¡œ ì•”í˜¸í™” â€¢ ì£¼ì–´ì§„ í”„ë¡œí† ì½œì„ ìœ ì§€í•˜ê¸° ìœ„í•œ ì‚¬íšŒì  ê²©ë ¤  ê·¸ë ‡ë‹¤ë©´ ì´ëŸ¬í•œ í”„ë¡œí† ì½œì—ëŠ” ì–´ë–¤ ê²ƒë“¤ì´ ìˆìŠµë‹ˆê¹Œ?\nProof-of-Work protocol Proof-of-Work (PoW)    Concept: Proof-of-Work (PoW)     Principle: A difficult solution to find but easy to verify.   Speed: Low   DLT setup: Public/private blockchain   Finality: Probabilistic   Example of use: Bitcoin, Ethereum, Litecoin    The Bitcoin blockchain is perhaps the most replicated blockchain. The multiple nodes running it, order the transactions according to the PoW consensus algorithm. To add new blocks, each node has to prove that it has performed a certain amount of work. To be precise, they solve a hard hashing puzzle using a high computational input.\në¹„íŠ¸ì½”ì¸ ë¸”ë¡ì²´ì¸ì€ ì•„ë§ˆë„ ê°€ì¥ ë§ì´ ë³µì œëœ ë¸”ë¡ì²´ì¸ì¼ ê²ƒì…ë‹ˆë‹¤. ì´ë¥¼ ì‹¤í–‰í•˜ëŠ” ì—¬ëŸ¬ ë…¸ë“œëŠ” PoW í•©ì˜ ì•Œê³ ë¦¬ì¦˜ì— ë”°ë¼ íŠ¸ëœì­ì…˜ì„ ì£¼ë¬¸í•©ë‹ˆë‹¤. ìƒˆ ë¸”ë¡ì„ ì¶”ê°€í•˜ë ¤ë©´ ê° ë…¸ë“œê°€ ì¼ì •ëŸ‰ì˜ ì‘ì—…ì„ ìˆ˜í–‰í–ˆìŒì„ ì¦ëª…í•´ì•¼ í•©ë‹ˆë‹¤. ì •í™•í•˜ê²Œ ë§í•˜ë©´, ê·¸ë“¤ì€ ë†’ì€ ê³„ì‚° ì…ë ¥ì„ ì‚¬ìš©í•˜ì—¬ ì–´ë ¤ìš´ í•´ì‹± í¼ì¦ì„ í’‰ë‹ˆë‹¤.\nAs a result, participation in PoW carries a cost but can be implemented in an environment without trust. Since it suits permissionless blockchains, anybody can join the network. Although the scalability of peer networks is high, the transaction speed remains low. Another concern is the decrease of the reward over time and low fees in future; generally, miners join to get rich, not to voluntarily support the network.\nê²°ê³¼ì ìœ¼ë¡œ PoW ì°¸ì—¬ì—ëŠ” ë¹„ìš©ì´ ë”°ë¥´ì§€ë§Œ ì‹ ë¢°ê°€ ì—†ëŠ” í™˜ê²½ì—ì„œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¬´í—ˆê°€ ë¸”ë¡ì²´ì¸ì— ì í•©í•˜ê¸° ë•Œë¬¸ì— ëˆ„êµ¬ë‚˜ ë„¤íŠ¸ì›Œí¬ì— ì°¸ì—¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í”¼ì–´ ë„¤íŠ¸ì›Œí¬ì˜ í™•ì¥ì„±ì€ ë†’ì§€ë§Œ íŠ¸ëœì­ì…˜ ì†ë„ëŠ” ì—¬ì „íˆ ë‚®ìŠµë‹ˆë‹¤. ë˜ ë‹¤ë¥¸ ë¬¸ì œëŠ” ì‹œê°„ì´ ì§€ë‚¨ì— ë”°ë¼ ë³´ìƒì´ ê°ì†Œí•˜ê³  í–¥í›„ ìˆ˜ìˆ˜ë£Œê°€ ë‚®ì•„ì§„ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ê´‘ë¶€ë“¤ì€ ë„¤íŠ¸ì›Œí¬ë¥¼ ìë°œì ìœ¼ë¡œ ì§€ì›í•˜ê¸° ìœ„í•´ ê°€ì…í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ë¶€ìê°€ ë˜ê¸° ìœ„í•´ ê°€ì…í•©ë‹ˆë‹¤.\nProof-of-Stake protocols Proof-of-Stake (PoS)    Concept: Proof-of-Stake (PoS)     Principle: The network trusts the validator who stakes their own coins; the bigger the stake the higher the chances of validating transactions.   Speed: Low   DLT setup: Public/private blockchain   Finality: Probabilistic   Example of use: NXT, Tezos, soon Ethereum    Turing-complete, Ethereumâ€™s main network, is running on PoW. However, the project plans to switch to a more efficient protocol known as Proof-of-Stake in 2018. The unique feature of PoS is the absence of difficult and unnecessary computation. Instead of competing with others, network members deposit their crypto-assets, like ether in Ethereum, and wait to be randomly picked to process a validation of the network.\nì´ë”ë¦¬ì›€ì˜ ë©”ì¸ ë„¤íŠ¸ì›Œí¬ì¸ Turing-completeê°€ PoWì—ì„œ ì‹¤í–‰ë˜ê³  ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ í”„ë¡œì íŠ¸ëŠ” 2018ë…„ì— Proof-of-Stakeë¡œ ì•Œë ¤ì§„ ë³´ë‹¤ íš¨ìœ¨ì ì¸ í”„ë¡œí† ì½œë¡œ ì „í™˜í•  ê³„íšì…ë‹ˆë‹¤. PoSì˜ ê³ ìœ í•œ íŠ¹ì§•ì€ ì–´ë µê³  ë¶ˆí•„ìš”í•œ ê³„ì‚°ì´ ì—†ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ë‹¤ë¥¸ ì‚¬ëŒë“¤ê³¼ ê²½ìŸí•˜ëŠ” ëŒ€ì‹  ë„¤íŠ¸ì›Œí¬ êµ¬ì„±ì›ì€ ì´ë”ë¦¬ì›€ê³¼ ê°™ì€ ì•”í˜¸í™” ìì‚°ì„ ì´ë”ë¦¬ì›€ì— ì˜ˆì¹˜í•˜ê³  ë„¤íŠ¸ì›Œí¬ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ë¬´ì‘ìœ„ë¡œ ì„ íƒë˜ê¸°ë¥¼ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.\nIf theyâ€™ve followed the rules, the staker creates or â€œmintsâ€ additional coins for validating a block of transactions. An algorithm selects one of the minters based on the stake they own. So if a node has a 5% stake, it will validate 5% of the transactions. The idea is that the higher the stake of the validator in the underlying cryptocurrency, the less interest they have in corrupting the validation process.\nê·¸ë“¤ì´ ê·œì¹™ì„ ë”°ëë‹¤ë©´ ìŠ¤í…Œì´ì»¤ëŠ” ê±°ë˜ ë¸”ë¡ì„ ê²€ì¦í•˜ê¸° ìœ„í•´ ì¶”ê°€ ì½”ì¸ì„ ìƒì„±í•˜ê±°ë‚˜ \u0026ldquo;ë°œí–‰\u0026quot;í•©ë‹ˆë‹¤. ì•Œê³ ë¦¬ì¦˜ì€ ê·¸ë“¤ì´ ì†Œìœ í•œ ì§€ë¶„ì„ ê¸°ë°˜ìœ¼ë¡œ ë°œí–‰ì ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•©ë‹ˆë‹¤. ë”°ë¼ì„œ ë…¸ë“œì— 5%ì˜ ì§€ë¶„ì´ ìˆìœ¼ë©´ íŠ¸ëœì­ì…˜ì˜ 5%ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤. ê¸°ë³¸ ì•”í˜¸ í™”íì—ì„œ ìœ íš¨ì„± ê²€ì‚¬ê¸°ì˜ ì§€ë¶„ì´ ë†’ì„ìˆ˜ë¡ ìœ íš¨ì„± ê²€ì‚¬ í”„ë¡œì„¸ìŠ¤ë¥¼ ì†ìƒì‹œí‚¤ëŠ” ë° ê´€ì‹¬ì´ ì ì–´ì§‘ë‹ˆë‹¤.\nJust like with PoW algorithm, transaction finality in PoS is probabilistic. Though transactions are relatively fast compared to those of Bitcoin, it still requires tokens to work. Furthermore, skeptics indicate that validators with high stakes will be selected more often and thus obtain even more tokens: the rich get richer.\nPoW ì•Œê³ ë¦¬ì¦˜ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ PoSì˜ íŠ¸ëœì­ì…˜ ì™„ê²°ì„±ì€ í™•ë¥ ì ì…ë‹ˆë‹¤. ê±°ë˜ëŠ” ë¹„íŠ¸ì½”ì¸ì— ë¹„í•´ ìƒëŒ€ì ìœ¼ë¡œ ë¹ ë¥´ì§€ë§Œ ì‘ë™í•˜ë ¤ë©´ ì—¬ì „íˆ í† í°ì´ í•„ìš”í•©ë‹ˆë‹¤. ë˜í•œ íšŒì˜ë¡ ìë“¤ì€ ë†’ì€ ì§€ë¶„ì„ ê°€ì§„ ê²€ì¦ì¸ì´ ë” ìì£¼ ì„ íƒë˜ì–´ ë” ë§ì€ í† í°ì„ ì–»ê²Œ ë  ê²ƒì´ë¼ê³  ë§í•©ë‹ˆë‹¤. ë¶€ìëŠ” ë” ë¶€ìê°€ ë©ë‹ˆë‹¤.\nHowever, the PoS algorithm doesnâ€™t incentivize those who donâ€™t expend any cryptocurrency. Consequently, they are likely to vote on multiple blocks to support â€œforksâ€ â€” copies of the blockchain with a new set of rules â€” while seeking to maximize the reward. This is called â€œnothing at stakeâ€ problem. On the other hand, the primary incentive to support the algorithm while running own node is securing funds rather than assuming that exchanges will do this for you.\nê·¸ëŸ¬ë‚˜ PoS ì•Œê³ ë¦¬ì¦˜ì€ ì•”í˜¸í™”íë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì‚¬ëŒë“¤ì—ê²Œ ì¸ì„¼í‹°ë¸Œë¥¼ ì œê³µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê²°ê³¼ì ìœ¼ë¡œ, ê·¸ë“¤ì€ ë³´ìƒì„ ìµœëŒ€í™”í•˜ëŠ” ë™ì‹œì— \u0026ldquo;í¬í¬\u0026rdquo;(ìƒˆë¡œìš´ ê·œì¹™ ì„¸íŠ¸ê°€ ìˆëŠ” ë¸”ë¡ì²´ì¸ì˜ ì‚¬ë³¸)ë¥¼ ì§€ì›í•˜ê¸° ìœ„í•´ ì—¬ëŸ¬ ë¸”ë¡ì— íˆ¬í‘œí•  ê°€ëŠ¥ì„±ì´ ë†’ìŠµë‹ˆë‹¤. ì´ê²ƒì„ \u0026ldquo;ìœ„í—˜í•˜ì§€ ì•Šì€ ë¬¸ì œ(?)\u0026ldquo;ë¼ê³  í•©ë‹ˆë‹¤. ë°˜ë©´ì— ìì²´ ë…¸ë“œë¥¼ ì‹¤í–‰í•˜ëŠ” ë™ì•ˆ ì•Œê³ ë¦¬ì¦˜ì„ ì§€ì›í•˜ëŠ” ì£¼ìš” ì¸ì„¼í‹°ë¸ŒëŠ” ê±°ë˜ì†Œê°€ ì´ë¥¼ ìˆ˜í–‰í•  ê²ƒì´ë¼ê³  ê°€ì •í•˜ê¸° ë³´ë‹¤ëŠ” ìê¸ˆì„ í™•ë³´í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.\nDelegated Proof-of-Stake (DPoS)    Concept: Delegated Proof-of-Stake (DPoS)     Principle: The participants delegate production of new blocks to a small and fixed number of elected participants. Highly competitive but highly profitable.   Speed: High   DLT setup: Public/private blockchain   Finality: Probabilistic   Example of use: EOS, BitShares    In the meantime, developers offered an alternative economic incentive called the Delegated Proof-of-Stake or DPoS. It allows you to generate blocks at high speed and handle a large number of transactions per second compared to other consensus algorithms. The basic principle of DPoS is to divide the voting and validation procedure among a few delegated participants.\nê·¸ ë™ì•ˆ ê°œë°œìë“¤ì€ ìœ„ì„ ì§€ë¶„ ì¦ëª… ë˜ëŠ” DPoSë¼ëŠ” ëŒ€ì•ˆì ì¸ ê²½ì œì  ì¸ì„¼í‹°ë¸Œë¥¼ ì œê³µí–ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ í•©ì˜ ì•Œê³ ë¦¬ì¦˜ì— ë¹„í•´ ë¹ ë¥¸ ì†ë„ë¡œ ë¸”ë¡ì„ ìƒì„±í•˜ê³  ì´ˆë‹¹ ë§ì€ ìˆ˜ì˜ íŠ¸ëœì­ì…˜ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. DPoSì˜ ê¸°ë³¸ ì›ì¹™ì€ íˆ¬í‘œ ë° ê²€ì¦ ì ˆì°¨ë¥¼ ìœ„ì„ëœ ì†Œìˆ˜ì˜ ì°¸ê°€ìì—ê²Œ ë‚˜ëˆ„ëŠ” ê²ƒì…ë‹ˆë‹¤.\nDuring voting, coin holders choose the validators of transactions that will form blocks. The weight of each vote is determined by the sum of the assets of the voter. Coin holders can re-vote candidates at any time. This determines the high resilience of the network: if most of the performers fail, the community will immediately vote for their replacement.\níˆ¬í‘œí•˜ëŠ” ë™ì•ˆ ì½”ì¸ ë³´ìœ ìëŠ” ë¸”ë¡ì„ í˜•ì„±í•  ê±°ë˜ì˜ ìœ íš¨ì„± ê²€ì‚¬ê¸°ë¥¼ ì„ íƒí•©ë‹ˆë‹¤. ê° íˆ¬í‘œì˜ ê°€ì¤‘ì¹˜ëŠ” ìœ ê¶Œì ìì‚°ì˜ í•©ê³„ë¡œ ê²°ì •ë©ë‹ˆë‹¤. ì½”ì¸ ë³´ìœ ìëŠ” ì–¸ì œë“ ì§€ í›„ë³´ìì—ê²Œ ì¬íˆ¬í‘œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ ë„¤íŠ¸ì›Œí¬ì˜ ë†’ì€ íƒ„ë ¥ì„±ì„ ê²°ì •í•©ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ ìˆ˜í–‰ìê°€ ì‹¤íŒ¨í•˜ë©´ ì»¤ë®¤ë‹ˆí‹°ëŠ” ì¦‰ì‹œ êµì²´ì— íˆ¬í‘œí•©ë‹ˆë‹¤.\nThe generation of new blocks happens every 1 or 2 seconds. This protocol is not only faster, but more fair since the â€œdelegatedâ€ validator shares newly minted coins with its voters later. However, confirmation is still needed from all validators. Therefore, a user may have to wait around twenty more blocks to ensure the validity of the transaction.\nìƒˆ ë¸”ë¡ì˜ ìƒì„±ì€ 1ì´ˆ ë˜ëŠ” 2ì´ˆë§ˆë‹¤ ë°œìƒí•©ë‹ˆë‹¤. ì´ í”„ë¡œí† ì½œì€ \u0026ldquo;ìœ„ì„ëœ\u0026rdquo; ê²€ì¦ìê°€ ë‚˜ì¤‘ì— ìœ ê¶Œìì™€ ìƒˆë¡œ ë°œí–‰ëœ ì½”ì¸ì„ ê³µìœ í•˜ê¸° ë•Œë¬¸ì— ë” ë¹ ë¥¼ ë¿ë§Œ ì•„ë‹ˆë¼ ë” ê³µì •í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì—¬ì „íˆ ëª¨ë“  ê²€ì¦ì¸ì˜ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤. ë”°ë¼ì„œ ì‚¬ìš©ìëŠ” íŠ¸ëœì­ì…˜ì˜ ìœ íš¨ì„±ì„ í™•ì¸í•˜ê¸° ìœ„í•´ ì•½ 20ê°œì˜ ë¸”ë¡ì„ ë” ê¸°ë‹¤ë ¤ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\nDaniel Larimer developed DPoS in 2014. He first used it in his BitShares project, and later in Steemit and EOS. Larimer hypothesized that validators in DPoS will have a strong incentive to remain fair and offer the fastest and best service possible. After all, it would be silly to hack a network that pays you well. And if you stop doing a good job, there are other members that are ready and willing to take the place of the validator.\nDaniel LarimerëŠ” 2014ë…„ì— DPoSë¥¼ ê°œë°œí–ˆìŠµë‹ˆë‹¤. ê·¸ëŠ” BitShares í”„ë¡œì íŠ¸ì—ì„œ ì²˜ìŒìœ¼ë¡œ DPoSë¥¼ ì‚¬ìš©í–ˆê³  ë‚˜ì¤‘ì—ëŠ” Steemitê³¼ EOSì—ì„œ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. LarimerëŠ” DPoSì˜ ê²€ì¦ì¸ì´ ê³µì •ì„±ì„ ìœ ì§€í•˜ê³  ê°€ëŠ¥í•œ ê°€ì¥ ë¹ ë¥´ê³  ìµœê³ ì˜ ì„œë¹„ìŠ¤ë¥¼ ì œê³µí•  ê°•ë ¥í•œ ì¸ì„¼í‹°ë¸Œë¥¼ ê°€ì§ˆ ê²ƒì´ë¼ê³  ê°€ì •í–ˆìŠµë‹ˆë‹¤. ê²°êµ­ ëˆì„ ì˜ ë²„ëŠ” ë„¤íŠ¸ì›Œí¬ë¥¼ í•´í‚¹í•˜ëŠ” ê²ƒì€ ì–´ë¦¬ì„ì€ ì¼ì…ë‹ˆë‹¤. ê·¸ë¦¬ê³  ë‹¹ì‹ ì´ ì¢‹ì€ ì¼ì„ ê·¸ë§Œë‘”ë‹¤ë©´, ê²€ì¦ì¸ì„ ëŒ€ì‹ í•  ì¤€ë¹„ê°€ ë˜ì–´ ìˆê³  ê¸°êº¼ì´ í•˜ëŠ” ë‹¤ë¥¸ êµ¬ì„±ì›ì´ ìˆìŠµë‹ˆë‹¤.\nByzantine Fault Tolerance (BFT) protocols So far weâ€™ve been talking about public blockchains that operate in a trustless environment and aim at decentralization. What about private enterprise blockchains? What if participants can trust each other? Itâ€™s true that the fewer validators a blockchain has, the faster it is. In fact, the speed increases tenfold, from hundreds to thousands of transactions per second, which is a great fit for corporate blockchain solutions.\nì§€ê¸ˆê¹Œì§€ ìš°ë¦¬ëŠ” ë¬´ì‹ ë¢° í™˜ê²½ì—ì„œ ì‘ë™í•˜ê³  íƒˆì¤‘ì•™í™”ë¥¼ ëª©í‘œë¡œ í•˜ëŠ” í¼ë¸”ë¦­ ë¸”ë¡ì²´ì¸ì— ëŒ€í•´ ì´ì•¼ê¸°í–ˆìŠµë‹ˆë‹¤. ë¯¼ê°„ ê¸°ì—… ë¸”ë¡ì²´ì¸ì€ ì–´ë–»ìŠµë‹ˆê¹Œ? ì°¸ê°€ìë“¤ì´ ì„œë¡œë¥¼ ì‹ ë¢°í•  ìˆ˜ ìˆë‹¤ë©´ ì–´ë–¨ê¹Œìš”? ë¸”ë¡ì²´ì¸ì— ê²€ì¦ì¸ì´ ì ì„ìˆ˜ë¡ ë” ë¹ ë¥¸ ê²ƒì´ ì‚¬ì‹¤ì…ë‹ˆë‹¤. ì‹¤ì œë¡œ ì†ë„ëŠ” ì´ˆë‹¹ ìˆ˜ë°±ì—ì„œ ìˆ˜ì²œ ê°œì˜ íŠ¸ëœì­ì…˜ìœ¼ë¡œ 10ë°° ì¦ê°€í•˜ë¯€ë¡œ ê¸°ì—… ë¸”ë¡ì²´ì¸ ì†”ë£¨ì…˜ì— ë§¤ìš° ì í•©í•©ë‹ˆë‹¤.\nByzantine Fault Tolerance (BFT) protocol is a different class of protocols that does not require tokens during the voting as in a PoS algorithm. Furthermore, it allows signing of a block even when 1/3 of the actors fail or act maliciously. BFT resolves the problem of numerous faults in the system and the waiting time of up to 30 seconds for confirming a block.\nBFT(Byzantine Fault Tolerance) í”„ë¡œí† ì½œì€ PoS ì•Œê³ ë¦¬ì¦˜ì—ì„œì™€ ê°™ì´ íˆ¬í‘œ ì¤‘ì— í† í°ì´ í•„ìš”í•˜ì§€ ì•Šì€ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ í”„ë¡œí† ì½œì…ë‹ˆë‹¤. ë˜í•œ ì•¡í„°ì˜ 1/3ì´ ì‹¤íŒ¨í•˜ê±°ë‚˜ ì•…ì˜ì ìœ¼ë¡œ í–‰ë™í•˜ë”ë¼ë„ ë¸”ë¡ì— ì„œëª…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. BFTëŠ” ì‹œìŠ¤í…œì˜ ìˆ˜ë§ì€ ì¥ì• ì™€ ë¸”ë¡ í™•ì¸ì„ ìœ„í•œ ìµœëŒ€ 30ì´ˆì˜ ëŒ€ê¸° ì‹œê°„ ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤.\nIn fact, the algorithm refers to an old Byzantine Generalsâ€™ problem, based on a real historical event. Using the analogy, the protocol does not care if a â€œgeneralâ€ got sick or sabotaged the counterparts â€” the system will still function even when the node goes offline.\nì‚¬ì‹¤, ì•Œê³ ë¦¬ì¦˜ì€ ì‹¤ì œ ì—­ì‚¬ì  ì‚¬ê±´ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ì˜¤ë˜ëœ ë¹„ì”í‹´ ì¥êµ°ì˜ ë¬¸ì œë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ìœ ì¶”ë¥¼ ì‚¬ìš©í•˜ë©´ í”„ë¡œí† ì½œì€ \u0026ldquo;ì¥êµ°\u0026quot;ì´ ì•„í”„ê±°ë‚˜ ìƒëŒ€ë°©ì„ ë°©í•´í•˜ëŠ” ê²½ìš° ì‹ ê²½ ì“°ì§€ ì•ŠìŠµë‹ˆë‹¤. ë…¸ë“œê°€ ì˜¤í”„ë¼ì¸ ìƒíƒœê°€ ëœ ê²½ìš°ì—ë„ ì‹œìŠ¤í…œì€ ê³„ì† ì‘ë™í•©ë‹ˆë‹¤.\nDelegated Byzantine Fault Tolerance (DBFT)    Concept: Delegated Byzantine Fault Tolerance (DBFT)     Principle: Preselected nodes maintain consensus even if some of them fail or are malicious.   Speed: Very high   DLT setup: Public/private blockchain   Finality: Immediate   Example of use: NEO, TON    So the BFT consensus protocol seems like salvation from the imperfections of PoW and PoS, but given thousands of validators, it would still struggle to resolve the speed issue. This is why developers offered a delegated model of BFT â€” the DBFT.\nPredefined validators in this consensus protocol allow it to far outstrip other protocols. Take Ethereum with 15-20 transactions per second and NEO with almost 10,000 t/s. It is indeed convenient to have a few known actors who validate transactions before releasing to other nodes. In case a validator betrays the network, participants can delegate a different node.\nNote: since NEO runs on PoS DBFT protocol, the network members not only delegate validators but also receive a native token GAS as part of their validator stake.\në”°ë¼ì„œ BFT í•©ì˜ í”„ë¡œí† ì½œì€ PoW ë° PoSì˜ ë¶ˆì™„ì „í•¨ì—ì„œ êµ¬ì›ë°›ëŠ” ê²ƒì²˜ëŸ¼ ë³´ì´ì§€ë§Œ ìˆ˜ì²œ ëª…ì˜ ê²€ì¦ì¸ì„ ê³ ë ¤í•  ë•Œ ì†ë„ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë° ì—¬ì „íˆ ì–´ë ¤ì›€ì„ ê²ªì„ ê²ƒì…ë‹ˆë‹¤. ì´ê²ƒì´ ê°œë°œìë“¤ì´ BFTì˜ ìœ„ì„ ëª¨ë¸ì¸ DBFTë¥¼ ì œì•ˆí•œ ì´ìœ ì…ë‹ˆë‹¤.\nì´ í•©ì˜ í”„ë¡œí† ì½œì˜ ì‚¬ì „ ì •ì˜ëœ ê²€ì¦ìëŠ” ë‹¤ë¥¸ í”„ë¡œí† ì½œì„ í›¨ì”¬ ëŠ¥ê°€í•©ë‹ˆë‹¤. ì´ˆë‹¹ 15-20ê°œì˜ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì´ë”ë¦¬ì›€ì„, ê±°ì˜ 10,000t/së¡œ NEOë¥¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤. ë‹¤ë¥¸ ë…¸ë“œì— ë¦´ë¦¬ìŠ¤í•˜ê¸° ì „ì— íŠ¸ëœì­ì…˜ì„ ê²€ì¦í•˜ëŠ” ì•Œë ¤ì§„ í–‰ìœ„ìê°€ ëª‡ ëª… ìˆëŠ” ê²ƒì´ ì°¸ìœ¼ë¡œ í¸ë¦¬í•©ë‹ˆë‹¤. ê²€ì¦ì¸ì´ ë„¤íŠ¸ì›Œí¬ë¥¼ ë°°ì‹ í•˜ëŠ” ê²½ìš° ì°¸ê°€ìëŠ” ë‹¤ë¥¸ ë…¸ë“œë¥¼ ìœ„ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\nì°¸ê³ : NEOëŠ” PoS DBFT í”„ë¡œí† ì½œì—ì„œ ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ì— ë„¤íŠ¸ì›Œí¬ êµ¬ì„±ì›ì€ ê²€ì¦ì¸ì„ ìœ„ì„í•  ë¿ë§Œ ì•„ë‹ˆë¼ ê²€ì¦ì¸ ì§€ë¶„ì˜ ì¼ë¶€ë¡œ ê¸°ë³¸ í† í° GASë¥¼ ë°›ìŠµë‹ˆë‹¤.\nPractical Byzantine Fault Tolerance (PBFT)    Concept: Practical Byzantine Fault Tolerance (PBFT)     Principle: Standard blockchain for enterprise.   Speed: High   DLT setup: Private permissioned blockchain   Finality: Immediate   Example of use: Hyperledger, Chain    If one wants a scalable and fast blockchain, this is a way to go. PBFT protocol is very similar to DBFT, especially in regard to its more centralized nature. The only difference is that the former has a simpler implementation and is often a private blockchain with appointed signing nodes from the very beginning. Which is kind of practical, isnâ€™t it?\nWhen a validator receives a message, it performs a computation, and then asks all other nodes in turn if the transaction is valid. After confirming validation, the first validator broadcasts the decision to the network of other validators. In this way, consensus is achieved based on the confirmation being submitted by all validators.\nPBFT is effective in low latency systems but sensitive to the number of validators and throughput. It fits well for private setups which donâ€™t require a large amount of capacity, but demand many transactions. PBFT guarantees the accuracy of transaction records within the network.\nYou may also have encountered SIEVE protocol which is a type of PBFT. It handles non-deterministic chaincode execution. There is also Cross Fault Tolerance (XFT) protocol as well as Paxos and Raft protocols which are Crash Fault Tolerant (CFT). We might cover these deep technical characteristics in future articles but if itâ€™s important to you, you could always ask us.\ní™•ì¥ ê°€ëŠ¥í•˜ê³  ë¹ ë¥¸ ë¸”ë¡ì²´ì¸ì„ ì›í•œë‹¤ë©´ ì´ê²ƒì´ ë°”ë¡œ ê°ˆ ê¸¸ì…ë‹ˆë‹¤. PBFT í”„ë¡œí† ì½œì€ íŠ¹íˆ ì¤‘ì•™ ì§‘ì¤‘ì‹ íŠ¹ì„±ê³¼ ê´€ë ¨í•˜ì—¬ DBFTì™€ ë§¤ìš° ìœ ì‚¬í•©ë‹ˆë‹¤. ìœ ì¼í•œ ì°¨ì´ì ì€ ì „ìëŠ” êµ¬í˜„ì´ ë” ê°„ë‹¨í•˜ê³  ì²˜ìŒë¶€í„° ì„œëª… ë…¸ë“œê°€ ì§€ì •ëœ í”„ë¼ì´ë¹— ë¸”ë¡ì²´ì¸ì¸ ê²½ìš°ê°€ ë§ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ì–´ë–¤ ê²ƒì´ ì‹¤ìš©ì ì´ì§€ ì•ŠìŠµë‹ˆê¹Œ?\nìœ íš¨ì„± ê²€ì‚¬ê¸°ëŠ” ë©”ì‹œì§€ë¥¼ ìˆ˜ì‹ í•˜ë©´ ê³„ì‚°ì„ ìˆ˜í–‰í•œ ë‹¤ìŒ íŠ¸ëœì­ì…˜ì´ ìœ íš¨í•œì§€ ë‹¤ë¥¸ ëª¨ë“  ë…¸ë“œì— ì°¨ë¡€ë¡œ ë¬»ìŠµë‹ˆë‹¤. ìœ íš¨ì„± ê²€ì‚¬ë¥¼ í™•ì¸í•œ í›„ ì²« ë²ˆì§¸ ìœ íš¨ì„± ê²€ì‚¬ìëŠ” ê²°ì •ì„ ë‹¤ë¥¸ ìœ íš¨ì„± ê²€ì‚¬ìì˜ ë„¤íŠ¸ì›Œí¬ì— ë¸Œë¡œë“œìºìŠ¤íŠ¸í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ë°©ì‹ìœ¼ë¡œ ëª¨ë“  ê²€ì¦ìê°€ ì œì¶œí•œ í™•ì¸ì„ ê¸°ë°˜ìœ¼ë¡œ í•©ì˜ê°€ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.\nPBFTëŠ” ëŒ€ê¸° ì‹œê°„ì´ ì§§ì€ ì‹œìŠ¤í…œì—ì„œ íš¨ê³¼ì ì´ì§€ë§Œ ê²€ì¦ì¸ì˜ ìˆ˜ì™€ ì²˜ë¦¬ëŸ‰ì— ë¯¼ê°í•©ë‹ˆë‹¤. ë§ì€ ìš©ëŸ‰ì„ í•„ìš”ë¡œ í•˜ì§€ ì•Šì§€ë§Œ ë§ì€ íŠ¸ëœì­ì…˜ì„ ìš”êµ¬í•˜ëŠ” ê°œì¸ ì„¤ì •ì— ì í•©í•©ë‹ˆë‹¤. PBFTëŠ” ë„¤íŠ¸ì›Œí¬ ë‚´ ê±°ë˜ ê¸°ë¡ì˜ ì •í™•ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.\në˜í•œ PBFT ìœ í˜•ì¸ SIEVE í”„ë¡œí† ì½œì„ ì ‘í–ˆì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ë¹„ê²°ì •ì  ì²´ì¸ì½”ë“œ ì‹¤í–‰ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤. XFT(Cross Fault Tolerance) í”„ë¡œí† ì½œê³¼ CFT(Crash Fault Tolerant)ì¸ Paxos ë° Raft í”„ë¡œí† ì½œë„ ìˆìŠµë‹ˆë‹¤. ìš°ë¦¬ëŠ” í–¥í›„ ê¸°ì‚¬ì—ì„œ ì´ëŸ¬í•œ ì‹¬ì¸µì ì¸ ê¸°ìˆ ì  íŠ¹ì„±ì„ ë‹¤ë£° ìˆ˜ ìˆì§€ë§Œ ê·¸ê²ƒì´ ë‹¹ì‹ ì—ê²Œ ì¤‘ìš”í•˜ë‹¤ë©´ ì–¸ì œë“ ì§€ Googleì— ë¬¸ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\nFederated Byzantine Agreement (FBA)    Concept: Federated Byzantine Agreement (FBA)     Principle: Blocks are validated if signed by a specified quorum of signers.   Speed: High   DLT setup: Public or private permissionless blockchain   Finality: Immediate   Example of use: Stellar, Ripple    Here you have a permissionless BFT protocol as opposed to the permissioned PBFT and other variants of BFT. A Federated Byzantine Agreement (FBA) allows anybody to join the network but transactions are verified by a group instead of one node broadcasting the message to others.\nNotably, FBA has Gateways and Market-Makers which ensure the fairness and liquidity of the network. The former act as traditional banks holding the fiat funds and creating an equivalent in virtual tokens. Market-makers keep accounts with multiple Gateways and in several currencies.\nì—¬ê¸°ì—ëŠ” í—ˆê°€ëœ PBFT ë° ê¸°íƒ€ BFT ë³€í˜•ê³¼ ë‹¬ë¦¬ í—ˆê°€ ì—†ëŠ” BFT í”„ë¡œí† ì½œì´ ìˆìŠµë‹ˆë‹¤. FBA(Federated Byzantine Agreement)ë¥¼ í†µí•´ ëˆ„êµ¬ë‚˜ ë„¤íŠ¸ì›Œí¬ì— ê°€ì…í•  ìˆ˜ ìˆì§€ë§Œ íŠ¸ëœì­ì…˜ì€ í•œ ë…¸ë“œê°€ ë©”ì‹œì§€ë¥¼ ë‹¤ë¥¸ ë…¸ë“œì— ë¸Œë¡œë“œìºìŠ¤íŒ…í•˜ëŠ” ëŒ€ì‹  ê·¸ë£¹ì— ì˜í•´ í™•ì¸ë©ë‹ˆë‹¤.\níŠ¹íˆ FBAì—ëŠ” ë„¤íŠ¸ì›Œí¬ì˜ ê³µì •ì„±ê³¼ ìœ ë™ì„±ì„ ë³´ì¥í•˜ëŠ” ê²Œì´íŠ¸ì›¨ì´ ë° ë§ˆì¼“ ë©”ì´ì»¤ê°€ ìˆìŠµë‹ˆë‹¤. ì „ìëŠ” ëª…ëª© í€ë“œë¥¼ ë³´ìœ í•˜ê³  ê°€ìƒ í† í°ìœ¼ë¡œ ì´ì— ìƒì‘í•˜ëŠ” ê²ƒì„ ìƒì„±í•˜ëŠ” ì „í†µì ì¸ ì€í–‰ ì—­í• ì„ í•©ë‹ˆë‹¤. ì‹œì¥ ì¡°ì„±ìëŠ” ì—¬ëŸ¬ ê²Œì´íŠ¸ì›¨ì´ì™€ ì—¬ëŸ¬ í†µí™”ë¡œ ê³„ì •ì„ ìœ ì§€í•©ë‹ˆë‹¤.\nQuick Review   â€¢ Proof-of-Work has been the first and most reliable consensus protocol for public blockchains like Bitcoin and Ethereum, yet it is energy-inefficient.\n  â€¢ Proof-of-Stake does not require hard computation. Instead, it encourages users to stake their own funds to perform the equivalent quantity of transaction validations and assumes everyone will act rationally.\n  â€¢ BFT is an addition to PoS concept that makes it much faster and more tolerant to faulty nodes. Itâ€™s only practical to run on small and private setups though.\n  â€¢ PBFT is a proven solution for corporate blockchains. Fast and safe but relies on throughput.\n  â€¢ DBFT improves BFT by allowing participants of the BFT network to delegate their validators. Very fast but more centralized.\n  â€¢ While the abovementioned BFT variants are permissioned blockchains, FBA is federated and, thus, permissionless. But there are more protocolsâ€¦\n  â€¢ ì‘ì—… ì¦ëª…ì€ ë¹„íŠ¸ì½”ì¸ ë° ì´ë”ë¦¬ì›€ê³¼ ê°™ì€ ê³µê°œ ë¸”ë¡ì²´ì¸ì„ ìœ„í•œ ìµœì´ˆì´ì ê°€ì¥ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” í•©ì˜ í”„ë¡œí† ì½œì´ì§€ë§Œ ì—ë„ˆì§€ ë¹„íš¨ìœ¨ì ì…ë‹ˆë‹¤.\n  â€¢ ì§€ë¶„ ì¦ëª…ì€ ì–´ë ¤ìš´ ê³„ì‚°ì„ í•„ìš”ë¡œ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ëŒ€ì‹ , ì‚¬ìš©ìê°€ ë™ì¼í•œ ì–‘ì˜ ê±°ë˜ ê²€ì¦ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ ìì‹ ì˜ ìê¸ˆì„ ê±¸ë„ë¡ ê¶Œì¥í•˜ê³  ëª¨ë“  ì‚¬ëŒì´ í•©ë¦¬ì ìœ¼ë¡œ í–‰ë™í•  ê²ƒì´ë¼ê³  ê°€ì •í•©ë‹ˆë‹¤.\n  â€¢ BFTëŠ” PoS ê°œë…ì— ì¶”ê°€ëœ ê²ƒìœ¼ë¡œ ê²°í•¨ì´ ìˆëŠ” ë…¸ë“œì— ëŒ€í•´ í›¨ì”¬ ë¹ ë¥´ê³  ê´€ëŒ€í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì†Œê·œëª¨ ë° ê°œì¸ ì„¤ì •ì—ì„œë§Œ ì‹¤í–‰í•˜ëŠ” ê²ƒì´ ì‹¤ìš©ì ì…ë‹ˆë‹¤.\n  â€¢ PBFTëŠ” ê¸°ì—… ë¸”ë¡ì²´ì¸ì„ ìœ„í•œ ê²€ì¦ëœ ì†”ë£¨ì…˜ì…ë‹ˆë‹¤. ë¹ ë¥´ê³  ì•ˆì „í•˜ì§€ë§Œ ì²˜ë¦¬ëŸ‰ì— ì˜ì¡´í•©ë‹ˆë‹¤.\n  â€¢ DBFTëŠ” BFT ë„¤íŠ¸ì›Œí¬ ì°¸ê°€ìê°€ ê²€ì¦ì¸ì„ ìœ„ì„í•  ìˆ˜ ìˆë„ë¡ í•˜ì—¬ BFTë¥¼ ê°œì„ í•©ë‹ˆë‹¤. ë§¤ìš° ë¹ ë¥´ì§€ë§Œ ë” ì¤‘ì•™ ì§‘ì¤‘í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.\n  â€¢ ìœ„ì—ì„œ ì–¸ê¸‰í•œ BFT ë³€ì¢…ì€ í—ˆê°€ëœ ë¸”ë¡ì²´ì¸ì´ì§€ë§Œ FBAëŠ” ì—°í•©ë˜ì–´ ìˆìœ¼ë¯€ë¡œ í—ˆê°€ê°€ ì—†ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ë” ë§ì€ í”„ë¡œí† ì½œì´ ìˆìŠµë‹ˆë‹¤ \u0026hellip;\n  Directed Acyclic Graph protocol Researcher Serguei Popov ran a thought experiment: what if we can avoid blocks completely?\nSerguei Popov ì—°êµ¬ì›ì€ ì‚¬ê³  ì‹¤í—˜ì„ ì‹¤í–‰í–ˆìŠµë‹ˆë‹¤. ë¸”ë¡ì„ ì™„ì „íˆ í”¼í•  ìˆ˜ ìˆë‹¤ë©´ ì–´ë–¨ê¹Œìš”?\nDirected Acyclic Graph (DAG)    Concept: Directed Acyclic Graph (DAG)     Principle: No fixed blocks that are confirmed in a random order on a linear scale.   Speed: High   DLT setup: Public permissioned non-blockchain   Finality: Probabilistic   Example of use: IOTA, ByteBall    The major issue with blockchain is its synchronous nature. Blockchains cannot be parallel. One can change the size or frequency of blocks as well as the parties that approve them, but there will always be a waiting queue. Alternately, Directed Acyclic Graph (DAG) technology is asynchronous which gives the competitive advantage of simultaneous events.\nThe protocol in such systems lets participants confirm a block of transactions a few blocks away, since there will eventually be another participant proving it is correct. While this implies ultra high speeds for the network, itâ€™s slow on a smaller scale. Additionally, thereâ€™s a danger of parasite â€œchainsâ€ of non-valid transactions and centralization due to preselected validators.\në¸”ë¡ì²´ì¸ì˜ ì£¼ìš” ë¬¸ì œëŠ” ë™ê¸°ì  íŠ¹ì„±ì…ë‹ˆë‹¤. ë¸”ë¡ì²´ì¸ì€ ë³‘ë ¬ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¸”ë¡ì˜ í¬ê¸°ë‚˜ ë¹ˆë„ì™€ ë¸”ë¡ì„ ìŠ¹ì¸í•˜ëŠ” ë‹¹ì‚¬ìë¥¼ ë³€ê²½í•  ìˆ˜ ìˆì§€ë§Œ í•­ìƒ ëŒ€ê¸° ëŒ€ê¸°ì—´ì´ ìˆìŠµë‹ˆë‹¤. ë˜ëŠ” DAG(Directed Acyclic Graph) ê¸°ìˆ ì€ ë™ì‹œ ì´ë²¤íŠ¸ì˜ ê²½ìŸ ìš°ìœ„ë¥¼ ì œê³µí•˜ëŠ” ë¹„ë™ê¸°ì‹ì…ë‹ˆë‹¤.\nì´ëŸ¬í•œ ì‹œìŠ¤í…œì˜ í”„ë¡œí† ì½œì„ ì‚¬ìš©í•˜ë©´ ì°¸ê°€ìê°€ ëª‡ ë¸”ë¡ ë–¨ì–´ì§„ ê³³ì—ì„œ íŠ¸ëœì­ì…˜ ë¸”ë¡ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê²°êµ­ ë‹¤ë¥¸ ì°¸ê°€ìê°€ ê·¸ê²ƒì´ ì˜³ë‹¤ëŠ” ê²ƒì„ ì¦ëª…í•  ê²ƒì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì´ê²ƒì€ ë„¤íŠ¸ì›Œí¬ì˜ ì´ˆê³ ì† ì†ë„ë¥¼ ì˜ë¯¸í•˜ì§€ë§Œ ì†Œê·œëª¨ì—ì„œëŠ” ëŠë¦½ë‹ˆë‹¤. ë˜í•œ ì‚¬ì „ ì„ íƒëœ ìœ íš¨ì„± ê²€ì‚¬ê¸°ë¡œ ì¸í•´ ìœ íš¨í•˜ì§€ ì•Šì€ ê±°ë˜ ë° ì¤‘ì•™ ì§‘ì¤‘í™”ì˜ ê¸°ìƒ \u0026ldquo;ì²´ì¸\u0026quot;ì˜ ìœ„í—˜ì´ ìˆìŠµë‹ˆë‹¤.\nHashGraph    Concept: HashGraph     Principle: Nodes communicate randomly using the â€˜gossip about gossipâ€™ protocol and agree on consensus after a certain communication round.   Speed: Very High   DLT setup: Private permissioned non-blockchain   Finality: Round based   Example of use: HashGraph    The developers of this protocol claim that blockchain is an outdated system. As a substitute, they also advocate for the DAG concept. However, the key difference of HashGraph is a â€œgossip to gossipâ€ protocol, where a node receives a time-stamped set of transactions that the other node â€œknowsâ€ about. As a result, there is an endless hash tree â€” or a graph â€” that grows over time with millions of time-stamps, the leaves. Once the majority of the network agrees on a particular event, there is no doubt it is valid.\nThere are certain limitations however. First of all, there is little evidence of practical implementation on a large scale, especially when compared to working blockchain projects. Secondly, HashGraph technology is patented and acquiring a license costs money. This also leads to the third issue: the lack of a strong community (like those associated with open-source projects). Such a community can test the robustness of a protocol, its vulnerability towards hackers and issues of compatibility. HashGraph is currently available for private setup only.\nì´ í”„ë¡œí† ì½œì˜ ê°œë°œìëŠ” ë¸”ë¡ì²´ì¸ì´ êµ¬ì‹ ì‹œìŠ¤í…œì´ë¼ê³  ì£¼ì¥í•©ë‹ˆë‹¤. ëŒ€ì•ˆìœ¼ë¡œì„œ ê·¸ë“¤ì€ ë˜í•œ DAG ê°œë…ì„ ì˜¹í˜¸í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ HashGraphì˜ ì£¼ìš” ì°¨ì´ì ì€ \u0026ldquo;ê°€ì‹­ ëŒ€ ê°€ì‹­\u0026rdquo; í”„ë¡œí† ì½œë¡œ, í•œ ë…¸ë“œê°€ ë‹¤ë¥¸ ë…¸ë“œê°€ \u0026ldquo;ì•Œê³  ìˆëŠ”\u0026rdquo; íƒ€ì„ ìŠ¤íƒ¬í”„ íŠ¸ëœì­ì…˜ ì§‘í•©ì„ ìˆ˜ì‹ í•©ë‹ˆë‹¤. ê²°ê³¼ì ìœ¼ë¡œ ìˆ˜ë°±ë§Œ ê°œì˜ íƒ€ì„ ìŠ¤íƒ¬í”„ì™€ í•¨ê»˜ ì‹œê°„ì´ ì§€ë‚¨ì— ë”°ë¼ ì„±ì¥í•˜ëŠ” ëì—†ëŠ” í•´ì‹œ íŠ¸ë¦¬ ë˜ëŠ” ê·¸ë˜í”„ê°€ ìˆìŠµë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬ì˜ ê³¼ë°˜ìˆ˜ê°€ íŠ¹ì • ì´ë²¤íŠ¸ì— ë™ì˜í•˜ë©´ ê·¸ê²ƒì´ ìœ íš¨í•˜ë‹¤ëŠ” ë°ëŠ” ì˜ì‹¬ì˜ ì—¬ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.\nê·¸ëŸ¬ë‚˜ íŠ¹ì • ì œí•œ ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤. ìš°ì„ , íŠ¹íˆ ì‘ì—… ì¤‘ì¸ ë¸”ë¡ì²´ì¸ í”„ë¡œì íŠ¸ì™€ ë¹„êµí•  ë•Œ ëŒ€ê·œëª¨ë¡œ ì‹¤ì§ˆì ì¸ êµ¬í˜„ì— ëŒ€í•œ ì¦ê±°ê°€ ê±°ì˜ ì—†ìŠµë‹ˆë‹¤. ë‘˜ì§¸, HashGraph ê¸°ìˆ ì€ íŠ¹í—ˆë¥¼ ë°›ì•˜ê³  ë¼ì´ì„¼ìŠ¤ë¥¼ ì–»ëŠ” ë° ë¹„ìš©ì´ ë“­ë‹ˆë‹¤. ì´ê²ƒì€ ë˜í•œ ì„¸ ë²ˆì§¸ ë¬¸ì œë¡œ ì´ì–´ì§‘ë‹ˆë‹¤. ê°•ë ¥í•œ ì»¤ë®¤ë‹ˆí‹°(ì˜¤í”ˆ ì†ŒìŠ¤ í”„ë¡œì íŠ¸ì™€ ê´€ë ¨ëœ ì»¤ë®¤ë‹ˆí‹°ì™€ ê°™ì€)ì˜ ë¶€ì¡±ì…ë‹ˆë‹¤. ì´ëŸ¬í•œ ì»¤ë®¤ë‹ˆí‹°ëŠ” í”„ë¡œí† ì½œì˜ ê²¬ê³ ì„±, í•´ì»¤ì— ëŒ€í•œ ì·¨ì•½ì„± ë° í˜¸í™˜ì„± ë¬¸ì œë¥¼ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. HashGraphëŠ” í˜„ì¬ ë¹„ê³µê°œ ì„¤ì •ì—ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\nOther Consensus Protocols for Specific Tasks As if that wasnâ€™t enough, people have pushed technology and the imagination even further . More researchers and blockchain developers have experimented with new consensus models that would resolve different business challenges.\nê·¸ê²ƒìœ¼ë¡œ ì¶©ë¶„í•˜ì§€ ì•Šë‹¤ëŠ” ë“¯ì´ ì‚¬ëŒë“¤ì€ ê¸°ìˆ ê³¼ ìƒìƒë ¥ì„ ë”ìš± ë°€ì–´ë¶™ì˜€ìŠµë‹ˆë‹¤. ë” ë§ì€ ì—°êµ¬ì›ê³¼ ë¸”ë¡ì²´ì¸ ê°œë°œìê°€ ë‹¤ì–‘í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ê³¼ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆëŠ” ìƒˆë¡œìš´ í•©ì˜ ëª¨ë¸ì„ ì‹¤í—˜í–ˆìŠµë‹ˆë‹¤.\nProof-of-Activity (PoA)    Concept: Proof-of-Activity (PoA)     Principle: A hybrid of PoW and PoS   Speed: Low   DLT setup: Public permissionless blockchain   Finality: Probabilistic   Example of use: Decred    Proof-of-Activity (PoA) combines PoW and PoS protocols meaning that the participants can both mine and stake their coins to validate blocks. This way, the PoA protocol ensures a balance between miners and common participants of the network.\ní™œë™ ì¦ëª…(PoA)ì€ PoWì™€ PoS í”„ë¡œí† ì½œì„ ê²°í•©í•˜ì—¬ ì°¸ê°€ìê°€ ë¸”ë¡ì„ ê²€ì¦í•˜ê¸° ìœ„í•´ ì½”ì¸ì„ ì±„êµ´í•˜ê³  ìŠ¤í…Œì´í‚¹í•  ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ë°©ì‹ìœ¼ë¡œ PoA í”„ë¡œí† ì½œì€ ê´‘ë¶€ì™€ ë„¤íŠ¸ì›Œí¬ì˜ ì¼ë°˜ ì°¸ê°€ì ê°„ì˜ ê· í˜•ì„ ë³´ì¥í•©ë‹ˆë‹¤.\nProof-of-Location (PoL)    Concept: Proof-of-Location (PoL)     Principle: Use beacons to notice a node in a synchronized manner and then timestamp its presence.   Speed: Medium   DLT setup: Public permissionless blockchain   Finality: Immediate   Example of use: FOAM, Platin    Proof-of-Location (PoL) lets users privately record authenticated location data when they choose so, without GPS. Then, they can reveal this personal information at will.\nInterestingly, the protocol relies on the BFT of the beacons that record geolocation and timestamp it in the blockchain which prevents the system from failures and frauds.\nìœ„ì¹˜ ì¦ëª…(PoL)ì„ ì‚¬ìš©í•˜ë©´ ì‚¬ìš©ìê°€ ì›í•˜ëŠ” ê²½ìš° GPS ì—†ì´ ì¸ì¦ëœ ìœ„ì¹˜ ë°ì´í„°ë¥¼ ë¹„ê³µê°œë¡œ ê¸°ë¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ì´ ê°œì¸ ì •ë³´ë¥¼ ë§ˆìŒëŒ€ë¡œ ê³µê°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\ní¥ë¯¸ë¡­ê²Œë„ ì´ í”„ë¡œí† ì½œì€ ì§€ë¦¬ì  ìœ„ì¹˜ë¥¼ ê¸°ë¡í•˜ê³  ë¸”ë¡ì²´ì¸ì— íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ê¸°ë¡í•˜ëŠ” ë¹„ì½˜ì˜ BFTì— ì˜ì¡´í•˜ì—¬ ì‹œìŠ¤í…œ ì‹¤íŒ¨ ë° ì‚¬ê¸°ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.\nProof-of-Importance (PoI)    Concept: Proof-of-Importance (PoI)     Principle: Like PoS but with additional properties that influence your ranking.   Speed: High   DLT setup: Public permissionless blockchain   Finality: Probabilistic   Example of use: NEM    The Proof-of-Importance (PoI) consensus algorithm acts almost like PoS but includes three components:\n â€¢ The number of tokens in the account â€¢ Account transaction activity â€¢ Time the has account spent in the network  While the first parameter plays a major role in the ranking for verifying transactions, the second and third parameters are rather weak but still help with establishing the â€œimportanceâ€ of an account. The smaller the sum of tokens, the stronger influence of other parameters.\nThus, an account that â€œvestedâ€ hundreds of thousands of tokens can increase its significance factor up to 3 times due to its activity and consistent presence in the network. On the other hand, it doesnâ€™t make any difference for those who possess hundreds of millions of tokens in their account.\nPoI(Proof-of-Importance) í•©ì˜ ì•Œê³ ë¦¬ì¦˜ì€ PoSì™€ ê±°ì˜ ë¹„ìŠ·í•˜ê²Œ ì‘ë™í•˜ì§€ë§Œ ì„¸ ê°€ì§€ êµ¬ì„±ìš”ì†Œë¥¼ í¬í•¨í•©ë‹ˆë‹¤.\n â€¢ ê³„ì •ì˜ í† í° ìˆ˜ â€¢ ê³„ì • ê±°ë˜ í™œë™ â€¢ ë„¤íŠ¸ì›Œí¬ì—ì„œ ì‚¬ìš©í•œ ê³„ì • ì‹œê°„  ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ê°€ ê±°ë˜ ê²€ì¦ ìˆœìœ„ì—ì„œ ì¤‘ìš”í•œ ì—­í• ì„ í•˜ëŠ” ë°˜ë©´, ë‘ ë²ˆì§¸ì™€ ì„¸ ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ëŠ” ë‹¤ì†Œ ì•½í•˜ì§€ë§Œ ì—¬ì „íˆ ê³„ì •ì˜ \u0026ldquo;ì¤‘ìš”ì„±\u0026quot;ì„ ì„¤ì •í•˜ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤. í† í° í•©ê³„ê°€ ì‘ì„ìˆ˜ë¡ ë‹¤ë¥¸ ë§¤ê°œë³€ìˆ˜ì˜ ì˜í–¥ì´ ë” ê°•í•´ì§‘ë‹ˆë‹¤.\në”°ë¼ì„œ ìˆ˜ì‹­ë§Œ ê°œì˜ í† í°ì„ \u0026ldquo;ë² íŒ…\u0026quot;í•œ ê³„ì •ì€ í™œë™ê³¼ ë„¤íŠ¸ì›Œí¬ì—ì„œì˜ ì¼ê´€ëœ ì¡´ì¬ë¡œ ì¸í•´ ì¤‘ìš”ë„ë¥¼ ìµœëŒ€ 3ë°°ê¹Œì§€ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë°˜ë©´ì— ê³„ì •ì— ìˆ˜ì–µ ê°œì˜ í† í°ì„ ë³´ìœ í•˜ê³  ìˆëŠ” ì‚¬ëŒë“¤ì—ê²ŒëŠ” ì•„ë¬´ëŸ° ì°¨ì´ê°€ ì—†ìŠµë‹ˆë‹¤.\nProof-of-Elapsed-Time (PoET)    Concept: Proof-of-Elapsed-Time (PoET)     Principle: Blocks are created in a trusted environment with equal periods   Speed: Medium   DLT setup: Private permissioned or permissionless blockchain   Finality: Probabilistic   Example of use: Intel    Chipmaker Intel didnâ€™t lag behind and developed their own blockchain entitled IntelLedger. A consensus algorithm of IntelLedger is called Proof of Elapsed Time (PoET). Today, it is a HyperLedger consensus module.\nThis system is similar to Proof-of-Work, but consumes far less electricity. Instead of having participants solve a cryptographic puzzle, the algorithm operates in a Trusted Execution Environment (TEE), such as Intelâ€™s Software Guard Extensions (SGX). The PoET protocol also assures blocks get created through a lottery but without any required work.\nIntelâ€™s solution offers a guaranteed wait time due to the TEE. According to the company, the proof-of-elapsed-time algorithm can scale to thousands of nodes and will properly run on any Intel processor that supports SGX. Isnâ€™t blockchain supposed to be helping us to get away from third parties rather than relying on them though?\nì¹© ì œì¡°ì—…ì²´ Intelì€ ë’¤ì²˜ì§€ì§€ ì•Šê³  IntelLedgerë¼ëŠ” ìì²´ ë¸”ë¡ì²´ì¸ì„ ê°œë°œí–ˆìŠµë‹ˆë‹¤. IntelLedgerì˜ í•©ì˜ ì•Œê³ ë¦¬ì¦˜ì„ PoET(Proof of Elapsed Time)ë¼ê³  í•©ë‹ˆë‹¤. ì˜¤ëŠ˜ì€ HyperLedger í•©ì˜ ëª¨ë“ˆì…ë‹ˆë‹¤.\nì´ ì‹œìŠ¤í…œì€ ì‘ì—… ì¦ëª…ê³¼ ìœ ì‚¬í•˜ì§€ë§Œ í›¨ì”¬ ì ì€ ì „ë ¥ì„ ì†Œë¹„í•©ë‹ˆë‹¤. ì°¸ê°€ìê°€ ì•”í˜¸í™” í¼ì¦ì„ í’€ë„ë¡ í•˜ëŠ” ëŒ€ì‹  ì•Œê³ ë¦¬ì¦˜ì€ Intelì˜ SGX(Software Guard Extensions)ì™€ ê°™ì€ TEE(ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì‹¤í–‰ í™˜ê²½)ì—ì„œ ì‘ë™í•©ë‹ˆë‹¤. PoET í”„ë¡œí† ì½œì€ ë˜í•œ ë³µê¶Œì„ í†µí•´ ë¸”ë¡ì´ ìƒì„±ë˜ì§€ë§Œ í•„ìš”í•œ ì‘ì—… ì—†ì´ë„ ë³´ì¥í•©ë‹ˆë‹¤.\nì¸í…”ì˜ ì†”ë£¨ì…˜ì€ TEEë¡œ ì¸í•´ ë³´ì¥ëœ ëŒ€ê¸° ì‹œê°„ì„ ì œê³µí•©ë‹ˆë‹¤. íšŒì‚¬ì— ë”°ë¥´ë©´ ê²½ê³¼ ì‹œê°„ ì¦ëª… ì•Œê³ ë¦¬ì¦˜ì€ ìˆ˜ì²œ ê°œì˜ ë…¸ë“œë¡œ í™•ì¥í•  ìˆ˜ ìˆìœ¼ë©° SGXë¥¼ ì§€ì›í•˜ëŠ” ëª¨ë“  ì¸í…” í”„ë¡œì„¸ì„œì—ì„œ ì œëŒ€ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤. ë¸”ë¡ì²´ì¸ì€ ìš°ë¦¬ê°€ ì œ3ìì—ê²Œ ì˜ì¡´í•˜ê¸°ë³´ë‹¤ ì œ3ìë¡œë¶€í„° ë²—ì–´ë‚  ìˆ˜ ìˆë„ë¡ ë„ì™€ì•¼ í•˜ì§€ ì•Šì„ê¹Œìš”?\nBeyond the Mainstream Protocols There are more exotic protocols like Proof-of-Stake-Time (PoST) and Proof-of-Brain (PoB) that we just couldnâ€™t fit in this article. Find them in Part II. Moreover, our Blockchain glossary will help you keep on top of the ever growing collection of Blockchain related terminology.\nPoST(Proof-of-Stake-Time) ë° PoB(Proof-of-Brain)ì™€ ê°™ì€ ë” íŠ¹ì´í•œ í”„ë¡œí† ì½œì´ ìˆì§€ë§Œ ì´ ê¸°ì‚¬ì—ì„œëŠ” ë‹¤ë£¨ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. íŒŒíŠ¸ IIì—ì„œ ì°¾ìœ¼ì‹­ì‹œì˜¤. ë˜í•œ, ë¸”ë¡ì²´ì¸ ìš©ì–´ì§‘ì„ í†µí•´ ê³„ì† ì¦ê°€í•˜ëŠ” ë¸”ë¡ì²´ì¸ ê´€ë ¨ ìš©ì–´ ëª¨ìŒì„ íŒŒì•…í•˜ëŠ” ë° ë„ì›€ì´ ë  ê²ƒì…ë‹ˆë‹¤.\nâ—¼[end]\n","date":"2021-07-15T13:30:26+09:00","permalink":"https://wadro.github.io/memo/graduate/references/consensus-protocols-that-meet-different-business-demands.-part-i/","tags":[""],"title":"Consensus Protocols That Meet Different Business Demands  Part I"},{"categories":["Computer Engineering"],"contents":"Go tutorials  ğŸ“”ğŸ“ë³¸ ë‚´ìš©ì€ tour.golang.org ì— ìˆëŠ” ë‚´ìš©ì„ ì •ë¦¬í•œ ê¸€ì…ë‹ˆë‹¤.  Hello, Go world! (ì „ íŠœí† ë¦¬ì–¼ì„ í•˜ë‚˜ë¡œ ëª¨ìŒ) package main // íŒŒì¼ë“¤(í•¨ìˆ˜ë“¤)ì„ ëª¨ì•„ë†“ì€ í•˜ë‚˜ì˜ ì„¸íŠ¸ import ( // ì´ëŸ°ì‹ìœ¼ë¡œ í•œë²ˆì— ì„í¬íŠ¸ í•˜ëŠ”ê²ƒì´ ê¶Œì¥ë¨(factored style) \u0026quot;fmt\u0026quot; // í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ \u0026quot;time\u0026quot; // ì‹œê°„ ê´€ë ¨ ë¼ì´ë¸ŒëŸ¬ë¦¬ \u0026quot;math/rand\u0026quot; // package rand ë¡œ ì‹œì‘í•˜ëŠ” íŒŒì¼ë“¤ë¡œ êµ¬ì„±ë¨. \u0026quot;math/cmplx\u0026quot; // ë³µì†Œìˆ˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ \u0026quot;strings\u0026quot; // ë¬¸ìì—´ ê´€ë ¨ í•¨ìˆ˜ ëª¨ìŒ ) /* í•¨ìˆ˜ ì„ ì–¸ ë°©ë²•: func í•¨ìˆ˜ëª…(ë³€ìˆ˜_ì´ë¦„ íƒ€ì…, ...) ì¶œë ¥_íƒ€ì… { ... return ì¶œë ¥ê°’ } */ func add(x int, y int) int { return x + y } /* ìœ„ì™€ ê°™ì€ í•¨ìˆ˜: func add(x, y int) int { // ê°™ì€ íƒ€ì…ì´ë©´ ë¬¶ì–´ì„œ ì„ ì–¸ ê°€ëŠ¥ return x + y } */ func swap(x, y string) (string, string) { return y, x // ë³µìˆ˜ ê°œì˜ ê²°ê³¼ ì¶œë ¥ ê°€ëŠ¥ } func split(sum int) (x, y int) { // ê²°ê³¼ê°’ì— ì´ë¦„ ë¶™ì¼ìˆ˜ ìˆìŒ x = sum * 4 / 9 y = sum - x return // ì•„ë¬´ê²ƒë„ ì—†ìœ¼ë©´ ê²°ê³¼ê°’ìœ¼ë¡œ ì„ ì–¸í•œ ë³€ìˆ˜ë“¤ì´ ì¶œë ¥ë¨ } func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { // if ë³€ìˆ˜ ì„ ì–¸(ìŠ¤ì½”í”„ëŠ” if ë˜ëŠ” else {}ë¸”ë¡ì•ˆì—ì„œë§Œ ìœ íš¨í•¨) return v } return lim } var c, python, java bool // ì „ì—­ë³€ìˆ˜ var i, j int = 1, 2 // ì´ˆê¸°ê°’ ì„ ì–¸ var ( // factored ì„ ì–¸ ê°€ëŠ¥ ToBe bool = false MaxInt uint64 = 1\u0026lt;\u0026lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) const Pi = 3.14 // ìƒìˆ˜ëŠ” := í‘œê¸°ë²•ìœ¼ë¡œ ì„ ì–¸ ëª»í•¨ func main() { fmt.Println(\u0026quot;Hello, ä¸–ç•Œ\u0026quot;) // \\n í¬í•¨ëœ í•¨ìˆ˜ fmt.Println(\u0026quot;The time is\u0026quot;, time.Now()) // í˜„ì¬ ì‹œê° ì¶œë ¥ fmt.Println(math.pi) // ëŒ€ë¬¸ìë¡œ ì‹œì‘í•˜ë©´ export ë˜ê³ (ë‹¤ë¥¸ íŒŒì¼ì—ì„œ ì‚¬ìš©ê°€ëŠ¥), ì†Œë¬¸ìë¡œ ì‹œì‘í•˜ë©´ export ì•ˆë¨ fmt.Println(add(42, 13)) a, b := swap(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) var i int // ì§€ì—­ë³€ìˆ˜, i ì´ˆê¸°í™”(0) var c, python, java = true, false, \u0026quot;no!\u0026quot; // ì„ ì–¸ëœ ê°’ìœ¼ë¡œ ì´ˆê¸°í™” k := 3 // í•¨ìˆ˜ ì•ˆì—ì„œëŠ” ì§§ì€ í‘œí˜„ì‹ ê°€ëŠ¥, í•¨ìˆ˜ ë°–ì—ì„œëŠ” ì—ëŸ¬. var ë¡œ ì‹œì‘í•´ì•¼í•¨ fmt.Println(i,j,k, c, python, java) fmt.Printf(\u0026quot;Type: %T Value: %v\\n\u0026quot;, ToBe, ToBe) fmt.Printf(\u0026quot;Type: %T Value: %v\\n\u0026quot;, MaxInt, MaxInt) fmt.Printf(\u0026quot;Type: %T Value: %v\\n\u0026quot;, z, z) sum := 0 for i := 0; i \u0026lt; 10; i++ { sum += i } fmt.Println(sum) sum = 1 for ; sum \u0026lt; 1000; { sum += sum } fmt.Println(sum) sum = 1 for sum \u0026lt; 1000 { // for == while sum += sum if sum \u0026gt; 100 { break } } fmt.Println(sum) /* for { } // ë¬´í•œ ë£¨í”„ */ // Go ì˜ switchë¬¸ì€ break ì•ˆí•´ë„ ëœë‹¤! switch os := runtime.GOOS; os { case \u0026quot;darwin\u0026quot;: fmt.Println(\u0026quot;OS X.\u0026quot;) case \u0026quot;linux\u0026quot;: fmt.Println(\u0026quot;Linux.\u0026quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(\u0026quot;%s.\\n\u0026quot;, os) } switch { // ì¡°ê±´ ì—†ìœ¼ë©´ switch true ì™€ ê°™ìŒ case t.Hour() \u0026lt; 12: fmt.Println(\u0026quot;Good morning!\u0026quot;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026quot;Good afternoon.\u0026quot;) default: fmt.Println(\u0026quot;Good evening.\u0026quot;) } /* 1. defer ë¬¸ì€ ìì‹ ì´ í¬í•¨ëœ í•¨ìˆ˜ ë¸”ë¡ì´ ì „ë¶€ ì‹¤í–‰ë˜ë©´ ì œì¼ ë§ˆì§€ë§‰ì— ì‹¤í–‰ë¨ 2. stack êµ¬ì¡°(defer ë¥¼ ë‘ê°œ í•˜ë©´ ë‚˜ì¤‘ì— ë“¤ì–´ê°„ ìª½ì´ ë¨¼ì € ì‹¤í–‰ë¨) */ defer fmt.Println(\u0026quot;world\u0026quot;) for i := 0; i \u0026lt; 10; i++ { defer fmt.Println(i) } /* Goì˜ í¬ì¸í„°ëŠ” í¬ì¸í„° ì—°ì‚°ì—†ì´ ê·¸ëƒ¥ ì£¼ì†Œ âŠƒ ê°’ ì˜ ê´€ê³„, address âŠƒ value ì˜ ê´€ê³„ì—ì„œ address == \u0026amp;value ì°¸ì¡°(ì£¼ì†Œ\u0026lt;-ê°’) *address == value ì—­ì°¸ì¡°(ì£¼ì†Œ-\u0026gt;ê°’) */ i, j := 42, 2701 p := \u0026amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = \u0026amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.Println(j) // see the new value of j type Vertex struct { // êµ¬ì¡°ì²´ëŠ” ì—¬ëŸ¬ íƒ€ì…ì„ í•˜ë‚˜ë¡œ ëª¨ì€ ì§‘í•© X int Y int } fmt.Println(Vertex{1, 2}) v := Vertex{1, 2} v.X = 4 // .(dot) ì˜¤í¼ë ˆì´í„°ë¡œ ì ‘ê·¼ ê°€ëŠ¥ fmt.Println(v.X) v := Vertex{1, 2} p := \u0026amp;v // ì›ë˜ëŠ” ì£¼ì†Œê°’ì´ë‹ˆê¹Œ (*p).X ì´ë ‡ê²Œ ì¨ì•¼í•˜ëŠ”ë° p.X = 1e9 // ìƒëµ ê°€ëŠ¥í•¨ /* c ì—ì„œëŠ” -\u0026gt; (arrow) ì˜¤í¼ë ˆì´í„°ë¥¼ ì¼ëŠ”ë° Go ì—ì„œëŠ” ë‹¨ìˆœí•¨ì„ ìœ„í•´ì„œ ê·¸ëƒ¥ ìƒëµí•œë“¯? ë‚˜ì¤‘ì— í•¨ìˆ˜í˜•ì„ ì§€ì›í•˜ê¸° ìœ„í•´ì„œì¼ê¹Œ? ì•„ì§ê¹Œì§€ë„ ì•ˆë„£ì€ê±° ë³´ë©´ ê·¸ëƒ¥ ì•„ì˜ˆ ìƒê°ì´ ì—†ëŠ”ë“¯ 2021-07-18T16:24:50+09:00 */ fmt.Println(v) v1 = Vertex{1, 2} // has type Vertex v2 = Vertex{Y: 1} // X:0 is implicit? v3 = Vertex{} // X:0 and Y:0 p = \u0026amp;Vertex{1, 2} // has type *Vertex // ì‰½ê²Œ(?!) ê¸°ì–µí•˜ëŠ” ë²• // type =\u0026gt; some value of some type ==\u0026gt; x: type // array =\u0026gt; n number of type ==\u0026gt; [n]type var a [10]int // declares a variable a as an array of **ten integers** // ì£¼ì˜: array ëŠ” íƒ€ì…ì˜ ì¼ì¢…ì´ë¯€ë¡œ resize ë¶ˆê°€ // arrayì˜ ì¹´í”¼ë³¸ì¸ slice ë¼ëŠ” ê°œë…ì´ ìˆìŒ // ì£¼ì˜2: slice ëŠ” ë ˆí¼ëŸ°ìŠ¤ë¥¼ ê³µìœ í•¨ // ì¦‰, slice ìˆ˜ì •í•˜ë©´ array ë„ ìˆ˜ì •ë¨ // ê·¸ë¦¬ê³  ê°™ì€ arrayë¥¼ ë ˆí¼ëŸ°ìŠ¤ë¥¼ ê°€ì§€ëŠ” slice ë˜í•œ ë ˆí¼ëŸ°ìŠ¤ë¥¼ ê³µìœ í•¨ primes := [6]int{2, 3, 5, 7, 11, 13} var s []int = primes[1:4] fmt.Println(s) // sliceë§Œ ë§Œë“¤ë©´ arrayëŠ” ìë™ ìƒì„±ë¨(ì¼ì¢…ì˜ ë ˆí¼ëŸ°ìŠ¤) q := []int{2, 3, 5, 7, 11, 13} fmt.Println(q) q1 := q[0:4] q1[2] = 1000 r := []bool{true, false, true, true, false, true} fmt.Println(r) fmt.Println(q) s := []struct { i int b bool }{ {2, true}, {3, false}, {5, true}, {7, true}, {11, false}, {13, true}, } fmt.Println(s) s := []int{2, 3, 5, 7, 11, 13} s = s[1:4] fmt.Println(s) s = s[:2] fmt.Println(s) // ìƒí•œ í•˜í•œ ì—†ìœ¼ë©´ ê·¸ëƒ¥ ëê¹Œì§€ s = s[1:] fmt.Println(s) s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length. s = s[:1] printSlice(s) // Extend its length. s = s[1:4] printSlice(s) s = s[:5] printSlice(s) // Drop its first two values. s = s[2:] printSlice(s) s = s[2:] printSlice(s) s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length. s = s[2:] printSlice(s) // Extend its length. s = s[1:2] printSlice(s) s = s[:3] printSlice(s) // Drop its first two values. s = s[2:] printSlice(s) s = s[1:] printSlice(s) s = s[:1] printSlice(s) var s []int var p *int fmt.Println( s, len(s), cap(s),p) if s == nil { fmt.Println(\u0026quot;nil slice\u0026quot;) } if p == nil { fmt.Println(\u0026quot;nil pointer\u0026quot;) } fmt.Printf(\u0026quot;%T, %T\u0026quot; ,s,p) a := make([]int, 5) printSliceAndString(\u0026quot;a\u0026quot;, a) b := make([]int, 0, 5) printSliceAndString(\u0026quot;b\u0026quot;, b) c := b[:2] printSliceAndString(\u0026quot;c\u0026quot;, c) d := c[2:5] printSliceAndString(\u0026quot;d\u0026quot;, d) board := [][]string{ []string{\u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;}, []string{\u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;}, []string{\u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;}, } // The players take turns. board[0][0] = \u0026quot;X\u0026quot; board[2][2] = \u0026quot;O\u0026quot; board[1][2] = \u0026quot;X\u0026quot; board[1][0] = \u0026quot;O\u0026quot; board[0][2] = \u0026quot;X\u0026quot; fmt.Println(len(board)) fmt.Println((board[0])) // strings.Join -\u0026gt; string // func append(s []T, vs ...T) []T for i := 0; i \u0026lt; len(board); i++ { fmt.Printf(\u0026quot;%s\\n\u0026quot;, strings.Join(board[i], \u0026quot; \u0026quot;)) } var s []int printSlice(s) if s == nil { fmt.Println(\u0026quot;nil slice!\u0026quot;) } // append works on nil slices. s = append(s, 0) printSlice(s) if s == nil { fmt.Println(\u0026quot;nil slice!\u0026quot;) } // The slice grows as needed. s = append(s, 1) printSlice(s) // We can add more than one element at a time. s = append(s, 2, 3, 4) printSlice(s) // range =\u0026gt; iterator // for ë¬¸ í•˜ê³  ê°™ì´ ì“°ì´ë‹ˆê¹Œ ê·¸ëƒ¥ í•˜ë‚˜ì˜ ë¬¸ë²•ì´ë¼ê³  ë³´ëŠ”ê²Œ ë§ì„ë“¯ var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} for i, v := range pow { fmt.Printf(\u0026quot;2**%d = %d\\n\u0026quot;, i, v) } for i:=0; i\u0026lt;len(pow); i++ { fmt.Printf(\u0026quot;2**%d = %d\\n\u0026quot;, i, pow[i]) } fmt.Printf(\u0026quot;this is range\\n\u0026quot;) for i, d := range pow { res := math.Pow(2, float64(i)) fmt.Printf(\u0026quot;2**%d = %d == %f\\n\u0026quot;, i,d,res) } fmt.Println() fmt.Printf(\u0026quot;this is just for loop\\n\u0026quot;) for i:=0; i\u0026lt;len(pow); i++ { res := math.Pow(2, float64(i)) fmt.Printf(\u0026quot;2**%d = %d == %f\\n\u0026quot;, i, pow[i], res) } // ì´ê±° ì¢‹ì€ êµ¬ë¬¸ì¸ë“¯, 2 ê±°ë“­ì œê³±ì„ ì´ëŸ°ì‹ìœ¼ë¡œ êµ¬í•œë‹¤ëŠ”ê²Œ ë¹„íŠ¸ì—°ì‚°ì´ë¼ì„œ ì¢‹ì„ë“¯ // í™•ì‹¤íˆ ì´ëŸ° ë¶€ë¶„ì„ ì¢€ ë°°ìš°ë©´ ì¢‹ì„í…ë°... pow := make([]int, 10) for i := range pow { pow[i] = 1 \u0026lt;\u0026lt; uint(i) // == 2**i } for _, value := range pow { fmt.Printf(\u0026quot;%d\\n\u0026quot;, value) } type Gps struct { Lat, Long float64 } var m map[string]Gps m = make(map[string]Gps) m[\u0026quot;Bell Labs\u0026quot;] = Gps{ 40.68433, -74.39967, } fmt.Println(m[\u0026quot;Bell Labs\u0026quot;]) var m = map[string]Gps{ \u0026quot;Bell Labs\u0026quot;: Vertex{ 40.68433, -74.39967, }, \u0026quot;Google\u0026quot;: { 37.42202, -122.08408},} msi := make(map[string]int) msi[\u0026quot;Answer\u0026quot;] = 42 fmt.Println(\u0026quot;The value:\u0026quot;, msi[\u0026quot;Answer\u0026quot;]) msi[\u0026quot;Answer\u0026quot;] = 48 fmt.Println(\u0026quot;The value:\u0026quot;, msi[\u0026quot;Answer\u0026quot;]) delete(msi, \u0026quot;Answer\u0026quot;) fmt.Println(\u0026quot;The value:\u0026quot;, msi[\u0026quot;Answer\u0026quot;]) val, ok := msi[\u0026quot;Answer\u0026quot;] fmt.Println(\u0026quot;The value:\u0026quot;, val, \u0026quot;Present?\u0026quot;, ok) hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Printf(\u0026quot;type is %T\\n\u0026quot;,hypot) fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow)) pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println( pos(i), neg(-2*i), ) } /* ë˜ ì‹«ì–´í•˜ëŠ” ì  ë°œê²¬... ì„¸ë¯¸ì½œë¡ ì€ ê°•ì œí•˜ì§€ ì•Šìœ¼ë©´ì„œ struct ì˜ ì½¤ë§ˆëŠ” ê°•ì œ ë¨... ì½¤ë§ˆ ì•ˆí•˜ë©´ ì—ëŸ¬ë‚¨... ì½¤ë§ˆ ëŒ€ì‹  {} ì¤‘ê´„í˜¸ ë¸”ë¡ì„ ë‹«ìœ¼ë©´ ì—ëŸ¬ ì•ˆë‚¨. ì§„ì§œ ì´ìƒí•œë°ë„ ê°„ë‹¨í•´ì„œ ì‚¬ëŒë“¤ì´ ì“°ëŠ”ê±´ê°€? javascript ë‚˜ lisp ì²˜ëŸ¼? ì°¨ë¼ë¦¬ rust ë¥¼ ì“°ê² ë‹¤. ì›¹ì€ ëŒ€ì²´ì œê°€ ë”°ë¡œ ì—†ê³  ê·¸ëƒ¥ íŠ¸ëœìŠ¤íŒŒì¼ëŸ¬? íŠ¸ëœìŠ¤ ì»´íŒŒì¼ëŸ¬ë§Œ ìˆì„ë¿ì´ê³ ... lisp ëŠ” ë¬¸ë²•ì´ ì›Œë‚™ ë‹¨ìˆœí•˜ì§€ë§Œ í•´ì„í•˜ê¸°ê°€ ì¢€ í˜ë“  ë©´ì´ ìˆì–´ì„œ... ì§„ì§œ ê·¹ë„ì˜ ë‹¨ìˆœí•¨ì„ ì¶”êµ¬í•˜ëŠ” ë³€íƒœì ì¸ ì–¸ì–´ë¼ê³  í•´ì•¼í•˜ë‚˜... haskell ë„ ë”°ì§€ê³  ë³´ë©´ ì—„ë°€í•œ ìˆœìˆ˜í•¨ì„ ë”°ì§€ëŠ” ë³€íƒœê³ ... ì–¸ì–´ë¼ëŠ”ê²Œ ë‹¤ ê·¸ë ‡ì§€ë­... rustë„ ì•ˆí•´ë´ì„œ ê·¸ë ‡ì§€ ë§‰ìƒ ë°°ìš°ë©´ ë˜ ë­”ê°€ ìˆì„ì§€ëŠ” ëª¨ë¥´ê² ë‹¤. ê·¼ë° ownership ì— ë„ˆë¬´ ë°˜í•´ì„œ ë˜ ë¹¨ë¦¬ ë°°ìš°ê³  ì‹¶ì€ ë§ˆìŒë„ ê³µì¡´í•¨. */ /* A slice is formed by specifying two indices, a low and high bound, separated by a colon: a[low : high] #slice-2 ì•„ë¬´íŠ¼ ê·¸ë˜ë„ ì •ë¦¬ë¥¼ í•˜ìë©´, capacity ë¼ëŠ” ê°œë…ì€ low bound ì—ë§Œ ì˜í–¥ì„ ë°›ëŠ”ë‹¤ high bound ì—ëŠ” ì•„ë¬´ëŸ° ì˜í–¥ì´ ì—†ë‹¤ length ë¼ëŠ” ê°œë…ì€ low bound, high bound ëª¨ë‘ì˜ ì˜í–¥ì„ ë°›ëŠ”ë‹¤ The zero value of a slice is nil. A nil slice has a length and capacity of 0 and has no underlying array. */ /* #slice-1 ì—¬ê¸°ì„œ ë‚´ê°€ goë¥¼ ì‹«ì–´í•˜ëŠ” ì´ìœ  ê³„ì‚° ë°©ì‹ì´ í†µì¼ë˜ì§€ì•Šê³  ì¢Œìš°ê°€ ë‹¤ë¥´ë‹¤ ì–´ë–¤ ëŠë‚Œì´ëƒë©´, ë‚˜ì¤‘ì— gob ì´ë¼ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì¸ì½”ë”© í• ë•ŒëŠ” ë¹„ì–´ìˆëŠ” ë²„í¼ë¥¼ ì¸ì½”ë” ì˜ì—­ìœ¼ë¡œ ì§€ì •í•˜ê³  b ë¼ëŠ” ë³€ìˆ˜ë¥¼ ì¸ì½”ë”©í•´ì„œ ì €ì¥í•œë‹¤ (ì—¬ê¸°ì„œ b ëŠ” Blockì´ë¼ëŠ” íƒ€ì…ì˜ í¬ì¸í„° =\u0026gt; ì¦‰, ì£¼ì†Œ) var res bytes.Buffer encoder := gob.NewEncoder(\u0026amp;res) err := encoder.Encode(b) ê·¸ë¦¬ê³  ë””ì½”ë”© í• ë•ŒëŠ” dataì˜ ìŠ¤íŠ¸ë¦¼ì„ ë°›ì•„ì„œ ë””ì½”ë” ê°ì²´ë¡œ ë§Œë“¬ ê·¸ë¦¬ê³ ë‚˜ì„œ ë§Œë“¤ì–´ì§„ ê°ì²´ë¥¼ ë””ì½”ë”©í•˜ëŠ”ë°, ì´ë•Œ ë¹„ì–´ìˆëŠ” block ì´ë¼ëŠ” ë³€ìˆ˜ì˜ ì£¼ì†Œì— ì§‘ì–´ë„£ìŒ (ì—¬ê¸°ì„œ block ì€ Blockì´ë¼ëŠ” íƒ€ì…ì˜ ê°’ =\u0026gt; ì£¼ì†Œ ì•„ë‹˜) var block Block decoder := gob.NewDecoder(bytes.NewReader(data)) err := decoder.Decode(\u0026amp;block) ì°¸ê³ : binary ë¼ì´ë¸ŒëŸ¬ë¦¬ ì“¸ë–„, .BigEndian ì€ ì¸ì ìˆœì„œëŒ€ë¡œ ë“¤ì–´ê°€ê³ , .LittleEndian ì€ ì¸ìì˜ ì—­ìˆœìœ¼ë¡œ ë“¤ì–´ê° ê·¸ë˜ì„œ ë­ê·€ì§€ê°€ í”„ë¡œê·¸ë˜ë¨¸ì— ë§ì¶”ëŠ”ê²Œ ì•„ë‹ˆë¼, í”„ë¡œê·¸ë˜ë¨¸ê°€ ë­ê·€ì§€ì— ë§ì¶°ì•¼í•˜ëŠ” ì–´ì´ì—†ëŠ” ìƒí™©ì´ ìƒê¸´ë‹¤ í•¨ìˆ˜í˜• ì–¸ì–´ì²˜ëŸ¼ ì—¬ëŸ¬ ì œì•½ì— ì ì‘í•´ì„œ ì–»ëŠ”ê²Œ ë§ìœ¼ë©´ ëª°ë¼ë„, ì´ê±´ ê·¸ëƒ¥ ì–¸ì–´ ìì²´ê°€ ì£¼ëŠ” í˜¼ë€ë•Œë¬¸ì— ì–»ëŠ”ê²ƒë„ ì—†ì´ í—·ê°ˆë¦¬ê²Œ ëœë‹¤ ì°¨ë¼ë¦¬ ì•„ì˜ˆ ììœ ë„ë¥¼ ë†’ì´ë ¤ë©´ clojure ì²˜ëŸ¼ ì•„ì˜ˆ ê·œì¹™ì´ ëª‡ê°œ ì—†ë˜ì§€, (ì‹¬í”Œí•´ì„œ ì½”ë“œëŠ” ë¹¨ë¦¬ ì½ëŠ”ë°, ì½”ë“œë¥¼ ì´í•´í•˜ê¸°ê°€ ì–´ë µë‹¤ ì»´í“¨í„°ëŠ” ì´í•´í•˜ê¸° ì‰¬ìš¸ë“¯) haskellì´ë‚˜ rust ì²˜ëŸ¼ ì•„ì˜ˆ ììœ ë„ë¥¼ ì œí•œí•´ì„œ í‘œí˜„ë ¥ì„ ìƒëŠ” ëŒ€ì‹ , ê¹”ë”í•¨ê³¼ ì•ˆì •ì„±ì„ í™•ë³´í•˜ëŠ”ê²Œ ë‚«ë‹¤ê³  ìƒê°í•œë‹¤ (ì½”ë“œë¥¼ ì½ê¸°ëŠ” ì–´ë ¤ìš´ ëŒ€ì‹ , ì´í•´í•˜ëŠ”ê±´ ìƒëŒ€ì ìœ¼ë¡œ ì‰½ë‹¤ ì¸ê°„ì´ ì´í•´í•˜ê¸° ì‰¬ìš´ ìˆ˜í•™ê³¼ ìœ ì‚¬í•œ ë¬¸ë²•) */ } func compute(fn func(float64, float64) float64) float64 { return fn(3, 4) } func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func printSlice(s []int) { fmt.Printf(\u0026quot;len=%d cap=%d %v\\n\u0026quot;, len(s), cap(s), s) } func printSliceAndString(s string, x []int) { fmt.Printf(\u0026quot;%s len=%d cap=%d %v\\n\u0026quot;, s, len(x), cap(x), x) }   Note:\n  ì„¸ë¯¸ì½œë¡  ì—†ìŒ ê¸°ë³¸ íƒ€ì…: bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // uint8ì˜ ë³„ì¹­ rune // int32ì˜ ë³„ì¹­ // ìœ ë‹ˆì½”ë“œì—ì„œ code pointë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. float32 float64 complex64 complex128   ì´ˆê¸°ê°’: zero value ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤. ìˆ«ì typeì—ëŠ” 0 boolean typeì—ëŠ” false stringì—ëŠ” \u0026quot;\u0026quot; (ë¹ˆ ë¬¸ìì—´) ì¶”ê°€: slice ê¸°ë³¸ê°’ì€ nil slice ~~(ë„¥ ìŠ¬ë¼ì´ìŠ¤!)~~ í¬ì¸í„° ê¸°ë³¸ê°’ë„ nil í¬ì¸í„° \u0026lt;nil\u0026gt;   íƒ€ì… ë³€í™˜ var i int = 42 var f float64 = float64(i) var u uint = uint(f) // í˜¹ì€ ì¢€ ë” ê°„ë‹¨íˆ: i := 42 f := float64(i) u := uint(f)   ë°˜ë³µë¬¸ì€ for ë°–ì— ì—†ìŒ.  () ê´„í˜¸ ì—†ê³ , {} í•„ìˆ˜!    ì§ˆë¬¸ ë¦¬ìŠ¤íŠ¸  ì´í•´ê°€ 100í¼ì„¼íŠ¸ ì•ˆë¨. Numeric Constants Numeric constants are high-precision values. An untyped constant takes the type needed by its context. Try printing needInt(Big) too. (An int can store at maximum a 64-bit integer, and sometimes less.) ìˆ«ìí˜• ìƒìˆ˜ ìˆ«ìí˜• ìƒìˆ˜ëŠ” ë§¤ìš° ì •í™•í•œ ê°’ ì…ë‹ˆë‹¤. typeì´ ì •í•´ì§€ì§€ ì•Šì€ ìƒìˆ˜ëŠ” ê·¸ê²ƒì˜ ë¬¸ë§¥ì—ì„œ í•„ìš”í•œ typeì„ ì·¨í•©ë‹ˆë‹¤. needInt(Big) ì„ ì¶œë ¥í•´ë³´ì„¸ìš”. (int ëŠ” ìµœëŒ€ 64-bit í˜¹ì€ ë•Œë•Œë¡œ ë” ì‘ì€ ì •ìˆ˜ë¥¼ ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.)   í´ë¡œì € ì¢€ë” í•´ì•¼ë¨  í€´ì¦ˆ  array ì™€ slice ì°¨ì´ëŠ”? range ë¬¸ë²•ì„ map ì— ì ìš©í•˜ë©´? ì•„ë˜ ìƒí™©ì—ì„œëŠ” ì–´ë–»ê²Œ ë ê¹Œ?  var sum = 0 func adder() func(int) int { var sum = 0 return func(x int) int { sum += x return sum } } func main() { pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println( pos(i), neg(-2*i), ) } }  ","date":"2021-07-15T13:19:21+09:00","permalink":"https://wadro.github.io/memo/cs/go/lab-golang-study-tutorials/","tags":["golang","go"],"title":"lab golang study tutorials"},{"categories":["likelion"],"contents":"ì•„ì´ë””ì–´í†¤ PPT ideathon ideathon(remote control version)\n","date":"2021-05-16T17:11:49+09:00","permalink":"https://wadro.github.io/slide/likelion/likelion-week1/","tags":["ideathon"],"title":"likelion week1"},{"categories":["hugo"],"contents":"Introduction One morning, when Gregor Samsa woke from troubled dreams, he found himself transformed in his bed into a horrible vermin.\nMy Heading He lay on his armour-like back, and if he lifted his head a little he could see his brown belly, slightly domed and divided by arches into stiff sections. The bedding was hardly able to cover it and seemed ready to slide off any moment.\nMy Subheading A collection of textile samples lay spread out on the table - Samsa was a travelling salesman - and above it there hung a picture that he had recently cut out of an illustrated magazine and housed in a nice, gilded frame. It showed a lady fitted out with a fur hat and fur boa who sat upright, raising a heavy fur muff that covered the whole of her lower arm towards the viewer. Gregor then turned to look out the window at the dull weather. Drops\nhead6 heading1 heading2 anc1 head3 head4 head5 head6 heading2  Level 1 folder  Level 2 file Level 2 folder  Level 3 file Level 3 folder  Level 4 file   Level 3 folder  Level 4 file Level 4 file   Level 3 file   Level 2 folder  Level 3 file Level 3 file Level 3 file   Level 2 file   Level 1 file  \r   Syntax Description     Header Title   Paragraph Text     Selling point one Selling point two Selling point three  \r  The Sun is the star at the center of the Solar System. It is a nearly perfect sphere of hot plasma, with internal convective motion that generates a magnetic field via a dynamo process. It is by far the most important source of energy for life on Earth. Credits.\n  ","date":"2021-04-28T07:00:19+09:00","permalink":"https://wadro.github.io/post/heading/","tags":["hugo shortcuts"],"title":"Heading"},{"categories":["ë¸”ë¡œê·¸"],"contents":"hugo ë¸”ë¡œê·¸ ë§Œë“¤ê¸° (windows \u0026amp; cupper theme ê¸°ì¤€)    choco install hugo -confirm (powershell ê´€ë¦¬ìë¡œ ì‹¤í–‰ í›„)\n  hugo new site (ë¸”ë¡œê·¸ íŒŒì¼ ëª¨ì•„ ë†“ì„ í´ë” ì´ë¦„) e.g. hugo new site blog\n  cd (ë¸”ë¡œê·¸ íŒŒì¼ ëª¨ì•„ ë†“ì„ í´ë” ì´ë¦„) e.g. cd blog\n  git init\nì´ ë¶€ë¶„ì€ ê°ì ì“°ê³  ì‹¶ì€ í…Œë§ˆë¥¼ ì°¾ì•„ë³¼ê²ƒ.ì—¬ê¸°ì„œ -\u0026gt; git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke\n  hugo new posts/(ì“°ê³ ì‹¶ì€ì´ë¦„).md\n  í„°ë¯¸ë„(powershell)ì— hugo ì—”í„° ëˆ„ë¥´ë©´ markdown ìœ¼ë¡œ ì‘ì„±ëœ íŒŒì¼ì´ ì•Œì•„ì„œ html,css,js íŒŒì¼ë¡œ ë³€í™˜ë¨.\n  hugo server ë¡œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥.\n  ì´í›„ ê°ì í¸í•œ ë°©ì‹ìœ¼ë¡œ ì—…ë¡œë“œ e.g. ì•„ì´ë””.github.io repository ë¡œ ì—…ë¡œë“œí•˜ë©´ í™ˆí˜ì´ì§€ ì™„ì„±!\n  config.toml ì€ ì¤‘ìš”í•˜ê¸°ë•Œë¬¸ì— ë”°ë¡œ í¬ìŠ¤íŒ… í•˜ë„ë¡ í•˜ê² ìŒ.\n  ","date":"2021-04-28T05:56:50+09:00","permalink":"https://wadro.github.io/post/hugo/hugo-tutorials/","tags":["hugo","tips"],"title":"Hugo Tutorials"},{"categories":null,"contents":"Hi! I\u0026rsquo;m studying Information Commucation, Electronics \u0026amp; Computer Science\nDetails   Information Technology\n ğŸ“Œ Blockchain ğŸ“Œ Operating System ğŸ“Œ Network ğŸ“Œ Electronics    Social Science\n ğŸ“Œ Economics ğŸ“Œ Accounting ğŸ“Œ IPRs(Intellectual Property Rights) ğŸ“Œ Philosophies(Western)    news/media/press\n newstof - http://www.newstof.com/ lemonde - https://www.ilemonde.com/ ë°ì´í„° ì €ë„ë¦¬ì¦˜    languages\n korean english japanese (basic) franch (want to learn) (constructed language)    etc (interests)\n watching masterpiece(books, movies, animation) music (piano) water sports(swimming, skin\u0026amp;scuba diving) martial arts(boxing) comics    want to learn\n harmonica, drum, ukulele tackyeon, jujitsu biology mechanics mechatronics    ","date":"2021-04-28T05:52:11+09:00","permalink":"https://wadro.github.io/about/","tags":null,"title":"About"}]