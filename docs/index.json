[{"categories":["graduate"],"contents":"읽은 논문 리스트  Caterpillar: A business process execution engine on the Ethereum Blockchain  새롭게 알게된 개념  bpmn - business process management notation bpmn 개념  그 외 진행 내용  golang - basic syntax, method, pointer, closure, etc - (스터디 내용 정리) 황용환 님과 대화 블록체인 플랫폼 조사 -\u0026gt; 솔라나, 아이오타, 홀로체인  조건1: DID method 가능한가 조건2: Smart Contract 가능한가   제6회 기업설명회(롯데정보통신,블록체인랩스,코인플러그) - 이노베이션 아카데미(42seoul)  보고 싶은 논문  Addressing Distributed Ledger Transaction Processing Limitations for the Internet-of-Things - IEEE Engineering Management Review -\u0026gt; IOTA 관련 논문 Thinking Out of the Blocks: Holochain for Distributed Security in IoT Healthcare - IEEE INTERNET OF THINGS JOURNAL -\u0026gt; Holochain 관련 논문  추후 진행 예정  golang 은 튜토리얼 까지만 진행 rust 언어 학습 (매주 1시 화면 공유로 진행)  기타 참고 자료  토큰 경제와 블록체인의 미래 - 이슈 리포트 읽기(BPM 관련 한국어 글) Caterpillar: A Blockchain-Based Business Process Management System  ","date":"2021-07-25T21:03:02+09:00","permalink":"https://wadro.github.io/slide/graduate/dcc/%EC%A7%84%ED%96%89%EC%83%81%ED%99%A9-2021-jul-25/","tags":["dcc"],"title":"진행상황 2021 Jul 25"},{"categories":["Computer Engineering"],"contents":"Go tutorials  📔📝본 내용은 tour.golang.org 에 있는 내용을 정리한 글입니다.  Hello, Go world! 3 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func say(s string) { for i := 0; i \u0026lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(\u0026quot;goroutine0\u0026quot;) say(\u0026quot;main0\u0026quot;) // 순차 실행끼리는 순서 맞춰서 실행됨 say(\u0026quot;main1\u0026quot;) // goroutine 끼리는 독립적으로 비동기식으로 처리됨 () go say(\u0026quot;goroutine2\u0026quot;) // 나중에 나오는 순차 실행과 함께 실행됨 go say(\u0026quot;goroutine1\u0026quot;) // 여기서는 say(\u0026quot;main2\u0026quot;) say(\u0026quot;main2\u0026quot;) }  output main0 goroutine0 goroutine0 main0 main0 goroutine0 goroutine0 main0 main0 goroutine0 main1 main1 main1 main1 main1 goroutine1 main2 goroutine2 main2 goroutine1 goroutine2 goroutine1 main2 goroutine2 main2 goroutine1 goroutine2 goroutine1 main2  ","date":"2021-07-25T14:03:14+09:00","permalink":"https://wadro.github.io/memo/cs/go/lab-golang-study-tutorials-03/","tags":["golang","go"],"title":"lab golang study tutorials 03"},{"categories":["Computer Engineering"],"contents":"Go tutorials  📔📝본 내용은 tour.golang.org 에 있는 내용을 정리한 글입니다. method 부터 concurrency 전까지  Go method! package main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) type Vertex struct { X, Y float64 } func (v Vertex) AbsMethod() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func AbsFunc(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } type MyFloat float64 // 메소드 만들때 주의사항, 일반 타입 안되고 custom 타입만 가능함. 같은 패키지 내에 선언되어 있어야함. ~~(싫어하는 이유가 계속 늘어난다!)~~ func (f MyFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } func (v *Vertex) AbsPointer(n float64) float64 { v.X = v.X * n v.Y = v.Y * n return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (v Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) fmt.Println(Abs(v)) f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) v := Vertex{3, 4} fmt.Println(v.AbsPointer(2)) // 포인터를 안쓰면 각각 다른 객체(복사된 값 사용) // 포인터를 쓰면 같은 레퍼런스를 참조하니까 같은 객체 v.Scale(10) fmt.Println(v.AbsPointer(2)) }  노트   메소드 주의사항\n  함수는 인자 넣을때 포인터 구분함(\u0026amp;붙여야됨) 메소드는 인자 넣을때 포인터 알아서 판단함 진짜 참 일관적으로 속편한 언어\u0026hellip; 언어는 속이 편한데 개발자가 불편\u0026hellip; v.Scale(5) == (\u0026amp;v).Scale(5)\n다행히 참조와 역참조 둘다 같은 특징을 가짐 p.Abs() 라는 메서드는 (*p).Abs() 로도 사용가능 그니까 value receiver이든 reference receiver 이든 메소드는 아무 신경안씀 대신 반드시 주의할점은, 레퍼런스 리시버는 값을 바꾸고, 값 리시버는 복사본을 만듬\n일반적으로 특정 유형의 모든 방법에는 값이나 포인터 리시버가 있어야 하지만 둘 다 혼합되어서는 안됩니다.\ntype Abser interface { Abs() float64 } func main() { var a Abser f := MyFloat(-math.Sqrt2) v := Vertex{3, 4} a = f // a MyFloat implements Abser fmt.Println(a.Abs()) //1.4142135623730951 a = \u0026amp;v // a *Vertex implements Abser // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. // a = v fmt.Println(a.Abs()) // 5 } type MyFloat float64 func (f MyFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) }  여기서 또 애매한 사실은,\nfunc (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) }  이렇게 하면 redeclared 라고 하면서, 아까 예제의 상황에서는\nfunc main() { a = \u0026amp;v // a *Vertex implements Abser fmt.Println(a.Abs()) // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. a = v fmt.Println(a.Abs()) } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) }  이건 또 잘 실행 된다\u0026hellip; 값 리시버에서는 주소 넣어도 되고, 값 넣어도 되는데, 주소 리시버에서는 꼭 주소만 넣어야 된다. 이게 뭐야?\n    자바를 잘몰라서\u0026hellip; 무슨 뜻이지?\n 인터페이스의 암시적 구현  type implements는 메소드를 실행함으로써 인터페이스를 구현합니다.\n명시적 intent의 선언도, \u0026ldquo;implementation\u0026quot;의 키워드도 없습니다.\n암시적 인터페이스는 인터페이스의 정의를 구현으로부터 분리하며,\n이는 사전 정렬 없이 어떠한 패키지에 등장할 수 있습니다.\n?      아래 나온 main 은 패키지 이름일듯? ({Hello}, main.T) Hello (3.141592653589793, main.F)\n  영어공부\n Under the hood : 내부 concrete type? 구체적인 타입 이름을 말하는 거겠지? 추상 타입도 있나? auto 같은거? 튜플이라고 하니까 (value, type) 직관적으로는 무슨 말을 하려고 하는지 의도는 알겠는데, 말은 모르겠다. 아무튼 이름 같아도 타입 다르면 다른거라는 거지.    nil receiver 가 좋다고 하던데\ntype I interface { M() } type T struct { S string } func (t *T) M() { // if t == nil { // fmt.Println(\u0026quot;this is\u0026quot;,t) // return // } fmt.Println(t) } /* 주석 처리 하면 (\u0026lt;nil\u0026gt;, *main.T) \u0026lt;nil\u0026gt; (\u0026amp;{hello}, *main.T) \u0026amp;{hello} 주석 풀면 (\u0026lt;nil\u0026gt;, *main.T) this is \u0026lt;nil\u0026gt; (\u0026amp;{hello}, *main.T) \u0026amp;{hello} t 를 *t 로 하면 t.S 와 같은 에러 발생 panic: runtime error: invalid memory address or nil pointer dereference 니 멋대로 해라... 아래는 실행 잘됨. func (t *T) M() { if t == nil { fmt.Println(\u0026quot;this is\u0026quot;,t) return } fmt.Println(*t) } */ func main() { var i I var t *T i = t describe(i) i.M() i = \u0026amp;T{\u0026quot;hello\u0026quot;} describe(i) i.M() } func describe(i I) { fmt.Printf(\u0026quot;(%v, %T)\\n\u0026quot;, i, i) }    type assertion\nvar i interface{} = \u0026quot;hello\u0026quot; s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // panic fmt.Println(f)    type switch\nfunc do(i interface{}) { switch v := i.(type) { case int: fmt.Printf(\u0026quot;Twice %v(%T) is %v\\n\u0026quot;, v,v, v*2) case string: fmt.Printf(\u0026quot;%q(%T) is %v bytes long\\n\u0026quot;, v,v, len(v)) default: fmt.Printf(\u0026quot;I don't know about type %T!\\n\u0026quot;, v) } } func main() { do(21) do(\u0026quot;hello\u0026quot;) do(true) }    Stringers 함수를 만들어놓으면 print할때 설정한것 처럼 나옴 함수 주석처리하면 그냥 객체만 나옴(아래 설정한 문장이 아니라)\ntype Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(\u0026quot;%v (%v years)\u0026quot;, p.Name, p.Age) } func main() { a := Person{\u0026quot;Arthur Dent\u0026quot;, 42} z := Person{\u0026quot;Zaphod Beeblebrox\u0026quot;, 9001} fmt.Println(a, z) }    io.Reader 의 타입? 아마 다른 인터페이스 (*strings.Reader)\nerror, io.EOF 의 타입은 (*errors.errorString)\n// 진도는 strings까지 했음 image 까지 하긴 했는데,\nimage 라이브러리는 나중에 사용하게 되면 다시 보는게 나을듯\n","date":"2021-07-22T19:55:35+09:00","permalink":"https://wadro.github.io/memo/cs/go/lab-golang-study-tutorials-02/","tags":["golang","go"],"title":"lab golang study tutorials 02"},{"categories":[""],"contents":"논문 레퍼런스 정리 (아래 링크를 한국어로 번역하였습니다.)\nread://https_blockchain.intellectsoft.net/?url=https%3A%2F%2Fblockchain.intellectsoft.net%2Fblog%2Fconsensus-protocols-that-meet-different-business-demands%2F\nhttps://blockchain.intellectsoft.net/blog/consensus-protocols-that-meet-different-business-demands/\noverview In our our previous post we described different types of blockchain. However, they only characterize the environment in which blockchain can operate. The heart of distributed ledger technology (DLT) is the consensus protocol.\n이전 게시물에서 다양한 유형의 블록체인에 대해 설명했습니다. 그러나 그것들은 블록체인이 작동할 수 있는 환경만을 특징짓습니다. 분산 원장 기술(DLT)의 핵심은 합의 프로토콜입니다.\nInterestingly, mathematicians and engineers have been developing distributed networks and consensensus protocols for decades but only with the emergence of Bitcoin has this technology made a leap forward. It doesn’t give any sign of stopping either, and it’s this leap forward that has allowed the variants of new rules for machine consensus to evolve. We invite you to take a glance at the most important of them.\n흥미롭게도 수학자와 엔지니어는 수십 년 동안 분산 네트워크와 합의 프로토콜을 개발해 왔지만 비트코인이 등장하면서 이 기술이 도약했습니다. 멈출 기미도 보이지 않으며, 이러한 도약 덕분에 기계 합의에 대한 새로운 규칙의 변형이 진화할 수 있었습니다. 그 중 가장 중요한 것을 한 눈에 볼 수 있도록 초대합니다.\nWhy Consensus Algorithm What is \u0026ldquo;consensus\u0026rdquo; anyway? To give a broad definition, consensus is an agreement that satisfies each of the parties involved. It’s a key to democracy and decentralization in general and DLTs in particular. Look at Bitcoin: despite having a mysterious founder in Satoshi Nakamoto, he has no power over the community whatsoever. Bitcoin as a blockchain is fully transparent and open-source, and every node is equal on the network.\n어쨌든 \u0026ldquo;합의\u0026quot;란 무엇입니까? 넓은 의미로, 합의란 만족하는 관여된 각 당사자 들을 만족시키는 동의이다. 그것은 특히 민주주의와 일반적인 지방 분권(탈중앙화) 및 DLTs 의 핵심입니다. 비트코인을 보세요: 사토시 나카모토라는 신비한 창립자가 있음에도 불구하고 그는 커뮤니티에 대한 권한이 전혀 없습니다. 블록체인으로서의 비트코인은 완전히 투명하고 오픈 소스이며 모든 노드는 네트워크에서 평등합니다.\nIn the narrow meaning that we apply to cryptography, consensus is a voting procedure. Its goal is to ensure that all members of the network agree on its current state even after the addition of a new block or a package of transactions. In other words, a consensus protocol guarantees that the chain is true and that there are incentives to keep participants fair. It’s a major framework for preventing a single entity from controlling the entire system and makes sure everybody follows the rules.\n합의를 암호에 적용시켰을때 좁은 의미로서의 합의란, 투표 절차입니다. 그 목표는 새로운 블록이나 트랜잭션 패키지를 추가한 후에도 네트워크의 모든 구성원이 현재 상태에 동의하도록 하는 것입니다. 다르게 말하면, 합의 프로토콜은 체인이 사실이고 참가자를 공정하게 유지하기 위한 인센티브가 있음을 보장합니다. 이것이 단일 개체가 전체 시스템을 제어하지 못하도록 방지하고 모든 사람이 규칙을 따르도록 하는 주요한 특징입니다.\nQuick Review Protocol = a set of rules\nProtocols help to:\n • ensure the viability of transactions in the network • eliminate double spending • alidate that participants are honest  A protocol is the sum of:\n the deterministic logical conditions of the framework cryptographic encryption as a basis of security social encouragement to maintain the given protocol  So what are some of these protocols?\n프로토콜 = 일련의 규칙\n프로토콜은 다음을 지원합니다.\n • 네트워크에서 트랜잭션의 실행 가능성 보장 • 이중 지출을 없애다 • 참가자들이 정직하다는 것을 강조  프로토콜은 다음의 합계입니다.\n • 프레임워크의 결정론적 논리적 조건 • 보안 기반으로 암호화 • 주어진 프로토콜을 유지하기 위한 사회적 격려  그렇다면 이러한 프로토콜에는 어떤 것들이 있습니까?\nProof-of-Work protocol Proof-of-Work (PoW)    Concept: Proof-of-Work (PoW)     Principle: A difficult solution to find but easy to verify.   Speed: Low   DLT setup: Public/private blockchain   Finality: Probabilistic   Example of use: Bitcoin, Ethereum, Litecoin    The Bitcoin blockchain is perhaps the most replicated blockchain. The multiple nodes running it, order the transactions according to the PoW consensus algorithm. To add new blocks, each node has to prove that it has performed a certain amount of work. To be precise, they solve a hard hashing puzzle using a high computational input.\n비트코인 블록체인은 아마도 가장 많이 복제된 블록체인일 것입니다. 이를 실행하는 여러 노드는 PoW 합의 알고리즘에 따라 트랜잭션을 주문합니다. 새 블록을 추가하려면 각 노드가 일정량의 작업을 수행했음을 증명해야 합니다. 정확하게 말하면, 그들은 높은 계산 입력을 사용하여 어려운 해싱 퍼즐을 풉니다.\nAs a result, participation in PoW carries a cost but can be implemented in an environment without trust. Since it suits permissionless blockchains, anybody can join the network. Although the scalability of peer networks is high, the transaction speed remains low. Another concern is the decrease of the reward over time and low fees in future; generally, miners join to get rich, not to voluntarily support the network.\n결과적으로 PoW 참여에는 비용이 따르지만 신뢰가 없는 환경에서 구현할 수 있습니다. 무허가 블록체인에 적합하기 때문에 누구나 네트워크에 참여할 수 있습니다. 피어 네트워크의 확장성은 높지만 트랜잭션 속도는 여전히 낮습니다. 또 다른 문제는 시간이 지남에 따라 보상이 감소하고 향후 수수료가 낮아진다는 것입니다. 일반적으로 광부들은 네트워크를 자발적으로 지원하기 위해 가입하는 것이 아니라 부자가 되기 위해 가입합니다.\nProof-of-Stake protocols Proof-of-Stake (PoS)    Concept: Proof-of-Stake (PoS)     Principle: The network trusts the validator who stakes their own coins; the bigger the stake the higher the chances of validating transactions.   Speed: Low   DLT setup: Public/private blockchain   Finality: Probabilistic   Example of use: NXT, Tezos, soon Ethereum    Turing-complete, Ethereum’s main network, is running on PoW. However, the project plans to switch to a more efficient protocol known as Proof-of-Stake in 2018. The unique feature of PoS is the absence of difficult and unnecessary computation. Instead of competing with others, network members deposit their crypto-assets, like ether in Ethereum, and wait to be randomly picked to process a validation of the network.\n이더리움의 메인 네트워크인 Turing-complete가 PoW에서 실행되고 있습니다. 그러나 프로젝트는 2018년에 Proof-of-Stake로 알려진 보다 효율적인 프로토콜로 전환할 계획입니다. PoS의 고유한 특징은 어렵고 불필요한 계산이 없다는 것입니다. 다른 사람들과 경쟁하는 대신 네트워크 구성원은 이더리움과 같은 암호화 자산을 이더리움에 예치하고 네트워크 유효성 검사를 처리하기 위해 무작위로 선택되기를 기다립니다.\nIf they’ve followed the rules, the staker creates or “mints” additional coins for validating a block of transactions. An algorithm selects one of the minters based on the stake they own. So if a node has a 5% stake, it will validate 5% of the transactions. The idea is that the higher the stake of the validator in the underlying cryptocurrency, the less interest they have in corrupting the validation process.\n그들이 규칙을 따랐다면 스테이커는 거래 블록을 검증하기 위해 추가 코인을 생성하거나 \u0026ldquo;발행\u0026quot;합니다. 알고리즘은 그들이 소유한 지분을 기반으로 발행자 중 하나를 선택합니다. 따라서 노드에 5%의 지분이 있으면 트랜잭션의 5%를 검증합니다. 기본 암호 화폐에서 유효성 검사기의 지분이 높을수록 유효성 검사 프로세스를 손상시키는 데 관심이 적어집니다.\nJust like with PoW algorithm, transaction finality in PoS is probabilistic. Though transactions are relatively fast compared to those of Bitcoin, it still requires tokens to work. Furthermore, skeptics indicate that validators with high stakes will be selected more often and thus obtain even more tokens: the rich get richer.\nPoW 알고리즘과 마찬가지로 PoS의 트랜잭션 완결성은 확률적입니다. 거래는 비트코인에 비해 상대적으로 빠르지만 작동하려면 여전히 토큰이 필요합니다. 또한 회의론자들은 높은 지분을 가진 검증인이 더 자주 선택되어 더 많은 토큰을 얻게 될 것이라고 말합니다. 부자는 더 부자가 됩니다.\nHowever, the PoS algorithm doesn’t incentivize those who don’t expend any cryptocurrency. Consequently, they are likely to vote on multiple blocks to support “forks” — copies of the blockchain with a new set of rules — while seeking to maximize the reward. This is called “nothing at stake” problem. On the other hand, the primary incentive to support the algorithm while running own node is securing funds rather than assuming that exchanges will do this for you.\n그러나 PoS 알고리즘은 암호화폐를 사용하지 않는 사람들에게 인센티브를 제공하지 않습니다. 결과적으로, 그들은 보상을 최대화하는 동시에 \u0026ldquo;포크\u0026rdquo;(새로운 규칙 세트가 있는 블록체인의 사본)를 지원하기 위해 여러 블록에 투표할 가능성이 높습니다. 이것을 \u0026ldquo;위험하지 않은 문제(?)\u0026ldquo;라고 합니다. 반면에 자체 노드를 실행하는 동안 알고리즘을 지원하는 주요 인센티브는 거래소가 이를 수행할 것이라고 가정하기 보다는 자금을 확보하는 것입니다.\nDelegated Proof-of-Stake (DPoS)    Concept: Delegated Proof-of-Stake (DPoS)     Principle: The participants delegate production of new blocks to a small and fixed number of elected participants. Highly competitive but highly profitable.   Speed: High   DLT setup: Public/private blockchain   Finality: Probabilistic   Example of use: EOS, BitShares    In the meantime, developers offered an alternative economic incentive called the Delegated Proof-of-Stake or DPoS. It allows you to generate blocks at high speed and handle a large number of transactions per second compared to other consensus algorithms. The basic principle of DPoS is to divide the voting and validation procedure among a few delegated participants.\n그 동안 개발자들은 위임 지분 증명 또는 DPoS라는 대안적인 경제적 인센티브를 제공했습니다. 다른 합의 알고리즘에 비해 빠른 속도로 블록을 생성하고 초당 많은 수의 트랜잭션을 처리할 수 있습니다. DPoS의 기본 원칙은 투표 및 검증 절차를 위임된 소수의 참가자에게 나누는 것입니다.\nDuring voting, coin holders choose the validators of transactions that will form blocks. The weight of each vote is determined by the sum of the assets of the voter. Coin holders can re-vote candidates at any time. This determines the high resilience of the network: if most of the performers fail, the community will immediately vote for their replacement.\n투표하는 동안 코인 보유자는 블록을 형성할 거래의 유효성 검사기를 선택합니다. 각 투표의 가중치는 유권자 자산의 합계로 결정됩니다. 코인 보유자는 언제든지 후보자에게 재투표할 수 있습니다. 이것은 네트워크의 높은 탄력성을 결정합니다. 대부분의 수행자가 실패하면 커뮤니티는 즉시 교체에 투표합니다.\nThe generation of new blocks happens every 1 or 2 seconds. This protocol is not only faster, but more fair since the “delegated” validator shares newly minted coins with its voters later. However, confirmation is still needed from all validators. Therefore, a user may have to wait around twenty more blocks to ensure the validity of the transaction.\n새 블록의 생성은 1초 또는 2초마다 발생합니다. 이 프로토콜은 \u0026ldquo;위임된\u0026rdquo; 검증자가 나중에 유권자와 새로 발행된 코인을 공유하기 때문에 더 빠를 뿐만 아니라 더 공정합니다. 그러나 여전히 모든 검증인의 확인이 필요합니다. 따라서 사용자는 트랜잭션의 유효성을 확인하기 위해 약 20개의 블록을 더 기다려야 할 수 있습니다.\nDaniel Larimer developed DPoS in 2014. He first used it in his BitShares project, and later in Steemit and EOS. Larimer hypothesized that validators in DPoS will have a strong incentive to remain fair and offer the fastest and best service possible. After all, it would be silly to hack a network that pays you well. And if you stop doing a good job, there are other members that are ready and willing to take the place of the validator.\nDaniel Larimer는 2014년에 DPoS를 개발했습니다. 그는 BitShares 프로젝트에서 처음으로 DPoS를 사용했고 나중에는 Steemit과 EOS에서 사용했습니다. Larimer는 DPoS의 검증인이 공정성을 유지하고 가능한 가장 빠르고 최고의 서비스를 제공할 강력한 인센티브를 가질 것이라고 가정했습니다. 결국 돈을 잘 버는 네트워크를 해킹하는 것은 어리석은 일입니다. 그리고 당신이 좋은 일을 그만둔다면, 검증인을 대신할 준비가 되어 있고 기꺼이 하는 다른 구성원이 있습니다.\nByzantine Fault Tolerance (BFT) protocols So far we’ve been talking about public blockchains that operate in a trustless environment and aim at decentralization. What about private enterprise blockchains? What if participants can trust each other? It’s true that the fewer validators a blockchain has, the faster it is. In fact, the speed increases tenfold, from hundreds to thousands of transactions per second, which is a great fit for corporate blockchain solutions.\n지금까지 우리는 무신뢰 환경에서 작동하고 탈중앙화를 목표로 하는 퍼블릭 블록체인에 대해 이야기했습니다. 민간 기업 블록체인은 어떻습니까? 참가자들이 서로를 신뢰할 수 있다면 어떨까요? 블록체인에 검증인이 적을수록 더 빠른 것이 사실입니다. 실제로 속도는 초당 수백에서 수천 개의 트랜잭션으로 10배 증가하므로 기업 블록체인 솔루션에 매우 적합합니다.\nByzantine Fault Tolerance (BFT) protocol is a different class of protocols that does not require tokens during the voting as in a PoS algorithm. Furthermore, it allows signing of a block even when 1/3 of the actors fail or act maliciously. BFT resolves the problem of numerous faults in the system and the waiting time of up to 30 seconds for confirming a block.\nBFT(Byzantine Fault Tolerance) 프로토콜은 PoS 알고리즘에서와 같이 투표 중에 토큰이 필요하지 않은 다른 종류의 프로토콜입니다. 또한 액터의 1/3이 실패하거나 악의적으로 행동하더라도 블록에 서명할 수 있습니다. BFT는 시스템의 수많은 장애와 블록 확인을 위한 최대 30초의 대기 시간 문제를 해결합니다.\nIn fact, the algorithm refers to an old Byzantine Generals’ problem, based on a real historical event. Using the analogy, the protocol does not care if a “general” got sick or sabotaged the counterparts — the system will still function even when the node goes offline.\n사실, 알고리즘은 실제 역사적 사건을 기반으로 한 오래된 비잔틴 장군의 문제를 나타냅니다. 유추를 사용하면 프로토콜은 \u0026ldquo;장군\u0026quot;이 아프거나 상대방을 방해하는 경우 신경 쓰지 않습니다. 노드가 오프라인 상태가 된 경우에도 시스템은 계속 작동합니다.\nDelegated Byzantine Fault Tolerance (DBFT)    Concept: Delegated Byzantine Fault Tolerance (DBFT)     Principle: Preselected nodes maintain consensus even if some of them fail or are malicious.   Speed: Very high   DLT setup: Public/private blockchain   Finality: Immediate   Example of use: NEO, TON    So the BFT consensus protocol seems like salvation from the imperfections of PoW and PoS, but given thousands of validators, it would still struggle to resolve the speed issue. This is why developers offered a delegated model of BFT — the DBFT.\nPredefined validators in this consensus protocol allow it to far outstrip other protocols. Take Ethereum with 15-20 transactions per second and NEO with almost 10,000 t/s. It is indeed convenient to have a few known actors who validate transactions before releasing to other nodes. In case a validator betrays the network, participants can delegate a different node.\nNote: since NEO runs on PoS DBFT protocol, the network members not only delegate validators but also receive a native token GAS as part of their validator stake.\n따라서 BFT 합의 프로토콜은 PoW 및 PoS의 불완전함에서 구원받는 것처럼 보이지만 수천 명의 검증인을 고려할 때 속도 문제를 해결하는 데 여전히 어려움을 겪을 것입니다. 이것이 개발자들이 BFT의 위임 모델인 DBFT를 제안한 이유입니다.\n이 합의 프로토콜의 사전 정의된 검증자는 다른 프로토콜을 훨씬 능가합니다. 초당 15-20개의 트랜잭션으로 이더리움을, 거의 10,000t/s로 NEO를 사용하십시오. 다른 노드에 릴리스하기 전에 트랜잭션을 검증하는 알려진 행위자가 몇 명 있는 것이 참으로 편리합니다. 검증인이 네트워크를 배신하는 경우 참가자는 다른 노드를 위임할 수 있습니다.\n참고: NEO는 PoS DBFT 프로토콜에서 실행되기 때문에 네트워크 구성원은 검증인을 위임할 뿐만 아니라 검증인 지분의 일부로 기본 토큰 GAS를 받습니다.\nPractical Byzantine Fault Tolerance (PBFT)    Concept: Practical Byzantine Fault Tolerance (PBFT)     Principle: Standard blockchain for enterprise.   Speed: High   DLT setup: Private permissioned blockchain   Finality: Immediate   Example of use: Hyperledger, Chain    If one wants a scalable and fast blockchain, this is a way to go. PBFT protocol is very similar to DBFT, especially in regard to its more centralized nature. The only difference is that the former has a simpler implementation and is often a private blockchain with appointed signing nodes from the very beginning. Which is kind of practical, isn’t it?\nWhen a validator receives a message, it performs a computation, and then asks all other nodes in turn if the transaction is valid. After confirming validation, the first validator broadcasts the decision to the network of other validators. In this way, consensus is achieved based on the confirmation being submitted by all validators.\nPBFT is effective in low latency systems but sensitive to the number of validators and throughput. It fits well for private setups which don’t require a large amount of capacity, but demand many transactions. PBFT guarantees the accuracy of transaction records within the network.\nYou may also have encountered SIEVE protocol which is a type of PBFT. It handles non-deterministic chaincode execution. There is also Cross Fault Tolerance (XFT) protocol as well as Paxos and Raft protocols which are Crash Fault Tolerant (CFT). We might cover these deep technical characteristics in future articles but if it’s important to you, you could always ask us.\n확장 가능하고 빠른 블록체인을 원한다면 이것이 바로 갈 길입니다. PBFT 프로토콜은 특히 중앙 집중식 특성과 관련하여 DBFT와 매우 유사합니다. 유일한 차이점은 전자는 구현이 더 간단하고 처음부터 서명 노드가 지정된 프라이빗 블록체인인 경우가 많다는 것입니다. 어떤 것이 실용적이지 않습니까?\n유효성 검사기는 메시지를 수신하면 계산을 수행한 다음 트랜잭션이 유효한지 다른 모든 노드에 차례로 묻습니다. 유효성 검사를 확인한 후 첫 번째 유효성 검사자는 결정을 다른 유효성 검사자의 네트워크에 브로드캐스트합니다. 이러한 방식으로 모든 검증자가 제출한 확인을 기반으로 합의가 이루어집니다.\nPBFT는 대기 시간이 짧은 시스템에서 효과적이지만 검증인의 수와 처리량에 민감합니다. 많은 용량을 필요로 하지 않지만 많은 트랜잭션을 요구하는 개인 설정에 적합합니다. PBFT는 네트워크 내 거래 기록의 정확성을 보장합니다.\n또한 PBFT 유형인 SIEVE 프로토콜을 접했을 수도 있습니다. 비결정적 체인코드 실행을 처리합니다. XFT(Cross Fault Tolerance) 프로토콜과 CFT(Crash Fault Tolerant)인 Paxos 및 Raft 프로토콜도 있습니다. 우리는 향후 기사에서 이러한 심층적인 기술적 특성을 다룰 수 있지만 그것이 당신에게 중요하다면 언제든지 Google에 문의할 수 있습니다.\nFederated Byzantine Agreement (FBA)    Concept: Federated Byzantine Agreement (FBA)     Principle: Blocks are validated if signed by a specified quorum of signers.   Speed: High   DLT setup: Public or private permissionless blockchain   Finality: Immediate   Example of use: Stellar, Ripple    Here you have a permissionless BFT protocol as opposed to the permissioned PBFT and other variants of BFT. A Federated Byzantine Agreement (FBA) allows anybody to join the network but transactions are verified by a group instead of one node broadcasting the message to others.\nNotably, FBA has Gateways and Market-Makers which ensure the fairness and liquidity of the network. The former act as traditional banks holding the fiat funds and creating an equivalent in virtual tokens. Market-makers keep accounts with multiple Gateways and in several currencies.\n여기에는 허가된 PBFT 및 기타 BFT 변형과 달리 허가 없는 BFT 프로토콜이 있습니다. FBA(Federated Byzantine Agreement)를 통해 누구나 네트워크에 가입할 수 있지만 트랜잭션은 한 노드가 메시지를 다른 노드에 브로드캐스팅하는 대신 그룹에 의해 확인됩니다.\n특히 FBA에는 네트워크의 공정성과 유동성을 보장하는 게이트웨이 및 마켓 메이커가 있습니다. 전자는 명목 펀드를 보유하고 가상 토큰으로 이에 상응하는 것을 생성하는 전통적인 은행 역할을 합니다. 시장 조성자는 여러 게이트웨이와 여러 통화로 계정을 유지합니다.\nQuick Review   • Proof-of-Work has been the first and most reliable consensus protocol for public blockchains like Bitcoin and Ethereum, yet it is energy-inefficient.\n  • Proof-of-Stake does not require hard computation. Instead, it encourages users to stake their own funds to perform the equivalent quantity of transaction validations and assumes everyone will act rationally.\n  • BFT is an addition to PoS concept that makes it much faster and more tolerant to faulty nodes. It’s only practical to run on small and private setups though.\n  • PBFT is a proven solution for corporate blockchains. Fast and safe but relies on throughput.\n  • DBFT improves BFT by allowing participants of the BFT network to delegate their validators. Very fast but more centralized.\n  • While the abovementioned BFT variants are permissioned blockchains, FBA is federated and, thus, permissionless. But there are more protocols…\n  • 작업 증명은 비트코인 및 이더리움과 같은 공개 블록체인을 위한 최초이자 가장 신뢰할 수 있는 합의 프로토콜이지만 에너지 비효율적입니다.\n  • 지분 증명은 어려운 계산을 필요로 하지 않습니다. 대신, 사용자가 동일한 양의 거래 검증을 수행하기 위해 자신의 자금을 걸도록 권장하고 모든 사람이 합리적으로 행동할 것이라고 가정합니다.\n  • BFT는 PoS 개념에 추가된 것으로 결함이 있는 노드에 대해 훨씬 빠르고 관대합니다. 그러나 소규모 및 개인 설정에서만 실행하는 것이 실용적입니다.\n  • PBFT는 기업 블록체인을 위한 검증된 솔루션입니다. 빠르고 안전하지만 처리량에 의존합니다.\n  • DBFT는 BFT 네트워크 참가자가 검증인을 위임할 수 있도록 하여 BFT를 개선합니다. 매우 빠르지만 더 중앙 집중화되어 있습니다.\n  • 위에서 언급한 BFT 변종은 허가된 블록체인이지만 FBA는 연합되어 있으므로 허가가 없습니다. 그러나 더 많은 프로토콜이 있습니다 \u0026hellip;\n  Directed Acyclic Graph protocol Researcher Serguei Popov ran a thought experiment: what if we can avoid blocks completely?\nSerguei Popov 연구원은 사고 실험을 실행했습니다. 블록을 완전히 피할 수 있다면 어떨까요?\nDirected Acyclic Graph (DAG)    Concept: Directed Acyclic Graph (DAG)     Principle: No fixed blocks that are confirmed in a random order on a linear scale.   Speed: High   DLT setup: Public permissioned non-blockchain   Finality: Probabilistic   Example of use: IOTA, ByteBall    The major issue with blockchain is its synchronous nature. Blockchains cannot be parallel. One can change the size or frequency of blocks as well as the parties that approve them, but there will always be a waiting queue. Alternately, Directed Acyclic Graph (DAG) technology is asynchronous which gives the competitive advantage of simultaneous events.\nThe protocol in such systems lets participants confirm a block of transactions a few blocks away, since there will eventually be another participant proving it is correct. While this implies ultra high speeds for the network, it’s slow on a smaller scale. Additionally, there’s a danger of parasite “chains” of non-valid transactions and centralization due to preselected validators.\n블록체인의 주요 문제는 동기적 특성입니다. 블록체인은 병렬일 수 없습니다. 블록의 크기나 빈도와 블록을 승인하는 당사자를 변경할 수 있지만 항상 대기 대기열이 있습니다. 또는 DAG(Directed Acyclic Graph) 기술은 동시 이벤트의 경쟁 우위를 제공하는 비동기식입니다.\n이러한 시스템의 프로토콜을 사용하면 참가자가 몇 블록 떨어진 곳에서 트랜잭션 블록을 확인할 수 있습니다. 결국 다른 참가자가 그것이 옳다는 것을 증명할 것이기 때문입니다. 이것은 네트워크의 초고속 속도를 의미하지만 소규모에서는 느립니다. 또한 사전 선택된 유효성 검사기로 인해 유효하지 않은 거래 및 중앙 집중화의 기생 \u0026ldquo;체인\u0026quot;의 위험이 있습니다.\nHashGraph    Concept: HashGraph     Principle: Nodes communicate randomly using the ‘gossip about gossip’ protocol and agree on consensus after a certain communication round.   Speed: Very High   DLT setup: Private permissioned non-blockchain   Finality: Round based   Example of use: HashGraph    The developers of this protocol claim that blockchain is an outdated system. As a substitute, they also advocate for the DAG concept. However, the key difference of HashGraph is a “gossip to gossip” protocol, where a node receives a time-stamped set of transactions that the other node “knows” about. As a result, there is an endless hash tree — or a graph — that grows over time with millions of time-stamps, the leaves. Once the majority of the network agrees on a particular event, there is no doubt it is valid.\nThere are certain limitations however. First of all, there is little evidence of practical implementation on a large scale, especially when compared to working blockchain projects. Secondly, HashGraph technology is patented and acquiring a license costs money. This also leads to the third issue: the lack of a strong community (like those associated with open-source projects). Such a community can test the robustness of a protocol, its vulnerability towards hackers and issues of compatibility. HashGraph is currently available for private setup only.\n이 프로토콜의 개발자는 블록체인이 구식 시스템이라고 주장합니다. 대안으로서 그들은 또한 DAG 개념을 옹호합니다. 그러나 HashGraph의 주요 차이점은 \u0026ldquo;가십 대 가십\u0026rdquo; 프로토콜로, 한 노드가 다른 노드가 \u0026ldquo;알고 있는\u0026rdquo; 타임 스탬프 트랜잭션 집합을 수신합니다. 결과적으로 수백만 개의 타임 스탬프와 함께 시간이 지남에 따라 성장하는 끝없는 해시 트리 또는 그래프가 있습니다. 네트워크의 과반수가 특정 이벤트에 동의하면 그것이 유효하다는 데는 의심의 여지가 없습니다.\n그러나 특정 제한 사항이 있습니다. 우선, 특히 작업 중인 블록체인 프로젝트와 비교할 때 대규모로 실질적인 구현에 대한 증거가 거의 없습니다. 둘째, HashGraph 기술은 특허를 받았고 라이센스를 얻는 데 비용이 듭니다. 이것은 또한 세 번째 문제로 이어집니다. 강력한 커뮤니티(오픈 소스 프로젝트와 관련된 커뮤니티와 같은)의 부족입니다. 이러한 커뮤니티는 프로토콜의 견고성, 해커에 대한 취약성 및 호환성 문제를 테스트할 수 있습니다. HashGraph는 현재 비공개 설정에만 사용할 수 있습니다.\nOther Consensus Protocols for Specific Tasks As if that wasn’t enough, people have pushed technology and the imagination even further . More researchers and blockchain developers have experimented with new consensus models that would resolve different business challenges.\n그것으로 충분하지 않다는 듯이 사람들은 기술과 상상력을 더욱 밀어붙였습니다. 더 많은 연구원과 블록체인 개발자가 다양한 비즈니스 과제를 해결할 수 있는 새로운 합의 모델을 실험했습니다.\nProof-of-Activity (PoA)    Concept: Proof-of-Activity (PoA)     Principle: A hybrid of PoW and PoS   Speed: Low   DLT setup: Public permissionless blockchain   Finality: Probabilistic   Example of use: Decred    Proof-of-Activity (PoA) combines PoW and PoS protocols meaning that the participants can both mine and stake their coins to validate blocks. This way, the PoA protocol ensures a balance between miners and common participants of the network.\n활동 증명(PoA)은 PoW와 PoS 프로토콜을 결합하여 참가자가 블록을 검증하기 위해 코인을 채굴하고 스테이킹할 수 있음을 의미합니다. 이러한 방식으로 PoA 프로토콜은 광부와 네트워크의 일반 참가자 간의 균형을 보장합니다.\nProof-of-Location (PoL)    Concept: Proof-of-Location (PoL)     Principle: Use beacons to notice a node in a synchronized manner and then timestamp its presence.   Speed: Medium   DLT setup: Public permissionless blockchain   Finality: Immediate   Example of use: FOAM, Platin    Proof-of-Location (PoL) lets users privately record authenticated location data when they choose so, without GPS. Then, they can reveal this personal information at will.\nInterestingly, the protocol relies on the BFT of the beacons that record geolocation and timestamp it in the blockchain which prevents the system from failures and frauds.\n위치 증명(PoL)을 사용하면 사용자가 원하는 경우 GPS 없이 인증된 위치 데이터를 비공개로 기록할 수 있습니다. 그런 다음 이 개인 정보를 마음대로 공개할 수 있습니다.\n흥미롭게도 이 프로토콜은 지리적 위치를 기록하고 블록체인에 타임스탬프를 기록하는 비콘의 BFT에 의존하여 시스템 실패 및 사기를 방지합니다.\nProof-of-Importance (PoI)    Concept: Proof-of-Importance (PoI)     Principle: Like PoS but with additional properties that influence your ranking.   Speed: High   DLT setup: Public permissionless blockchain   Finality: Probabilistic   Example of use: NEM    The Proof-of-Importance (PoI) consensus algorithm acts almost like PoS but includes three components:\n • The number of tokens in the account • Account transaction activity • Time the has account spent in the network  While the first parameter plays a major role in the ranking for verifying transactions, the second and third parameters are rather weak but still help with establishing the “importance” of an account. The smaller the sum of tokens, the stronger influence of other parameters.\nThus, an account that “vested” hundreds of thousands of tokens can increase its significance factor up to 3 times due to its activity and consistent presence in the network. On the other hand, it doesn’t make any difference for those who possess hundreds of millions of tokens in their account.\nPoI(Proof-of-Importance) 합의 알고리즘은 PoS와 거의 비슷하게 작동하지만 세 가지 구성요소를 포함합니다.\n • 계정의 토큰 수 • 계정 거래 활동 • 네트워크에서 사용한 계정 시간  첫 번째 매개변수가 거래 검증 순위에서 중요한 역할을 하는 반면, 두 번째와 세 번째 매개변수는 다소 약하지만 여전히 계정의 \u0026ldquo;중요성\u0026quot;을 설정하는 데 도움이 됩니다. 토큰 합계가 작을수록 다른 매개변수의 영향이 더 강해집니다.\n따라서 수십만 개의 토큰을 \u0026ldquo;베팅\u0026quot;한 계정은 활동과 네트워크에서의 일관된 존재로 인해 중요도를 최대 3배까지 높일 수 있습니다. 반면에 계정에 수억 개의 토큰을 보유하고 있는 사람들에게는 아무런 차이가 없습니다.\nProof-of-Elapsed-Time (PoET)    Concept: Proof-of-Elapsed-Time (PoET)     Principle: Blocks are created in a trusted environment with equal periods   Speed: Medium   DLT setup: Private permissioned or permissionless blockchain   Finality: Probabilistic   Example of use: Intel    Chipmaker Intel didn’t lag behind and developed their own blockchain entitled IntelLedger. A consensus algorithm of IntelLedger is called Proof of Elapsed Time (PoET). Today, it is a HyperLedger consensus module.\nThis system is similar to Proof-of-Work, but consumes far less electricity. Instead of having participants solve a cryptographic puzzle, the algorithm operates in a Trusted Execution Environment (TEE), such as Intel’s Software Guard Extensions (SGX). The PoET protocol also assures blocks get created through a lottery but without any required work.\nIntel’s solution offers a guaranteed wait time due to the TEE. According to the company, the proof-of-elapsed-time algorithm can scale to thousands of nodes and will properly run on any Intel processor that supports SGX. Isn’t blockchain supposed to be helping us to get away from third parties rather than relying on them though?\n칩 제조업체 Intel은 뒤처지지 않고 IntelLedger라는 자체 블록체인을 개발했습니다. IntelLedger의 합의 알고리즘을 PoET(Proof of Elapsed Time)라고 합니다. 오늘은 HyperLedger 합의 모듈입니다.\n이 시스템은 작업 증명과 유사하지만 훨씬 적은 전력을 소비합니다. 참가자가 암호화 퍼즐을 풀도록 하는 대신 알고리즘은 Intel의 SGX(Software Guard Extensions)와 같은 TEE(신뢰할 수 있는 실행 환경)에서 작동합니다. PoET 프로토콜은 또한 복권을 통해 블록이 생성되지만 필요한 작업 없이도 보장합니다.\n인텔의 솔루션은 TEE로 인해 보장된 대기 시간을 제공합니다. 회사에 따르면 경과 시간 증명 알고리즘은 수천 개의 노드로 확장할 수 있으며 SGX를 지원하는 모든 인텔 프로세서에서 제대로 실행됩니다. 블록체인은 우리가 제3자에게 의존하기보다 제3자로부터 벗어날 수 있도록 도와야 하지 않을까요?\nBeyond the Mainstream Protocols There are more exotic protocols like Proof-of-Stake-Time (PoST) and Proof-of-Brain (PoB) that we just couldn’t fit in this article. Find them in Part II. Moreover, our Blockchain glossary will help you keep on top of the ever growing collection of Blockchain related terminology.\nPoST(Proof-of-Stake-Time) 및 PoB(Proof-of-Brain)와 같은 더 특이한 프로토콜이 있지만 이 기사에서는 다루지 못했습니다. 파트 II에서 찾으십시오. 또한, 블록체인 용어집을 통해 계속 증가하는 블록체인 관련 용어 모음을 파악하는 데 도움이 될 것입니다.\n◼[end]\n","date":"2021-07-15T13:30:26+09:00","permalink":"https://wadro.github.io/memo/graduate/references/consensus-protocols-that-meet-different-business-demands.-part-i/","tags":[""],"title":"Consensus Protocols That Meet Different Business Demands  Part I"},{"categories":["Computer Engineering"],"contents":"Go tutorials  📔📝본 내용은 tour.golang.org 에 있는 내용을 정리한 글입니다.  Hello, Go world! (전 튜토리얼을 하나로 모음) package main // 파일들(함수들)을 모아놓은 하나의 세트 import ( // 이런식으로 한번에 임포트 하는것이 권장됨(factored style) \u0026quot;fmt\u0026quot; // 표준 라이브러리 \u0026quot;time\u0026quot; // 시간 관련 라이브러리 \u0026quot;math/rand\u0026quot; // package rand 로 시작하는 파일들로 구성됨. \u0026quot;math/cmplx\u0026quot; // 복소수 라이브러리 \u0026quot;strings\u0026quot; // 문자열 관련 함수 모음 ) /* 함수 선언 방법: func 함수명(변수_이름 타입, ...) 출력_타입 { ... return 출력값 } */ func add(x int, y int) int { return x + y } /* 위와 같은 함수: func add(x, y int) int { // 같은 타입이면 묶어서 선언 가능 return x + y } */ func swap(x, y string) (string, string) { return y, x // 복수 개의 결과 출력 가능 } func split(sum int) (x, y int) { // 결과값에 이름 붙일수 있음 x = sum * 4 / 9 y = sum - x return // 아무것도 없으면 결과값으로 선언한 변수들이 출력됨 } func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { // if 변수 선언(스코프는 if 또는 else {}블록안에서만 유효함) return v } return lim } var c, python, java bool // 전역변수 var i, j int = 1, 2 // 초기값 선언 var ( // factored 선언 가능 ToBe bool = false MaxInt uint64 = 1\u0026lt;\u0026lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) const Pi = 3.14 // 상수는 := 표기법으로 선언 못함 func main() { fmt.Println(\u0026quot;Hello, 世界\u0026quot;) // \\n 포함된 함수 fmt.Println(\u0026quot;The time is\u0026quot;, time.Now()) // 현재 시각 출력 fmt.Println(math.pi) // 대문자로 시작하면 export 되고(다른 파일에서 사용가능), 소문자로 시작하면 export 안됨 fmt.Println(add(42, 13)) a, b := swap(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) var i int // 지역변수, i 초기화(0) var c, python, java = true, false, \u0026quot;no!\u0026quot; // 선언된 값으로 초기화 k := 3 // 함수 안에서는 짧은 표현식 가능, 함수 밖에서는 에러. var 로 시작해야함 fmt.Println(i,j,k, c, python, java) fmt.Printf(\u0026quot;Type: %T Value: %v\\n\u0026quot;, ToBe, ToBe) fmt.Printf(\u0026quot;Type: %T Value: %v\\n\u0026quot;, MaxInt, MaxInt) fmt.Printf(\u0026quot;Type: %T Value: %v\\n\u0026quot;, z, z) sum := 0 for i := 0; i \u0026lt; 10; i++ { sum += i } fmt.Println(sum) sum = 1 for ; sum \u0026lt; 1000; { sum += sum } fmt.Println(sum) sum = 1 for sum \u0026lt; 1000 { // for == while sum += sum if sum \u0026gt; 100 { break } } fmt.Println(sum) /* for { } // 무한 루프 */ // Go 의 switch문은 break 안해도 된다! switch os := runtime.GOOS; os { case \u0026quot;darwin\u0026quot;: fmt.Println(\u0026quot;OS X.\u0026quot;) case \u0026quot;linux\u0026quot;: fmt.Println(\u0026quot;Linux.\u0026quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(\u0026quot;%s.\\n\u0026quot;, os) } switch { // 조건 없으면 switch true 와 같음 case t.Hour() \u0026lt; 12: fmt.Println(\u0026quot;Good morning!\u0026quot;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026quot;Good afternoon.\u0026quot;) default: fmt.Println(\u0026quot;Good evening.\u0026quot;) } /* 1. defer 문은 자신이 포함된 함수 블록이 전부 실행되면 제일 마지막에 실행됨 2. stack 구조(defer 를 두개 하면 나중에 들어간 쪽이 먼저 실행됨) */ defer fmt.Println(\u0026quot;world\u0026quot;) for i := 0; i \u0026lt; 10; i++ { defer fmt.Println(i) } /* Go의 포인터는 포인터 연산없이 그냥 주소 ⊃ 값 의 관계, address ⊃ value 의 관계에서 address == \u0026amp;value 참조(주소\u0026lt;-값) *address == value 역참조(주소-\u0026gt;값) */ i, j := 42, 2701 p := \u0026amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = \u0026amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.Println(j) // see the new value of j type Vertex struct { // 구조체는 여러 타입을 하나로 모은 집합 X int Y int } fmt.Println(Vertex{1, 2}) v := Vertex{1, 2} v.X = 4 // .(dot) 오퍼레이터로 접근 가능 fmt.Println(v.X) v := Vertex{1, 2} p := \u0026amp;v // 원래는 주소값이니까 (*p).X 이렇게 써야하는데 p.X = 1e9 // 생략 가능함 /* c 에서는 -\u0026gt; (arrow) 오퍼레이터를 썼는데 Go 에서는 단순함을 위해서 그냥 생략한듯? 나중에 함수형을 지원하기 위해서일까? 아직까지도 안넣은거 보면 그냥 아예 생각이 없는듯 2021-07-18T16:24:50+09:00 */ fmt.Println(v) v1 = Vertex{1, 2} // has type Vertex v2 = Vertex{Y: 1} // X:0 is implicit? v3 = Vertex{} // X:0 and Y:0 p = \u0026amp;Vertex{1, 2} // has type *Vertex // 쉽게(?!) 기억하는 법 // type =\u0026gt; some value of some type ==\u0026gt; x: type // array =\u0026gt; n number of type ==\u0026gt; [n]type var a [10]int // declares a variable a as an array of **ten integers** // 주의: array 는 타입의 일종이므로 resize 불가 // array의 카피본인 slice 라는 개념이 있음 // 주의2: slice 는 레퍼런스를 공유함 // 즉, slice 수정하면 array 도 수정됨 // 그리고 같은 array를 레퍼런스를 가지는 slice 또한 레퍼런스를 공유함 primes := [6]int{2, 3, 5, 7, 11, 13} var s []int = primes[1:4] fmt.Println(s) // slice만 만들면 array는 자동 생성됨(일종의 레퍼런스) q := []int{2, 3, 5, 7, 11, 13} fmt.Println(q) q1 := q[0:4] q1[2] = 1000 r := []bool{true, false, true, true, false, true} fmt.Println(r) fmt.Println(q) s := []struct { i int b bool }{ {2, true}, {3, false}, {5, true}, {7, true}, {11, false}, {13, true}, } fmt.Println(s) s := []int{2, 3, 5, 7, 11, 13} s = s[1:4] fmt.Println(s) s = s[:2] fmt.Println(s) // 상한 하한 없으면 그냥 끝까지 s = s[1:] fmt.Println(s) s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length. s = s[:1] printSlice(s) // Extend its length. s = s[1:4] printSlice(s) s = s[:5] printSlice(s) // Drop its first two values. s = s[2:] printSlice(s) s = s[2:] printSlice(s) s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length. s = s[2:] printSlice(s) // Extend its length. s = s[1:2] printSlice(s) s = s[:3] printSlice(s) // Drop its first two values. s = s[2:] printSlice(s) s = s[1:] printSlice(s) s = s[:1] printSlice(s) var s []int var p *int fmt.Println( s, len(s), cap(s),p) if s == nil { fmt.Println(\u0026quot;nil slice\u0026quot;) } if p == nil { fmt.Println(\u0026quot;nil pointer\u0026quot;) } fmt.Printf(\u0026quot;%T, %T\u0026quot; ,s,p) a := make([]int, 5) printSliceAndString(\u0026quot;a\u0026quot;, a) b := make([]int, 0, 5) printSliceAndString(\u0026quot;b\u0026quot;, b) c := b[:2] printSliceAndString(\u0026quot;c\u0026quot;, c) d := c[2:5] printSliceAndString(\u0026quot;d\u0026quot;, d) board := [][]string{ []string{\u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;}, []string{\u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;}, []string{\u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;}, } // The players take turns. board[0][0] = \u0026quot;X\u0026quot; board[2][2] = \u0026quot;O\u0026quot; board[1][2] = \u0026quot;X\u0026quot; board[1][0] = \u0026quot;O\u0026quot; board[0][2] = \u0026quot;X\u0026quot; fmt.Println(len(board)) fmt.Println((board[0])) // strings.Join -\u0026gt; string // func append(s []T, vs ...T) []T for i := 0; i \u0026lt; len(board); i++ { fmt.Printf(\u0026quot;%s\\n\u0026quot;, strings.Join(board[i], \u0026quot; \u0026quot;)) } var s []int printSlice(s) if s == nil { fmt.Println(\u0026quot;nil slice!\u0026quot;) } // append works on nil slices. s = append(s, 0) printSlice(s) if s == nil { fmt.Println(\u0026quot;nil slice!\u0026quot;) } // The slice grows as needed. s = append(s, 1) printSlice(s) // We can add more than one element at a time. s = append(s, 2, 3, 4) printSlice(s) // range =\u0026gt; iterator // for 문 하고 같이 쓰이니까 그냥 하나의 문법이라고 보는게 맞을듯 var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} for i, v := range pow { fmt.Printf(\u0026quot;2**%d = %d\\n\u0026quot;, i, v) } for i:=0; i\u0026lt;len(pow); i++ { fmt.Printf(\u0026quot;2**%d = %d\\n\u0026quot;, i, pow[i]) } fmt.Printf(\u0026quot;this is range\\n\u0026quot;) for i, d := range pow { res := math.Pow(2, float64(i)) fmt.Printf(\u0026quot;2**%d = %d == %f\\n\u0026quot;, i,d,res) } fmt.Println() fmt.Printf(\u0026quot;this is just for loop\\n\u0026quot;) for i:=0; i\u0026lt;len(pow); i++ { res := math.Pow(2, float64(i)) fmt.Printf(\u0026quot;2**%d = %d == %f\\n\u0026quot;, i, pow[i], res) } // 이거 좋은 구문인듯, 2 거듭제곱을 이런식으로 구한다는게 비트연산이라서 좋을듯 // 확실히 이런 부분을 좀 배우면 좋을텐데... pow := make([]int, 10) for i := range pow { pow[i] = 1 \u0026lt;\u0026lt; uint(i) // == 2**i } for _, value := range pow { fmt.Printf(\u0026quot;%d\\n\u0026quot;, value) } type Gps struct { Lat, Long float64 } var m map[string]Gps m = make(map[string]Gps) m[\u0026quot;Bell Labs\u0026quot;] = Gps{ 40.68433, -74.39967, } fmt.Println(m[\u0026quot;Bell Labs\u0026quot;]) var m = map[string]Gps{ \u0026quot;Bell Labs\u0026quot;: Vertex{ 40.68433, -74.39967, }, \u0026quot;Google\u0026quot;: { 37.42202, -122.08408},} msi := make(map[string]int) msi[\u0026quot;Answer\u0026quot;] = 42 fmt.Println(\u0026quot;The value:\u0026quot;, msi[\u0026quot;Answer\u0026quot;]) msi[\u0026quot;Answer\u0026quot;] = 48 fmt.Println(\u0026quot;The value:\u0026quot;, msi[\u0026quot;Answer\u0026quot;]) delete(msi, \u0026quot;Answer\u0026quot;) fmt.Println(\u0026quot;The value:\u0026quot;, msi[\u0026quot;Answer\u0026quot;]) val, ok := msi[\u0026quot;Answer\u0026quot;] fmt.Println(\u0026quot;The value:\u0026quot;, val, \u0026quot;Present?\u0026quot;, ok) hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Printf(\u0026quot;type is %T\\n\u0026quot;,hypot) fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow)) pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println( pos(i), neg(-2*i), ) } /* 또 싫어하는 점 발견... 세미콜론은 강제하지 않으면서 struct 의 콤마는 강제 됨... 콤마 안하면 에러남... 콤마 대신 {} 중괄호 블록을 닫으면 에러 안남. 진짜 이상한데도 간단해서 사람들이 쓰는건가? javascript 나 lisp 처럼? 차라리 rust 를 쓰겠다. 웹은 대체제가 따로 없고 그냥 트랜스파일러? 트랜스 컴파일러만 있을뿐이고... lisp 는 문법이 워낙 단순하지만 해석하기가 좀 힘든 면이 있어서... 진짜 극도의 단순함을 추구하는 변태적인 언어라고 해야하나... haskell 도 따지고 보면 엄밀한 순수함을 따지는 변태고... 언어라는게 다 그렇지뭐... rust도 안해봐서 그렇지 막상 배우면 또 뭔가 있을지는 모르겠다. 근데 ownership 에 너무 반해서 또 빨리 배우고 싶은 마음도 공존함. */ /* A slice is formed by specifying two indices, a low and high bound, separated by a colon: a[low : high] #slice-2 아무튼 그래도 정리를 하자면, capacity 라는 개념은 low bound 에만 영향을 받는다 high bound 에는 아무런 영향이 없다 length 라는 개념은 low bound, high bound 모두의 영향을 받는다 The zero value of a slice is nil. A nil slice has a length and capacity of 0 and has no underlying array. */ /* #slice-1 여기서 내가 go를 싫어하는 이유 계산 방식이 통일되지않고 좌우가 다르다 어떤 느낌이냐면, 나중에 gob 이라는 라이브러리에서 인코딩 할때는 비어있는 버퍼를 인코더 영역으로 지정하고 b 라는 변수를 인코딩해서 저장한다 (여기서 b 는 Block이라는 타입의 포인터 =\u0026gt; 즉, 주소) var res bytes.Buffer encoder := gob.NewEncoder(\u0026amp;res) err := encoder.Encode(b) 그리고 디코딩 할때는 data의 스트림을 받아서 디코더 객체로 만듬 그리고나서 만들어진 객체를 디코딩하는데, 이때 비어있는 block 이라는 변수의 주소에 집어넣음 (여기서 block 은 Block이라는 타입의 값 =\u0026gt; 주소 아님) var block Block decoder := gob.NewDecoder(bytes.NewReader(data)) err := decoder.Decode(\u0026amp;block) 참고: binary 라이브러리 쓸떄, .BigEndian 은 인자 순서대로 들어가고, .LittleEndian 은 인자의 역순으로 들어감 그래서 랭귀지가 프로그래머에 맞추는게 아니라, 프로그래머가 랭귀지에 맞춰야하는 어이없는 상황이 생긴다 함수형 언어처럼 여러 제약에 적응해서 얻는게 많으면 몰라도, 이건 그냥 언어 자체가 주는 혼란때문에 얻는것도 없이 헷갈리게 된다 차라리 아예 자유도를 높이려면 clojure 처럼 아예 규칙이 몇개 없던지, (심플해서 코드는 빨리 읽는데, 코드를 이해하기가 어렵다 컴퓨터는 이해하기 쉬울듯) haskell이나 rust 처럼 아예 자유도를 제한해서 표현력을 잃는 대신, 깔끔함과 안정성을 확보하는게 낫다고 생각한다 (코드를 읽기는 어려운 대신, 이해하는건 상대적으로 쉽다 인간이 이해하기 쉬운 수학과 유사한 문법) */ } func compute(fn func(float64, float64) float64) float64 { return fn(3, 4) } func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func printSlice(s []int) { fmt.Printf(\u0026quot;len=%d cap=%d %v\\n\u0026quot;, len(s), cap(s), s) } func printSliceAndString(s string, x []int) { fmt.Printf(\u0026quot;%s len=%d cap=%d %v\\n\u0026quot;, s, len(x), cap(x), x) }   Note:\n  세미콜론 없음 기본 타입: bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // uint8의 별칭 rune // int32의 별칭 // 유니코드에서 code point를 의미합니다. float32 float64 complex64 complex128   초기값: zero value 는 다음과 같습니다. 숫자 type에는 0 boolean type에는 false string에는 \u0026quot;\u0026quot; (빈 문자열) 추가: slice 기본값은 nil slice ~~(넥 슬라이스!)~~ 포인터 기본값도 nil 포인터 \u0026lt;nil\u0026gt;   타입 변환 var i int = 42 var f float64 = float64(i) var u uint = uint(f) // 혹은 좀 더 간단히: i := 42 f := float64(i) u := uint(f)   반복문은 for 밖에 없음.  () 괄호 없고, {} 필수!    질문 리스트  이해가 100퍼센트 안됨. Numeric Constants Numeric constants are high-precision values. An untyped constant takes the type needed by its context. Try printing needInt(Big) too. (An int can store at maximum a 64-bit integer, and sometimes less.) 숫자형 상수 숫자형 상수는 매우 정확한 값 입니다. type이 정해지지 않은 상수는 그것의 문맥에서 필요한 type을 취합니다. needInt(Big) 을 출력해보세요. (int 는 최대 64-bit 혹은 때때로 더 작은 정수를 저장할 수 있습니다.)   클로저 좀더 해야됨  퀴즈  array 와 slice 차이는? range 문법을 map 에 적용하면? 아래 상황에서는 어떻게 될까?  var sum = 0 func adder() func(int) int { var sum = 0 return func(x int) int { sum += x return sum } } func main() { pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println( pos(i), neg(-2*i), ) } }  ","date":"2021-07-15T13:19:21+09:00","permalink":"https://wadro.github.io/memo/cs/go/lab-golang-study-tutorials/","tags":["golang","go"],"title":"lab golang study tutorials"},{"categories":["likelion"],"contents":"아이디어톤 PPT ideathon ideathon(remote control version)\n","date":"2021-05-16T17:11:49+09:00","permalink":"https://wadro.github.io/slide/likelion/likelion-week1/","tags":["ideathon"],"title":"likelion week1"},{"categories":["hugo"],"contents":"Introduction One morning, when Gregor Samsa woke from troubled dreams, he found himself transformed in his bed into a horrible vermin.\nMy Heading He lay on his armour-like back, and if he lifted his head a little he could see his brown belly, slightly domed and divided by arches into stiff sections. The bedding was hardly able to cover it and seemed ready to slide off any moment.\nMy Subheading A collection of textile samples lay spread out on the table - Samsa was a travelling salesman - and above it there hung a picture that he had recently cut out of an illustrated magazine and housed in a nice, gilded frame. It showed a lady fitted out with a fur hat and fur boa who sat upright, raising a heavy fur muff that covered the whole of her lower arm towards the viewer. Gregor then turned to look out the window at the dull weather. Drops\nhead6 heading1 heading2 anc1 head3 head4 head5 head6 heading2  Level 1 folder  Level 2 file Level 2 folder  Level 3 file Level 3 folder  Level 4 file   Level 3 folder  Level 4 file Level 4 file   Level 3 file   Level 2 folder  Level 3 file Level 3 file Level 3 file   Level 2 file   Level 1 file  \r   Syntax Description     Header Title   Paragraph Text     Selling point one Selling point two Selling point three  \r  The Sun is the star at the center of the Solar System. It is a nearly perfect sphere of hot plasma, with internal convective motion that generates a magnetic field via a dynamo process. It is by far the most important source of energy for life on Earth. Credits.\n  ","date":"2021-04-28T07:00:19+09:00","permalink":"https://wadro.github.io/post/heading/","tags":["hugo shortcuts"],"title":"Heading"},{"categories":["블로그"],"contents":"hugo 블로그 만들기 (windows \u0026amp; cupper theme 기준)    choco install hugo -confirm (powershell 관리자로 실행 후)\n  hugo new site (블로그 파일 모아 놓을 폴더 이름) e.g. hugo new site blog\n  cd (블로그 파일 모아 놓을 폴더 이름) e.g. cd blog\n  git init\n이 부분은 각자 쓰고 싶은 테마를 찾아볼것.여기서 -\u0026gt; git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke\n  hugo new posts/(쓰고싶은이름).md\n  터미널(powershell)에 hugo 엔터 누르면 markdown 으로 작성된 파일이 알아서 html,css,js 파일로 변환됨.\n  hugo server 로 테스트 가능.\n  이후 각자 편한 방식으로 업로드 e.g. 아이디.github.io repository 로 업로드하면 홈페이지 완성!\n  config.toml 은 중요하기때문에 따로 포스팅 하도록 하겠음.\n  ","date":"2021-04-28T05:56:50+09:00","permalink":"https://wadro.github.io/post/hugo/hugo-tutorials/","tags":["hugo","tips"],"title":"Hugo Tutorials"},{"categories":null,"contents":"Hi! I\u0026rsquo;m studying Information Commucation, Electronics \u0026amp; Computer Science\nDetails   Information Technology\n 📌 Blockchain 📌 Operating System 📌 Network 📌 Electronics    Social Science\n 📌 Economics 📌 Accounting 📌 IPRs(Intellectual Property Rights) 📌 Philosophies(Western)    news/media/press\n newstof - http://www.newstof.com/ lemonde - https://www.ilemonde.com/ 데이터 저널리즘    languages\n korean english japanese (basic) franch (want to learn) (constructed language)    etc (interests)\n watching masterpiece(books, movies, animation) music (piano) water sports(swimming, skin\u0026amp;scuba diving) martial arts(boxing) comics    want to learn\n harmonica, drum, ukulele tackyeon, jujitsu biology mechanics mechatronics    ","date":"2021-04-28T05:52:11+09:00","permalink":"https://wadro.github.io/about/","tags":null,"title":"About"}]