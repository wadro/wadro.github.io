[{"categories":[""],"contents":"용어 정리 (참고링크)  가산금리 (spread) = 기준금리에 신용도 등 조건이 붙여진 금리\n➜ 관련개념: 16. 기준금리 경기동향지수 = 경기동향지수는 경기종합지수와는 달리 경기변동의 진폭이나 속도는 측정하지 않고 변화방향만을 파악하는 것으로서 경기의 국면 및 전환점을 식별하기 위한 지표로서 경기확산지수(diffusion index)라고도 함. 경상수지 = (간단하게)수출-수입 / 경제적으로 항상 있는 일로 발생한 수지타산   Note\u0026gt; ref3\n▶ 순수출 : 재화와 서비스의 수출과 수입의 차\n▶ 경상수지 : 상품수지 및 서비스 수지, 소득 수지, 경상이전 수지를 합한 것 위의 정의에서 알 수 있듯이, 경상수지 항목에서 상품수지와 서비스수지를 합한 것이 바로 순수출입니다(상품수지는 본래 재화수지라 부르는 것이 더 정확한 표현이나 현재 한국은행 국제수지표에서는 상품수지란 용어를 사용하고 있습니다). 그런데 경상수지에는 상품수지와 서비스수지 이외에도 소득수지와 경상이전수지가 있습니다. 따라서 순수출은 경상수지에 포함되는 한 부분이라고 보면 됩니다.\n 고용률 = 만 15세 이상 인구 중 취업자가 차지하는 비율 고정금리 = 최초 약정한 금리가 만기때까지 그대로 유지되는 금리 고통지수 = 소비자물가상승률과 실업률을 더한 값 골디락스경제 = 이상적인 경제상황 / 경기과열에 따른 인플레이션과 경기침체에 따른 실업을 염려할 필요가 없는 최적 상태에 있는 건실한 경제 공공재 = 모든 개인이 공동으로 이용할 수 있는 재화 또는 서비스 공급탄력성 = 가격변화에 대한 공급의 민감도를 측정하는 척도 공매도 = 없는 것을 판다 / 투자자가 주식을 보유하지 않은 상태에서 주가 하락을 예상하고 금융기관으로부터 주식을 빌려 먼저 매도한 후, 주가가 하락하면 시장에서 주식을 매입하여 되갚은 후 차익을 얻는 투자 국가신용등급 = 국제신용평가사가 한 국가의 정부 채무 이행 능력과 의사 수준을 평가, 표시한 등급으로 국제금융시장에서 차입금리나 투자여건을 판단하는 기준\n➜ 관련개념: 31. 무디스 국채 = 정부가 다양한 목적의 재정자금을 조달하기 위해 발행하는 채권 금본위제 = 각국의 통화가치를 순금의 일정한 중량으로 정해 놓고 금화의 자유로운 주조와 수출입을 허용하며 이를 지폐나 예금통화 등과 교환할 수 있도록 하는 제도 금산분리 = 산업자본이 은행지분을 일정한도 이상 소유하지 못하도록 하는 것 기업공개 (IPO) = 기업공개(IPO; Initial Public Offering)란 넓은 의미로는 기업의 전반적 경영내용을 공개하는 것을 의미하며 좁은 의미로는 주식을 다수의 투자자들에게 분산 매각하는 것 기준금리 = 한 국가의 금리를 대표하는 정책금리 기축통화 = 현재기준(2021-08-30T14:12:01+09:00): 달러 / 여러 국가의 암묵적인 동의하에 국제거래에서 중심적인 역할을 하는 통화 기회비용 = 10원 8원 6원 있을때 10원 골랐으면 8원이 기회비용임 / 다양한 욕구의 대상들 가운데서 하나를 골랐을 때 포기해 버린 선택의 욕구들로부터 예상되는 유·무형의 이익 중 최선의 이익 낙수효과 = 정부가 경제정책으로 대기업과 고소득층 또는 부유층의 소득과 부를 먼저 늘려주게 되면 이들의 소비와 투자 증가를 통해 전체 경제활동이 활발해지면서 결국에는 중소기업과 저소득층도 혜택을 볼 수 있다는 주장 단기금융시장 = 금융기관, 기업 등 경제주체들이 단기적인 자금수급 불균형을 조절하기 위하여 통상 만기 1년 이내의 단기 금융상품을 거래하는 시장 대외의존도 = 개방경제체제 하의 국민경제에서 국외부문과의 거래가 차지하는 크기를 측정하는 지표   Note\u0026gt;\n개방경제체제: 국민경제가 가계, 기업, 정부 이외에 국외부문과의 상호작용에 의해서도 영향을 받게 되는 경제체제\n 대체제 = 커피는 차의 대체재, 콜라는 피자의 보완재 더블딥 = 경기침체 후 잠시 회복기를 보이다가 다시 침체에 빠지는 이중침체 현상 디커플링 = 한 국가의 경제가 인접한 국가 또는 전반적인 세계의 흐름과는 달리 독자적으로 움직이는 현상 디플레이션 = 인플레이션(inflation)의 반대 개념으로, 물가가 하락하는 현상 레버리지효과 = 타인이나 금융기관으로부터 차입한 자본을 가지고 투자를 하여 이익을 발생시키는 것. 빌린 돈을 지렛대(lever) 삼아 이익을 창출한다는 의미에서 지렛대 효과라고도 함. 만기수익률 = 만기가 될 때까지 채권을 보유할 경우 예상되는 총 수익률 마이크로 크레딧트 = 무담보 소액대출 (제도권 금융회사와 거래하기 힘든 저소득층 대상) 매몰비용 = 이미 지출해서 회수할 수 없는 비용 / 이미 실패한 또는 실패할 것으로 예상되는 일에 시간, 노력, 돈을 투자하는 것을 \u0026lsquo;매몰비용의 오류\u0026rsquo;라고 함. 명목금리 = 화폐 1단위를 일정 기간 동안 빌리는 대가로 지불한 화폐액으로서 이자를 원금으로 나눈 값으로 계산 / 명목 금리는 실질 금리와 인플레이션율의 합계로 결정 무디스 = 신용평가기관 / 전 세계 신용평가 시장의 40% 이상을 점유 물가지수 = 물가의 변동을 지수로 한 것 / 가격 정보만을 기초로하여 계산하는 것이 아니라, 상품 · 서비스의 양과 가격을 기초로 계산 뮤추얼펀드 = 주식회사 방식으로 운영되는 펀드, 회사형 펀드 / 보통의 펀드와 똑같은데, 이름만 좀 특이한 펀드 뱅크런 = 은행의 대규모 예금인출사태 / 은행 못 믿는 사람들이 많아지면 돈 다 빼가서 패닉 베블런효과 = 과시 욕구를 반영한 소비현상 / 가격이 상승하면 수요량이 감소하는 수요의 법칙에 반하는 재화를 베블런재 라고 하고, 사치재 또는 명품 등이 이에 해당하는데 이러한 재화는 가격이 비쌀수록 소비가 증가하는 경향이 있음. 변동금리 = 시장금리를 반영하여 일정 주기별로 약정금리가 변하는 금리를 의미하며 고정금리란 최초 약정한 금리가 만기때까지 그대로 유지되는 금리를 의미 보호무역주의 = 국가간 무역을 제한하는 경제정책 본원통화 = 통화는 일차적으로 중앙은행의 창구를 통하여 공급되는데, 이를 통화량의 원천이 되는 통화라 하여 본원통화(RB; Reserve Base)라고 함. 부가가치 = 일정 기간 동안에 경제활동주체가 생산활동에 참여하여 새로이 창출한 가치 부채담보부증권(CDO) = 남이 빚진것들을 모아서 상품으로 만들어서 팜. 남이 빚진걸 파는 놈이 사는 놈한테 돈 빌리는 거, 내가 사면 그 돈의 이자를 내가 받는 거 / 금융기관이 보유한 대출채권이나 회사채등을 한데 묶어 유동화시킨 신용파생상품 부채비율 = 부채를 자기자본으로 나눈 비율로 타인자본(부채)과 자기자본간의 관계를 나타내는 대표적인 안전성 지표 분수효과 = 정부가 경제정책으로 저소득층과 중산층의 소득을 먼저 늘려주면 이들의 소비 확대가 생산과 투자로 이어지면서 전체 경제활동이 되살아나고 이로 인해 고소득층의 소득도 늘어날 수 있다는 주장 (케인즈의 논리에 근거함)\n반대개념: 낙수효과 빅맥지수 = 각국 통화의 구매력 정도 또는 환율 수준을 측정하기 위해 일물일가의 법칙을 햄버거 가격에 적용한 것으로 영국에서 발행되는 주간 경제전문지 이코노미스트지(The Economist)에서 1986년 이래 매년 전 세계적으로 판매되고 있는 맥도날드의 빅맥가격을 비교·분석해서 발표하고 있음. 상장지수 펀드(ETF) = 주식, 채권, 통화, 원자재 등의 가격지수를 추종하는 것이 목표인 인덱스펀드의 지분을 거래소에 상장하여 일반주식처럼 거래토록 한 금융상품 서킷브레이커 = 과열된 전기회로를 차단하는 안전장치에서 유래된 용어로 주식시장에서 주가의 급등락 시 주식거래를 일시 정지시켜 시장에 미치는 충격을 완화하기 위해 도입된 제도 선물거래 = 오늘은 물건을 구입하기 위한 약속만 하고 물건과 돈의 교환은 나중에 하기로 하는 것. 미래 특정일에 미리 정한 가격으로 자산을 사거나 팔기로 한 계약으로, 거래소를 통해 체결되는 것 / 공인된 거래소에서 품질, 규격 등이 표준화된 상품의 매매계약을 체결하고 일정기간이 경과한 후에 상품의 인수도와 결제가 이루어지는 거래로서 매매계약의 성립과 동시에 상품의 인수도와 결제가 이루어지는 현물거래와 구분됨. 소득주도성장(Income-led growth) = 가계의 임금과 소득을 늘리면 소비도 늘어나 경제성장이 이루어진다는 이론(포스트케인지언 경제학자들의 임금주도성장(Wage-led Growth)에 근거)-일자리 정책이 동반되어야 함.\n➜ 비교개념: 분수효과 수요탄력성 = 상품의 가격 변화비율에 대한 수요량의 변화비율 / 수요의 가격탄력성은 각 요인들의 변화가 수요량이 얼마나 민감하게 반응하게 되는지를 나타낸 것. 만약 1%의 가격 상승이 3%의 수요 감소를 일으켰다면 3의 가격탄력성을 가지며, 이 때 가격탄력성이 1보다 크면 탄력적이라고 보고, 1보다 작으면 비탄력적. 스왑 = 나중에 좀더 공부해서 정리\u0026hellip; 스톡옵션 = 회사의 주식을 일정한 기간(행사기간) 내에 미리 정한 가액(행사가액)에 매수할 수 있는 권리 / 파생상품의 옵션과 같이 일정한 권리 조건이 충족되면 소유주가 권리를 행사할 수 있는 옵션 시뇨리지 = 주조차익, 화폐에 대한 독점적 발권력을 갖는 중앙은행이나 국가가 화폐발행을 통해 획득하는 이득 신용정책 신주인수권부사채(BW) 실질임금 애그플레이션 양도성예금증서 양적완화정책 어음관리계좌(CMA) 연방준비제도(FRS)/연방준비은행(FRB) 엥겔의법칙 역모기지론 예대율 옵션 외환보유액 워크아웃 원금리스크 유동성 이중통화채 자기자본비율 자발적실업 장단기금리차 장외시장 전환사채 정크본드 제로금리정책 주가수익률(PER) 주가지수 조세부담률 주당순이익(EPS) 중앙은행 증거금 지주회사 추심 치킨게임 카르텔 콜옵션 통화스왑 투자은행 특수목적기구(SPV) 파생금융상품 평가절하 표면금리 한계비용 헤지펀드 환율조작국 M\u0026amp;A  ","date":"2021-08-30T13:40:29+09:00","permalink":"https://wadro.github.io/post/eco-nomy/%EA%B2%BD%EC%A0%9C%EA%B0%9C%EB%85%90/","tags":[""],"title":"경제개념"},{"categories":[""],"contents":"강의링크 https://www.youtube.com/watch?v=NBTWIqusmCM\u0026amp;list=PLuQ0pAf6nnK93rHsEHsdkLLJnDwuQ4r3f\u0026amp;index=15\n강의 자료 링크 :\n회계원리+14강+엑셀자료(1) - 필기용(onedrive-excel)\nSummary  Here is summary.\n            Question1  what is concept1?  Question2 2. what is concept1?\n           concept1 - description - sub-description  concept2 - description - sub-description             arbit note 재고자산은 자신이 업으로 하는 것과 관련되어있으면 재고자산이고, 관련없는 부동산이나 다른 유형자산이면 재고자산이 아니다.\n매출채권은 자산이니 왼쪽(차변계정)이기때문에 왼쪽에 적으면 +, 오른쪽에 적으면 - .\n매출에누리의 경우, 개인적으로는 컴퓨터공학에서 처럼, 보다 명시적으로 한 계정을 더써서 서술하는것이 나중에 알아보기 쉬울듯.\n아닌가, 그냥 비고란이나 설명을 추가하는편이 나을지도\u0026hellip;\n국제회계기준에서도 송장가격(순매출액=총매출액(송장가격)-에누리-환입-할인)에서 실제로 발생된 매출할인을 차감하기때문에 총액법을 사용하는것을 권장함.\n","date":"2021-08-29T13:05:57+09:00","permalink":"https://wadro.github.io/note/accounting/principles/%EA%B0%95%EC%9D%98-%EB%A7%A4%EC%B6%9C%EC%B1%84%EA%B6%8C-%ED%9A%8C%EA%B3%84%EC%B2%98%EB%A6%AC%EC%9D%98-%EC%9D%B4%ED%95%B4-%EC%89%AC%EC%9A%B4%ED%9A%8C%EA%B3%84%EC%9B%90%EB%A6%AC-14%EA%B0%95/","tags":[""],"title":"[강의] 매출채권 회계처리의 이해 [쉬운회계원리 14강]"},{"categories":[""],"contents":"8월 넷째주(마지막주) 진행상황 프레젠테이션\n주요 진행 내용              질문   BPM 논문에서는 더 발전할 가능성이 있었다.\n이승화 님 논문에서는 어떻게 더 발전하는 방향이 있는가?\n이미 SIP에 DID 추가하는 걸로 된거 아닌가.\n하지만 SOLID 를 비롯한 다른 어플리케이션이나 프로토콜이 있다.\nSIP 등 기존 ID 체계? WebID? 기존 체계에서 Did로 변화를 줄수있는 부분은 계속 바뀌어 나갈것.\n그런 부분의 연장선에서 지금 쓰는 논문도 의미가 있을것.\nSOAP, ActivityPub, fediverse protocol\u0026hellip;\n  계획    ","date":"2021-08-24T17:10:51+09:00","permalink":"https://wadro.github.io/slide/graduate/dcc/%EC%A7%84%ED%96%89%EC%83%81%ED%99%A9-2021-aug-27/","tags":[""],"title":"진행상황 2021 Aug 27"},{"categories":[""],"contents":"강의링크 https://www.youtube.com/watch?v=G5byHKvFx5U\u0026amp;list=PLuQ0pAf6nnK93rHsEHsdkLLJnDwuQ4r3f\u0026amp;index=13\n강의 자료 링크 :\n회계원리+13강+엑셀자료(1) - 필기용(onedrive-excel)\nSummary  Here is summary.\n            Question1  what is concept1?  Question2 2. what is concept1?\n           concept1 - description - sub-description  concept2 - description - sub-description             arbit note 현금및 현금성 자산\n즉시사용이 가능하며\n유동성이 높아 현금전환이 용이함.\n가치변동이 위험이 중요하지않은 자산\n현금으로 계측되는 가치\n유동성이 높다는건 취득일로부터 만기일이 3개월이내\n투자금융자산 : 단기 - 보고기간말로부터 1년이내\n취득한날 기준으로 현금으로 인정받느냐 안받느냐가 판단기준이됨.\n어음은 만기가 있음. 믿고 기다리기 때문에 신용증권.\n수표는 바로 지급.\n선일자수표도 기다려야되서 어음임.\n당좌차월은 단기차입금.\n3개월 미만 어음은 현금 아닌가?\n현금이 아니라 현금성 자산!\n","date":"2021-08-22T13:20:59+09:00","permalink":"https://wadro.github.io/note/accounting/principles/%EA%B0%95%EC%9D%98-%ED%98%84%EA%B8%88-%EB%B0%8F-%ED%98%84%EA%B8%88%EC%84%B1%EC%9E%90%EC%82%B0-%EC%89%AC%EC%9A%B4%ED%9A%8C%EA%B3%84%EC%9B%90%EB%A6%AC-13%EA%B0%95/","tags":[""],"title":"[강의] 현금 및 현금성자산 [쉬운회계원리 13강]"},{"categories":[""],"contents":"8월 셋째주 진행상황 프레젠테이션\n주요 진행 내용  SSI in Business Process management on Blockchain\n➜ 논문 개요 구상 필요 개념 학습  논문 리스트 중:   2.blockchain-accessControl\n𝛽. Distributed Attribute-Based Access Control System Using a Permissioned Blockchain\n➜ Hyperledger fabric에서 access control(PEP, PDP, PAP, PIP 개념) \n4.SSI-AccessControl\n𝛼. SSIBAC: Self-Sovereign Identity Based Access Control\n➜ SSI를 이용한 access control \n     질문  논문쓸때 통계툴 필요한지 물어보기 sas 등  계획   8월 둘째주까지\n bpm, rea, 개념 정리 논문 리스트 중 bpm 논문 1,2,3 읽기 (1-ㄱ,ㄴ,ㄷ)    8월 셋째주까지\n 1-ㅁ,ㅂ,ㄹ ; 2-ㄷ -\u0026gt; 4개 2-𝛽. Distributed Attribute-Based Access Control System\nUsing a Permissioned Blockchain 4-𝛼. SSIBAC: Self-Sovereign Identity Based Access Control    넷째주까지\n 1-ㅅ ; 2-ㄱ -\u0026gt; 2개 1-ㅁ,ㅂ,ㄹ ; -\u0026gt; 3개    9월 첫째주까지\n 2-ㄷ ; 1-ㅅ ; 2-ㄱ -\u0026gt; 3개    미팅 전까지 (9월 둘째주)\n 못한 부분 마무리(여유분)    기타 ( 3. IoT-accessControl )\n 나머지 (3-ㄱ,ㄴ ;) -\u0026gt; 2개    ","date":"2021-08-17T17:03:46+09:00","permalink":"https://wadro.github.io/slide/graduate/dcc/%EC%A7%84%ED%96%89%EC%83%81%ED%99%A9-2021-aug-19/","tags":[""],"title":"진행상황 2021 Aug 19"},{"categories":[""],"contents":" Note: 참고로 이전까지 진행했던 회계 강의 들을 다시 듣기엔 한차례 반복하는 기간이 길어지게 되므로 템포를 맞추기 위해 기존 진행하던 곳에서 이어서 진행.\n진행하다보면 저절로 머릿속에서 개념이 다시 잡힐것이라 가정하고 강의 리스트를 1회 반복 하는 것을 목표로 함.\n이 후에 복습으로 2회 반복을 진행할 예정.\n2021-08-15T14:04:44+09:00\n 강의링크 https://www.youtube.com/watch?v=G5byHKvFx5U\u0026amp;list=PLuQ0pAf6nnK93rHsEHsdkLLJnDwuQ4r3f\u0026amp;index=13\n## 아직 정리중: 맨아래 arbit note 참조 강의 자료 링크 :\n회계원리+12강+필기(onedrive-excel)\nSummary  Here is summary.\n            Question1  what is concept1?  Question2 2. what is concept1?\n           concept1 - description - sub-description  concept2 - description - sub-description             arbit note 상품매매회계처리 :\n기업의 영업활동은 3가지 구분 가능\n1.상품: 물건 사와서 판매\n2.제품: 물건 제조, 판매\n3.용역: 금융, 의료, 교육등의 서비스 제공\n이 중 간단한게 상품매매 회계를 예시로 공부!\n강의 목표는 매출과 매출원가의 구조 알아보기\n상품이기때문에 두가지 행위가 발생.\n사는것\n-\u0026gt;\n1.파는 사람에게 돈 주기\n2.물건 받아오기\n모아놨다가 외상으로 정산하기가 실제 업무에서 빈번히 일어나는 일.\n파는것\n-\u0026gt;\n1.돈 받기\n2.물건 건네주기\n각각 회계처리 필요함\n순액 법과 총액법이 존재함.\n거래 손익만 남고 수익 비용 사라지는것이 순액법\n예:\n200원에 사와서 300원에 팔았다,\n상품 처분 이익이라는 손익만 남았음.\n돈을 받는 행위가 \u0026ldquo;매출\u0026rdquo; -\u0026gt; 수익\n물건을 건내주는 행위가 \u0026ldquo;매출원가\u0026rdquo; -\u0026gt; 비용\n이 값들(수익, 비용)을 계산하면 손익이 뙇!\n이익 100원!\n상품 매매는 순액, 총액이 있지만, 총액법이 정석임.\n매출 대비 수익률을 보면 , 회사별로 비교가 가능함.\n즉, 올바른 경영성과를 알기 위해서는\n단순히 손익만 적는 것이 아닌,\n매출과 매출 원가를 기록하여\n볼륨도 알수 있고, 실제 순이익도 알수 있도록 하는 것이 중요함!\n매출 볼륨이 커야한다! 라고 할수도 있음.\n손실나도 쿠팡처럼 키우기.\n수익률이 좋은거지!\n하면 규모는 작아도 견실함을 보는 것.\n총액법의 매출 총이익은\n회계계정으로 존재하지않고 손익계산서에서만 표기되는 개념.\n결산시 알수 있음.\n영업용 자산이 아닐 경우는 경영상 성과를 나타내는 것이 아니기때문에 순액법의 표기가 권장됨.\n또다른 예시에서 매입은 10개를 샀더라도,\n판매한건 7개이기때문에\n수익 비용을 대응시키기위해\n매출원가는 판매된 것만 인식하고\n매입은 사온것 전부로 인식한다.\n상품매매 기록방법:\n1.계속 기록법\n2.실지재고조사법\n(근래에는 크게 필요없다고 함.)\n상품 매매가 실제에는 정말 수도 없이 많이 생김.\n계속 기록법은 거래마다 계속 그냥 기록 하는거임.\n실지재고조사법은 현금 거래만 기록해놓고,\n나중에 재고는 한번에 조사하는 거임.\n(결산시 수정분개를 통해 매출원가와 재고자산을 인식한다고 함.)\n","date":"2021-08-15T13:30:42+09:00","permalink":"https://wadro.github.io/note/accounting/principles/%EA%B0%95%EC%9D%98-%EC%83%81%ED%92%88%EB%A7%A4%EB%A7%A4%ED%9A%8C%EA%B3%84%EC%B2%98%EB%A6%AC%EC%9D%98-%EC%9D%B4%ED%95%B4-%EC%89%AC%EC%9A%B4%ED%9A%8C%EA%B3%84%EC%9B%90%EB%A6%AC-12%EA%B0%95/","tags":[""],"title":"[강의] 상품매매회계처리의 이해 [쉬운회계원리 12강]"},{"categories":[""],"contents":"정기 미팅 발표 계획   8월 둘째주까지\n bpm, rea, 개념 정리 논문 리스트 중 bpm 논문 1,2,3 읽기 (1-ㄱ,ㄴ,ㄷ)    8월 셋째주까지\n  2-ㄴ. Distributed Attribute-Based Access Control System Using a Permissioned Blockchain\n  4-ㄱ. SSIBAC: Self-Sovereign Identity Based Access Control\n  1-ㅁ,ㅂ,ㄹ ; 2-ㄷ -\u0026gt; 4개\n    넷째주까지\n 1-ㅅ ; 2-ㄱ -\u0026gt; 개    9월 첫째주까지\n  미팅 전까지 (9월 둘째주)\n 못한 부분 마무리(여유분)    기타 ( 3. IoT-accessControl )\n 나머지 (3-ㄱ,ㄴ ; ) -\u0026gt; 개    8월 둘째주 진행상황 프레젠테이션\n","date":"2021-08-08T17:40:42+09:00","permalink":"https://wadro.github.io/slide/graduate/dcc/%EC%A7%84%ED%96%89%EC%83%81%ED%99%A9-2021-aug-11/","tags":[""],"title":"진행상황 2021 Aug 11"},{"categories":["cs"],"contents":"변수 선언 기본적으로 rust 의 변수는 immutable 합니다. 즉, 변하지 않는 값이 되죠.\n(c 나 여러 언어에서 const 키워드를 사용하는 것과 같습니다. 기본 변수 타입이 const 인 셈이죠.)\n이걸 통해 안전성과 쉬운 병렬성을 달성할수가 있게됩니다.(왜 그런지는 배우면서 차차 알수 있겠죠. 저도 아직 모름\u0026hellip;)\n물론, 변하는 값으로 설정하는 방법도 있습니다.\n이제부터 왜 그렇게 설계했는지를 살펴봅시다.\n먼저 변수를 선언하고나면, 그 이름을 가진 변수의 값을 바꿀수 없습니다.\n한번 예시를 통해 살펴 볼게요.\nfn main() { let x = 5; println!(\u0026quot;The value of x is: {}\u0026quot;, x); x = 6; println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  cargo check (또는 cargo run)을 해보면, 에러메세지가 나올겁니다.\n앞으로는 물론, 아마도 평생(?!) 러스트 코드를 짜다보면 에러메세지를 만날텐데요,\n실망하지마세요. 이건 아직 우리의 코드가 원하는 동작을 하기 위해 준비가 필요하다는 의미에 불과합니다.\n보다 안전한 실행을 위해 꼼꼼히 체크하는 것입니다.\n에러메세지는 이렇게 나올텐데요,\ncannot assign twice to immutable variable x\n우리가 x 변수에 다른 값을 넣으려고 해서 그렇습니다.\n우리가 불변값으로 지정했던 값을 바꾸려고 할때 컴파일-타임 에러는 중요합니다.\n바로 이런 상황이 버그로 이어질수 있기 때문이죠.\n만약 우리 코드 중 일부가, 값이 절대 변하지 않을거야! 라는 가정 하에 실행되는데\n다른 코드가 그 값을 바꾸려고 한다면, 원래 예상했던 동작이 일어나지 않겠죠.\n이런 종류의 버그는 발생하고 나면 추적하기 어려울수도 있는게,\n값을 바꾸는 일이 정말 가끔씩만 일어나기 때문입니다.\n우리가 이 값은 절대 바뀌지 않을거야! 라고 한다면, 진짜 바뀌지 않습니다.\n러스트에서는 컴파일러가 이런 일들을 보장해줍니다.\n이게 뭘 의미하냐면,\n우리가 코드를 읽고, 쓸때,\n값이 언제 변할지를 신경쓰지 않아도 된다는 의미입니다.\n따라서 코드를 추론하기가 더 쉬워지는 것이죠.\n하지만 변하는 값도 아주 유용하죠.\n(사실 실제 하드웨어에서는 메모리가 수시로 바뀌니까요)\n변수가 불변하는게 기본이지만, mut 키워드를 쓰면 변하게 만들수도 있습니다.\n단지 변하게 하는것 외에도, mut 키워드는 마치 책갈피 처럼,\n내가 가리키는 지금 이 부분이 변할거야! 라는 의도를,\n코드를 읽는 독자에게 전달해 줄수도 있습니다.\n코드를 이렇게 바꿔볼까요?\nmutable.rs fn main() { let mut x = 5; println!(\u0026quot;The value of x is: {}\u0026quot;, x); x = 6; println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  결과는 이렇게 나오겠죠.\n$ cargo run Compiling variables v0.1.0 (file:///projects/variables) Finished dev [unoptimized + debuginfo] target(s) in 0.30s Running `target/debug/variables` The value of x is: 5 The value of x is: 6  mut 키워드를 쓰면 x가 들고 있던 값을 5 에서 6 으로 변하게 할수 있도록 해줍니다.\n몇몇 경우에서 우리는 굉장히 편리하다는 이유로,\n불변하는 값만 쓰기보다는,\n변하는 변수를 쓰는 유혹을 많이 받으실텐데요. (근데 변수 원래 뜻이 변할수 있는 수 아니야?)\n단지 버그를 방지하기 위해서뿐만 아니라,\n고려해야할 몇가지 트레이드 오프(일장일단, 절충안)가 있습니다.\n예를 들면 큰 데이터 구조를 사용하는 경우에는\n복사하고 다시 새로 할당된 인스턴스를 리턴 하기 보다,\n그 자리에서 바로 값을 바꿔버리는게 빠를수도 있습니다.\n작은 데이터 구조에서는,\n새로운 인스턴스를 만들고, 함수형 프로그래밍 스타일로 작성하는것이 더 생각를 이어가기에 쉬울수 있기때문에,\n조금 성능을 희생하더라도, 명확성을 얻을수 있다는 장점을 가져갈수 있습니다.\n변수와 상수의 차이 변수의 값을 바꿀수 없다는 개념은, \u0026ldquo;상수\u0026quot;에 대해서 다시 생각해보게 합니다.\n불변하는 변수와 같이, 상수도 어떤 이름에 할당된 변하지않는 값이지만,\n조금 다른 점들이 있습니다.\n가령, mut 키워드를 상수에는 적용할수 없습니다.\n그냥 상수는 항상 불변합니다.\n상수는 const 키워드로 선언할수 있습니다.\n그리고 반드시 타입을 지정해줘야합니다.\n타입에 대한 얘기는 다음 절에 나오니 우선 넘어갑시다.\n상수는 전역 변수든 어디 위치에서든 선언 될수 있습니다.\n코드의 많은 부분에서 알아야하는 값일 경우 유용합니다.\n마지막으로 다른 점은,\n상수로 선언하는 방식 외에,\n함수 호출의 결과나\n런타임시에 계산해야만 알수있는 값은 상수가 될수 없다는 점입니다.\n예를 볼까요.\nMAX_POINTS 라는 이름의 상수가 100,000 이라는 값을 가지고 있습니다.\n(러스트에서 상수 이름을 만들때는 전부 대문자를 사용하고 단어 사이에 언더스코어(_)를 사용합니다.)\n(숫자에 대한 가독성을 높히기 위해 사용되기도 합니다.)\n#![allow(unused)] fn main() { const MAX_POINTS: u32 = 100_000; }  상수는 프로그램이 실행되는 동안, 선언된 스코프 내에서 유효하기때문에,\n애플리케이션 영역에서, 프로그램의 여러 파트에서 알아야할 값들,\n게임 플레이어가 모아야하는 최대 점수라던가, 빛의 속도와 같은 경우에 유용합니다.\n의미있는 이름으로 하드코딩된 값은\n다른 메인테이너(코드 유지 보수하는 사람)에게 코드를 보여줄때 요긴하게 사용될수 있습니다.\n또한 나중에 하드코딩된 값을 바꿔야 할 경우에, 한 부분만 바꾸면 되는 이점을 제공합니다.\n쉐도잉 원래 선언했던 변수 이름으로 다시 설정 가능합니다.\n이럴때 러스트에서는 shadowed(가려졌다) 되었다고 말합니다.\n예시를 보면서 설명해볼까요.\nfn main() { let x = 5; let x = x + 1; let x = x * 2; println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  처음에 x 는 5 라는 값에 묶이죠.\n그리고 다시 let 키워드를 통해서 x에 1을 더한 6 이라는 값에 묶입니다.\n마지막으로 세번째 선언을 통해 그 값을 2배 하면서 다시 x에는 12 라는 값으로 묶입니다.\n쉐도잉(shadowing) 은 mut키워드로 선언된 변수와는 다른데요,\nlet 키워드를 사용하지않으면 재할당되지 않기 때문입니다.\nlet 키워드를 사용한 할당 뒤에는 그 값은 불변합니다.\n또 다른 mut와 shadowing 의 차이점이라면,\nlet키워드로 너무나 효과적으로 새로운 변수를 만들수 있기때문에,\n같은 이름을 사용한, 다른 타입의 변수를 만들수가 있습니다.\n예를 들어, 유저에게 공백문자를 넣어 텍스트 사이에 몇 개의 공백을 원하는지 보여달라는 프로그램이 있을때, 그 입력을 숫자로 저장하고 싶다고 생각해봅시다.\nlet spaces = \u0026quot; \u0026quot;; let spaces = spaces.len();  첫번째 변수는 문자열 타입이고, 두번째 변수는 숫자 타입입니다.\n쉐도잉을 사용하면, space_str, space_num 과 같이\n다른 이름을 사용하지 않아도 됩니다.\n하지만 mut 키워드를 사용해서 위와 같은 작업을 실행하면 에러가 납니다.\nlet mut spaces = \u0026quot; \u0026quot;; spaces = spaces.len();  $ cargo run Compiling variables v0.1.0 (file:///projects/variables) error[E0308]: mismatched types --\u0026gt; src/main.rs:3:14 | 3 | spaces = spaces.len(); | ^^^^^^^^^^^^ expected `\u0026amp;str`, found `usize` error: aborting due to previous error For more information about this error, try `rustc --explain E0308`. error: could not compile `variables` To learn more, run the command again with --verbose.  즉, mut키워드를 사용해도 타입은 바꿀수 없다는 겁니다.\n자, 이제는 타입에 대한 내용을 다뤄보겠습니다.\n데이터 타입 러스트에서 모든 변수는 특정한 타입을 가지고 있습니다.\n어떤 종류의 데이터가 지정되었는지 알려줌으로써,\n어떻게 그 데이터를 처리할지를 알려주는 것이죠.\n데이터 타입를 두가지로 나눠서 살펴보겠습니다:\n스칼라와 컴파운드\n러스트는 정적 타입 언어 라는 사실을 명심하세요.\n컴파일 타임에 모든 변수의 타입을 알고 있어야한다는 사실입니다.\n컴파일러는 보통 변수의 값과 어떻게 그것을 사용할것인지에 따라 어떤 타입인지를 유추할수 있습니다.\n많은 타입이 유추 가능할 경우에,\n예를 들면 parse를 사용하여 문자열 타입에서 숫자형 타입으로 바꾸는 경우,\n타입 어노테이션(힌트,설명)을 추가해야합니다:\nlet guess: u32 = \u0026quot;42\u0026quot;.parse().expect(\u0026quot;Not a number!\u0026quot;);  2021-08-04T14:28:27+09:00 2021-08-05T13:11:53+09:00\n만약 타입 어노테이션을 추가하지 않으면 에러가 납니다.\n어떤 타입을 사용할것인지 우리에게 물어보는 것이죠.\n$ cargo build Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations) error[E0282]: type annotations needed --\u0026gt; src/main.rs:2:9 | 2 | let guess = \u0026quot;42\u0026quot;.parse().expect(\u0026quot;Not a number!\u0026quot;); | ^^^^^ consider giving `guess` a type error: aborting due to previous error For more information about this error, try `rustc --explain E0282`. error: could not compile `no_type_annotations` To learn more, run the command again with --verbose.  다른 데이터 타입들에 대한 어노테이션을 볼까요.\n스칼라 타입 스칼라 타입은 단일 값을 나타냅니다.\n러스트는 네 가지 기초 스칼라 타입이 있습니다.\nintegers, floating-point numbers, booleans, characters.\n아마 다른 프로그래밍 언어에서 많이 접했을 개념입니다.\n하나씩 살펴보죠.\ninteger 타입 integer 는 소수점이 없는 숫자 입니다.\ni32 는 signed integer, u32 는 unsigned integer 입니다.\n32비트의 공간을 차지하고, 부호가 있느냐 없느냐의 차이입니다.\nTable 3-1: Integer Types in Rust\n   Length Signed Unsigned     8-bit i8 u8   16-bit i16 u16   32-bit i32 u32   64-bit i64 u64   128-bit i128 u128   arch isize usize    명시적인 크기를 가지고, 부호가 있거나 없거나 하는 식의 변형이 있습니다.\n부호가 있는 숫자는 two\u0026rsquo;s complement(2의 보수) 표기법으로 저장됩니다.\n부호가 있는 경우, \\( -(2^{n-1}) \\) 부터 \\( 2^{n-1}-1 \\) 이하(포함) 의 값을 저장할수 있습니다.\ni8의 경우는 -128~127 까지의 값을 저장하죠.\n부호가 없는 경우, 0부터 \\( 2^{n}-1 \\) 의 값을 저장합니다.\nu8이면 0 부터 255 까지요.\nisize ,usize 같은 ~size 의 타입은 사용하는 아키텍처에 따라 달라집니다.\n가령, 64비트 아키텍처라면 i64,u64가 되는 것이죠.\n정수 표현하는 방식은 아래 표에 나온 것과 같습니다.\n바이트 정수를 제외하고 모든 표기에는 접미사(suffix)를 허용합니다.\n57u8 이런 식으로요.\n그리고 언더스코어(_) 는 구분자로 사용가능합니다.\n1_000 이렇게 말이죠.\nTable 3-2: Integer Literals in Rust\n   Number literals Example     Decimal 98_222   Hex 0xff   Octal 0o77   Binary 0b1111_0000   Byte (u8 only) b\u0026rsquo;A'    어떤 타입을 사용할지 모르겠다고요?\n그렇다면 디폴트 타입인 i32 가 일반적으로 좋은 선택일겁니다.\n(제일 빠릅니다(심지어 64비트 시스템에서도))\n일종의 컬렉션을 인덱싱할때 주로 isize 나 usize를 사용합니다.\n(나중에 이 부분은 다시 살펴 보도록 합시다.)\n  Integer Overflow 0에서 255까지 저장할수 있는 u8 타입의 변수를 사용한다고 해볼까요.\n만약, 이 범위 밖의 값, 예를 들면 256을 저장하려고 한다면,\ninteger overflow 가 발생합니다.\n러스트에는 이것과 관련된 흥미로운 규칙이 있습니다.\n디버그 모드에서 컴파일 할때, 러스트는 integer overflow 를 체크합니다.\n만약 런타임에 일어나게 된다면 프로그램이 패닉 에 빠지게 될수 있으니까 말이죠.\n러스트는 프로그램이 에러로 종료되면 패닉에 빠졌다는 표현을 사용하는데,\n챕터 9에서 이 부분을 좀더 다뤄보도록 하겠습니다.\n--release 플래그를 붙여서 릴리즈 모드로 컴파일하게 되면,\ninteger overflow 를 체크하지 않습니다.\n대신, 오버플로우가 일어나면, two\u0026rsquo;s complement wrapping 을 실행합니다.\n간단히 말해서, 변수가 담을수 있는 최댓값보다 큰 값은, 최솟값으로 \u0026ldquo;감싸집니다(wrapping)\u0026rdquo;.\nu8의 경우, 256은 0이 디고, 257은 1이 되는 식입니다. (0 1 \u0026hellip; 255 0 1 \u0026hellip;)\n프로그램은 패닉에 빠지지않지만, 원래 예상했던 동작을 하지 않을수도 있습니다.\n랩핑에 의존하는것은 에러로 간주됩니다.\n명시적으로 오버플로우 가능성을 처리하기 위해,\n표준 라이브러리가 기본 숫자 타입에 제공하는 메소드 모음을 사용할수 있습니다.\n ◼ wrapping_add처럼, 모든 모드에서 랩핑하는 wrapping_* ◼ 오버플로우가 있으면 None 값을 반환하는 checked_* ◼ 값과 오버플로우 여부를 알려주는 boolean 을 반환하는 overflowing_* ◼ 값의 최소와 최대값으로 고정되는 (포화) saturating_*    floating-point 타입 러스트는 부동소수점 숫자를 위한 두가지 기본 타입이 있습니다.\nf32와 f64 인데, 각각 32비트와 64비트의 사이즈를 가지고 있습니다.\n현대 cpu의 대부분이 64비트를 채용하고 있고, 속도는 비슷한데 더 정밀하기 때문입니다.\n예제를 보면서 설명해보죠.\nfn main() { let x = 2.0; // f64 let y: f32 = 3.0; // f32 }  부동소수점 숫자는 IEEE-754 표준에 따라 표기 됩니다.\nf32 타입은 단일-정밀도 이고, f64 더블-정밀도 입니다.\n(이 부분 용어 설명은 나중에 포스팅하기로 할게요.)\nNumeric Operations 러스트는 간단한 숫자 연산을 지원합니다.\n덧셈, 뺄셈, 곱셈, 나눗셈, 모듈러(나머지) 연산 등이죠.\nfn main() { // addition let sum = 5 + 10; // subtraction let difference = 95.5 - 4.3; // multiplication let product = 4 * 30; // division let quotient = 56.7 / 32.2; // remainder let remainder = 43 % 5; }  위의 예시에서 각 연산의 결과값은 변수에 바인딩(묶임)됩니다.\nAppendix B 에서 모든 연산의 종류를 확인할수 있습니다.\nBoolean type 대부분의 프로그래밍 언어에서 다루는, true, false 값을 가지는 불리언 타입입니다.\nBoolean 타입은 1바이트의 사이즈를 가집니다.\nfn main() { let t = true; let f: bool = false; // with explicit type annotation }  주로 if문에서 사용하죠.\n이후에 control flow 챕터에서 다뤄보도록 합시다.\ncharacter type 지금까지는 숫자에 대해서만 다뤘지만, 러스트는 문자도 지원합니다.\nchar 타입은 문자열 타입과는 다르게 '' 단따옴표를 사용하여 표기합니다.\nfn main() { let c = 'z'; let z = 'ℤ'; let heart_eyed_cat = '😻'; }  char타입은 4 바이트이며, 유니코드 값을 나타낼수 있습니다.\nASCII 말고도 수많은 표현이 가능하다는 얘기입니다.\n강조 문자, 중국어, 일본어, 한국어, 이모지, 공백문자 까지 모두 가능합니다.\n유니코드는 U+0000 부터 U+D7FF, 그리고 U+E000 부터 U+10FFFF 까지(포함) 가능합니다.\n일반적으로 \u0026lsquo;character\u0026rsquo;라고 하면 유니코드랑은 좀 개념이 맞지않아서 직관적으로 다소 이해되지 않을수 있습니다.\n이러한 부분은 storing UTF-8 Encoded text with strings에서 좀더 살펴보겠습니다.\nCompound Types 컴파운드 타입은 여러개의 값을 하나의 타입으로 묶을수 있습니다.\n러스트는 두개의 기본 컴파운드 타입이 있습니다:\ntuples 와 arrays 입니다.\nTuple type 튜플은 여러개의 다양한 타입을 가진 값들을 하나로 묶는 일반적인 방법입니다.\n튜플은 고정 길이를 가집니다:\n즉, 한번 선언되면 늘어나거나 줄어들지 않습니다.\n괄호안에 쉼표로 구분하는 리스트를 만들어서 튜플을 생성할수 있습니다.\n각 위치는 타입을 가질수 있으며, 타입이 꼭 전부 같을 필요는 없습니다.\n아래 예제에서는 타입 어노테이션(선택 가능: 해도 되고 안해도 됨)을 붙여봤습니다.\nmain.rs fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); }  tup 이라는 변수는 전체 튜플을 잡아둡니다.\n튜플은 전체가 하나의 요소로 취급되기 때문입니다.\n튜플로부터 각각의 값을 가져오려면, 패턴 매칭을 사용하여 아래와 같이 튜플 값을 분해할수 있습니다.\nfn main(){ let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026quot;The value of y is: {}\u0026quot;, y); }  이 프로그램은 먼저 튜플을 만들고 tup이라는 변수에 묶습니다.\nlet키워드와 함께 패턴을 사용해서 tup 변수를 받아서 3개의 분리된 값으로 바꿉니다.\n이것을 destructuring(해체) 이라고 부릅니다.\n하나의 튜플을 세 부분으로 나누기 때문이죠.\n마지막으로 프로그램은 y의 값인 6.4를 프린트하게 됩니다.\n패턴 매칭으로 해체하는 방식 외에도,\n마침표(.)를 이용하여 바로 튜플 요소에 접근할수 있습니다.\n 튜플.{순서}\n 예제를 한번 봅시다.\nfn main() { let tup2: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = tup2.0; let six_point_four = tup2.1; let one = tup2.2; }  먼저 tup2라는 변수를 만들고, 튜플의 인덱스(순서)를 고려하여 새로운 변수에 넣었습니다.\n대부분의 프로그래밍 언어가 그렇듯, 인덱스는 0 부터 시작합니다.\nArray 타입 또 다른 방식으로, array 를 이용하면 여러 값의 집합을 만들수 있습니다.\ntuple 과는 다르게 array의 모든 요소는 같은 타입을 가져야 합니다.\n다른 프로그래밍 언어들과는 다르게 러스트의 array는 고정된 길이만을 갖습니다.\n대괄호[] 안에 쉼표로 구분하여 적습니다.\nfn main() { let a = [1, 2, 3, 4, 5]; }  어레이는 힙 보다는 스택에 데이터를 지정하고 싶을때 유용합니다.\n(스택과 힙에 대해서는 챕터 4에서 좀더 알아보도록 합시다.)\n또는 항상 고정된 갯수의 요소를 가질것이라고 확신할수 있을때 사용합니다.\n어레이는 벡터 타입 만큼 유연하지 않습니다.\n벡터는 표준 라이브러리를 통해 제공되는 집합(collection) 타입이고, 사이즈가 늘어나거나 줄어드는 것이 가능합니다!\n만약 어레이를 쓸지 벡터를 쓸지 확실하지 않다면 벡터를 사용하게 될겁니다.\n(챕터 8 에서 벡터에 대해 좀더 알아보도록 합시다.)\n프로그램에서 벡터 대신 어레이를 쓰게될 상황에 대한 예로는,\n월별 이름을 알아야 할때가 있습니다.\n새로운 달이 추가되거나 사라질 일이 왠만해서는 없기때문에,\n어레이를 사용할수 있습니다. 항상 12개의 요소를 가질 것이기 때문이죠.\nlet months = [\u0026quot;January\u0026quot;, \u0026quot;February\u0026quot;, \u0026quot;March\u0026quot;, \u0026quot;April\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;June\u0026quot;, \u0026quot;July\u0026quot;, \u0026quot;August\u0026quot;, \u0026quot;September\u0026quot;, \u0026quot;October\u0026quot;, \u0026quot;November\u0026quot;, \u0026quot;December\u0026quot;];  아래 처럼 어레이의 타입을 적는 경우,\n대괄호안에 요소의 타입을 적고, 세미콜론을 붙인 다음,\n그 옆에 어레이의 사이즈를 적어주면 됩니다.\nlet a: [i32; 5] = [1, 2, 3, 4, 5];  여기에서 i32는 각 원소들의 타입이고 5는 어레이가 5개의 원소를 포함한다는 의미입니다.\n동일한 원소로 어레이를 만들려면 타입 대신 해당 원소를 적어주면 됩니다.\nlet a = [3; 5];  이렇게 하면 3이 5개 들어있는 어레이가 생성됩니다.\n어레이 원소 접근 어레이는 스택에서 하나의 메모리 덩어리로 지정됩니다.\n어레이의 원소는 아래 처럼 인덱스로 접근할수 있습니다:\nfn main() { let a = [1, 2, 3, 4, 5]; let first = a[0]; // 1 let second = a[1]; // 2 }  참고: 어레이의 인덱스도 0부터 시작합니다.\n잘못된 어레이 원소 접근 만약 맨 마지막 원소를 지나서 접근을 하려고 한다면 어떻게 될까요?\n(챕터 2를 하고 온 다음에 다시 보기)\n(사용자 입력을 받아서, 어레이의 해당 인덱스의 원소를 출력하는 프로그램)\nthread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace  이러한 결과는 런타임 에러로, 잘못된 인덱스를 가리켰을때 나타납니다.\n프로그램은 마지막 프린트문을 출력하지 못한채로 종료됩니다.\n이런식으로 사용자가 어떤 값을 입력할지 모르는 경우, 컴파일러가 컴파일 전에 체크할수가 없기때문에 런타임 에러가 발생할수가 있습니다.\n바로 이것이 현실에서 일어날수 있는\n러스트의 안전 원칙 중 첫번째 예입니다.\n많은 저레벨 언어들에서 이런 종류의 체크는 수행되지 않고,\n잘못된 인덱스를 넣으면 잘못된 메모리 주소에 접근할수가 있습니다.\n러스트에서는 이러한 종류의 에러를 미연에 방지하는 방법으로 프로그램을 바로 종료시키게 됩니다.\n챕터 9에서 러스트의 에러 핸들링을 좀더 알아보기로 합시다.\nFunctions 러스트 코드에는 함수가 널리 퍼져있습니다(?).\n그 중에서도 가장 중요한 함수를 이미 우리는 알고 있죠: 많은 언어에서 엔트리 포인트(시작점) 으로 사용되는 main 함수입니다.\n새로운 함수를 선언하는 fn키워드도 한번 본적이 있습니다.\n러스트 코드는 함수나 변수 이름을 만들때 관습적으로 snake case 를 사용합니다.\nsnake case 에서는 모든 문자가 소문자이고, 언더스코어(_)로 단어들을 구별합니다.\n예시를 봅시다:\nfn main() { println!(\u0026quot;Hello, world!\u0026quot;); another_function(); } fn another_function() { println!(\u0026quot;Another function.\u0026quot;); }  러스트에서 함수를 선언할때는 fn 키워드로 시작하고,\n함수 이름 뒤에 괄호를 붙입니다.\n중괄호는 컴파일러에게 함수 바디(body)의 시작과 끝을 알려줍니다.\n함수 이름을 쓰고 뒤에 괄호를 붙이면 우리가 정의한 어떤 함수든 호출할수 있습니다.\n노트:\n유의할점은, 소스코드에서는 main함수 뒤에 another_function을 정의하였지만, 앞에서 정의해도 상관없습니다.\n어딘가에만 정의되어 있으면 됩니다.\n함수를 실행해보면 다음과 같은 결과가 나옵니다:\n$ cargo run Compiling functions v0.1.0 (file:///projects/functions) Finished dev [unoptimized + debuginfo] target(s) in 0.28s Running `target/debug/functions` Hello, world! Another function.  main 함수 내에서 호출된 순서대로, Hello, world! 다음에 Another function. 이 차례로 호출되는것을 확인할 수 있습니다.\nFunction Parameters 함수의 시그니처(함수의 구성요소) 중 하나로서,\n특별한 변수로 사용되는 \u0026ldquo;parameter\u0026rdquo; 를 가지도록 함수를 정의할 수도 있습니다.\n함수가 parameter 를 가지고 있을때, 구체적인 값을 가지도록 할수도 있습니다.\n기술적으로는, 구제척인 값을 \u0026ldquo;argument\u0026rdquo; 라고 하지만(함수에서 정의된 변수가 아닌 구체적인 값: example ➜ funcion1(2) ➜ 여기서 2를 말함),\n일상 대화에서 우리가 parameter 와 argument를 사용할때는 딱히 구분없이 말하기도 합니다.\n다음 예를 보면서 설명해볼까요.\nfn main() { another_function(5); } fn another_function(x: i32) { println!(\u0026quot;The Value of x is: {}\u0026quot;,x); }  실행해보면 아래와 같이 나올겁니다.\n$ cargo run Compiling functions v0.1.0 (file:///projects/functions) Finished dev [unoptimized + debuginfo] target(s) in 1.21s Running `target/debug/functions` The value of x is: 5  another_function 함수를 선언할때, 파라미터는 x 하나이고 타입은 i32입니다.\n5라는 값이 함수로 들어가면, println!이라는 매크로가 형식 문자열(format string) 내에서 중괄호가 있는 위치에 5를 넣습니다.\n함수 시그니처(구성요소)에서, 파라미터의 타입은 반드시 지정해줘야 합니다.\n이런 특징은 러스트 언어를 디자인할때 의도적으로 고려된 결정입니다:\n함수 정의할때 미리 타입을 선언한다는 것은,\n컴파일러가 어떤 의미로 코드를 짰는지 알기위해\n해당 변수를 사용한 곳들을 찾아갈 필요가 거의 전혀 없다는 의미입니다.\n함수가 여러개의 파라미터를 갖기를 원한다면,\n쉼표로 파라미터를 구분하여 선언하면 됩니다. 이렇게요:\nfn main() { another_function(5, 6); } fn another_function(x: i32, y: i32) { println!(\u0026quot;The value of x is : {}\u0026quot;, x); println!(\u0026quot;The value of y is : {}\u0026quot;, y); }  이 예제는 두개의 파라미터를 갖는 함수를 만들었습니다. 같은 i32타입을 가지고 있네요.\n그리고선 두개 파라미터가 가지는 값을 바로 출력합니다.\n당연한 얘기지만, 모든 파라미터가 같은 타입을 가져야만 할 이유는 1도~~(하나도)~~ 없습니다.\n그냥 예제가 그럴뿐이죠.\n예제를 실행하면 아래처럼 나올겁니다.\n$ cargo run Compiling functions v0.1.0 (file:///projects/functions) Finished dev [unoptimized + debuginfo] target(s) in 0.31s Running `target/debug/functions` The value of x is: 5 The value of y is: 6  익히 예상할수 있는것처럼\n차례로 5와 6을 넣었기 때문에,\n출력되는 문자열도 똑같은 순서로 나오는 것을 확인할수 있습니다.\nFunction Bodies Contain Statements and Expressions 함수 본문은 선택적으로는 표현식으로 끝나는, 일련의 문장으로 구성됩니다.\n지금까지는 종료 표현식이 없는 함수만 다루었지만, 표현식은 명령문의 일부로 보았습니다.\n러스트는 표현식 기반 언어이기 때문에, 이런 내용은 꼭 이해해야할 중요한 차이점 입니다.\n다른 언어에는 이러한 구분이 없기때문에, 명령문장과 표현식이 무엇이고,\n그 차이가 함수 본문에 어떤 영향을 미치는지 한번 살펴보겠습니다.\n우리는 사실 이미 명령식과 표현식을 사용했습니다.\n명령식(statement) 은 값을 리턴하지않으면서 어떤 행위를 수행하는 지시문입니다.\n표현식(Expressions) 은 결과값을 도출합니다.\n예제를 통해 살펴봅시다.\n변수를 만들고 let키워드로 값을 할당하는 이런 형태는 Statement(명령식) 입니다.\n아래 예제 코드에서 let y = 6; 이 문장이 명령식입니다.\nfn main() { let y = 6; }  Listing 3-1: A main function declaration containing one statement\n함수 정의 또한 Statement 입니다.\n앞서 나온 전체 예제는 그 자체로 statement 입니다.\nStatements 는 값을 리턴하지 않습니다.\n따라서 let statement 를 다른 변수에 다시 할당할수 없습니다.\n다음 예제를 실행하면 에러가 발생합니다.\nfn main() { let x = (let y = 6); }  실제로 프로그램을 실행하면 다음과 같은 에러가 나올겁니다.\n$ cargo run Compiling functions v0.1.0 (file:///projects/functions) error[E0658]: `let` expressions in this position are experimental --\u0026gt; src/main.rs:2:14 | 2 | let x = (let y = 6); | ^^^^^^^^^ | = note: see issue #53667 \u0026lt;https://github.com/rust-lang/rust/issues/53667\u0026gt; for more information = help: you can write `matches!(\u0026lt;expr\u0026gt;, \u0026lt;pattern\u0026gt;)` instead of `let \u0026lt;pattern\u0026gt; = \u0026lt;expr\u0026gt;` error: expected expression, found statement (`let`) --\u0026gt; src/main.rs:2:14 | 2 | let x = (let y = 6); | ^^^^^^^^^ | = note: variable declaration using `let` is a statement warning: unnecessary parentheses around assigned value --\u0026gt; src/main.rs:2:13 | 2 | let x = (let y = 6); | ^^^^^^^^^^^ help: remove these parentheses | = note: `#[warn(unused_parens)]` on by default error: aborting due to 2 previous errors; 1 warning emitted For more information about this error, try `rustc --explain E0658`. error: could not compile `functions` To learn more, run the command again with --verbose.  let y = 6 statement 는 값을 반환하지 않다보니, x에 묶어놓을 값이 없습니다.\n이런 특징이, 할당을 하면 할당된 값을 반환하는 다른 언어(C,Ruby 등)들과 다른 점입니다.\n만약 x = y = 6 이런식으로 쓰면 x 와 y는 모두 6이라는 값을 가집니다.\n러스트에서는 이런 경우가 없습니다.\nExpressions 는 어떤 값을 도출해내고, 러스트에서 작성할 코드의 나머지 대부분을 차지합니다.\n간단한 수학 연산을 생각해볼까요.\n5+6이라는 표현식에서 결과는 11이 나옵니다.\n표현식(expressions)은 선언식(statement) 의 일부가 될수 있습니다:\n위 예제 3-1 의 let y=6에서 6은 6이라는 값으로 도출되는 표현식입니다.\n함수를 호출하는 것도 표현식입니다.\n매크로를 호출하는 것도 표현식입니다.\n새로운 스코프를 만들때 사용하는 블록,{},도 표현식입니다.\n예를 들면 이렇습니다.\nfn main() { let x = 5; let y = { let x = 3; x + 1 }; println!(\u0026quot;The value of y is : {}\u0026quot;, y); }  아래 표현식을 보세요:\n{ let x = 3; x + 1 }  이 블록은 4라는 결과로 나타납니다.\n이 값은 y에 묶이게 되고(bound to) let문장의 일부분입니다.\n여기서 주의할점은 x+1 에는 세미콜론; 이 마지막에 없습니다.\n지금까지 본적없는 형태이죠.\nexpressions(표현식)은 마지막 세미콜론을 포함하지 않습니다.\n마지막에 세미콜론을 찍으면, 그 문장은 statement(선언식)으로 바뀌게 되고, 값을 반환하지 않게 됩니다.\n이것을 명심하시고, 다음부터 배울 함수 값반환과 표현식으로 넘어가보도록 합시다.\nFunctions with Return Values 함수는 자신을 부른 코드에 값을 반환할수 있습니다.\n반환하는 값의 이름을 붙이진않지만, 타입은 지정할수 있습니다.\n화살표(-\u0026gt;) 뒤에 붙입니다.\n러스트에서, 반환값은 함수 본문의 블록에서 가장 마지막 표현식의 값과 같습니다.\n값을 지정해서 return 키워드로 먼저 끝내버릴수도 있지만, 대부분의 함수는 암시적으로 마지막 표현식을 반환합니다.\n아래는 값을 반환하는 함수의 예입니다.\nfn five() -\u0026gt; i32 { 5 } fn main() { let x = five(); println!(\u0026quot;The value of x is : {}\u0026quot;, x); }  여기에 있는 five함수안에는 함수 호출도 없고, 매크로도, 심지어 let statement도 없습니다 — 그냥 숫자 5가 들어있을 뿐이죠.\n러스트에서는 완벽하게 유효한 함수입니다.\n함수의 반환 타입도 명시되어 있다는 것에 주목하세요. (-\u0026gt; 32)\n위 코드를 실행하면 아래와 같이 나올겁니다.\n$ cargo run Compiling functions v0.1.0 (file:///projects/functions) Finished dev [unoptimized + debuginfo] target(s) in 0.30s Running `target/debug/functions` The value of x is: 5  five함수의 5는 함수의 반환 값이고, 리턴 타입이 i32인 이유입니다.\n좀더 자세히 살펴봅시다.\n두가지 중요한 부분이 있습니다.\n첫번째로, let x = five(); 이 줄에서 변수를 초기화하기 위해서 함수의 반환값을 이용하였습니다.\nfive함수가 5를 반환했기때문에, 아래와 같은 줄이 됩니다.\nlet x = 5;  두번째로, five함수는 파라미터가 없고, 반환 타입만 정의하였습니다.\n함수 본문에는 외로이 5가 있을뿐이고, 세미콜론;도 없습니다.\n선언식이 아닌 표현식이기 때문이며, 반환하고 싶은 값이기 때문입니다.\n다른 예제를 살펴보죠.\nfn main() { let x = plus_one(5); println!(\u0026quot;The value of x is: {}\u0026quot;, x); } fn plus_one(x: i32) -\u0026gt; i32 { x + 1 }  위 코드를 실행하면 The value of x is: 6 이 나올겁니다.\n하지만 x+1이 있는 이 줄에 세미콜론을 추가한다면, statement로 바뀌면서 에러가 나게 됩니다.\nfn main() { let x = plus_one(5); println!(\u0026quot;The value of x is: {}\u0026quot;, x); } fn plus_one(x: i32) -\u0026gt; i32 { x + 1; }  이 코드를 컴파일 하면 아래처럼 에러가 나올 겁니다.\n$ cargo run Compiling functions v0.1.0 (file:///projects/functions) error[E0308]: mismatched types --\u0026gt; src/main.rs:7:24 | 7 | fn plus_one(x: i32) -\u0026gt; i32 { | -------- ^^^ expected `i32`, found `()` | | | implicitly returns `()` as its body has no tail or `return` expression 8 | x + 1; | - help: consider removing this semicolon error: aborting due to previous error For more information about this error, try `rustc --explain E0308`. error: could not compile `functions` To learn more, run the command again with --verbose.  주요 에러 메세지는 \u0026ldquo;타입 미스매치(타입이 잘못 매칭되었음)\u0026rdquo; 입니다.\nplus_one 함수의 정의를 보면, i32타입을 반환한다고 되어있습니다.\n하지만 statement선언식은 값으로 도출되지않고 비어있는 튜플()로 표현될 뿐입니다.\n그러므로, 아무것도 반환되지 않으며, 함수 정의에 위배되므로, 에러가 발생하게 됩니다.\n이 결과에서 러스트는 문제를 수정하는데 도움이 될수 있는 메세지를 제공합니다:\n세미콜론을 제거하면 문제를 해결할수 있을거라고\u0026hellip;\nComments 모든 프로그래머들은 자신의 코드를 이해하기 쉽게 만들기 위해 노력하지만, 때때로 추가적인 설명이 필요합니다.\n이런 경우에 노트를 남기거나, 코멘트 를 남깁니다:\n컴파일러는 소스코드의 코멘트를 무시하지만 코드를 읽는 사람들에게는 매우 유용할수 있습니다.\n간단한 코멘트를 볼까요.\n// hello, world  러스트에서는 관용적으로 두개의 슬래쉬// 로 코멘트를 시작하고 그 줄의 끝까지를 주석으로 간주합니다.\n여러줄에 주석을 적으려면 이렇게 합니다:\n// So we’re doing something complicated here, long enough that we need // multiple lines of comments to do it! Whew! Hopefully, this comment will // explain what’s going on.  각 줄에 두개의 술래쉬//를 적으면 됩니다.\n주석은 코드를 포함한 줄에도 사용 가능합니다.\nfn main() { let lucky_number = 7; // I’m feeling lucky today }  하지만 아래와 같이\n설명하려는 코드 윗줄에 주석을 적는 것이 보통입니다.\nfn main() { // I’m feeling lucky today let lucky_number = 7; }  러스트에는 documentation comments 라는 다른 종류의 주석도 있는데,\n이 내용은 챕터 14의 \u0026ldquo;Publishing a Crate to Crates.io\u0026rdquo; 섹션에서 더 다뤄보도록 하겠습니다.\nControl Flow 어떤 조건하에서 실행 할지 말지 결정하는것과, 어떤ㄷ 조건하에서 어떤 코드를 반복 실행하는 것은,\n대부분의 프로그래밍 언어에서 기본적인 빌딩 블록 입니다(로직,논리를 쌓아나가는 기본 단위).\n러스트에서 흐름을 제어할수 있게 도와주는 가장 일반적인 구조는 if문과 루프 입니다.\nif Expressions if문은 조건에 따라서 코드를 분기할수 있도록 도와줍니다.\n조건을 적은 다음, \u0026ldquo;이 조건에는 이 코드블록을 실행하고, 맞지 않으면 이 코드 블록을 실행해줘\u0026rdquo; 라고 적으면 됩니다.\nbranches 라는 새로운 프로젝트를 만든 다음(cargo new branches), if문을 체험해봅시다.\nfn main() { let number = 3; if number \u0026lt; 5 { println!(\u0026quot;condition was true\u0026quot;); } else { println!(\u0026quot;condition was false\u0026quot;); } }  condition was true  모든 if문은 if키워드로 시작합니다.\n그리고 그 뒤에 조건을 붙입니다.\n위 경우에서는, number변수가 5보다 작은지 작지않은지 체크합니다.\n조건이 충족되었을때 실행하고 싶은 코드블록은 조건을 적은 바로 다음에 중괄호{} 안에 적습니다.\nif 컨디션에 따라 실행되는, 관련된 코드 블록을 때로는 arms(팔) 이라고 불리기도 하는데,\n챕터 2의 “Comparing the Guess to the Secret Number” section 에서 다루었던 match 표현식에서 나온 arm 과 같은 개념입니다.\n추가적으로, else키워드도 사용할수 있는데,\n프로그램의 조건이 충족되지않았을 경우, 대안을 주기 위해 선택할수 있습니다.\n만약 else 키워드를 적지않았다면, 조건이 충족되지않았을때\n그냥 if블록을 건너뛰고 다음 코드를 실행하게 됩니다.\n만약 number의 값이 조건에 맞지 않는 값이라면 어떨까요?\nlet number = 7;  이번에는 결과가 이렇게 나오겠죠.\n$ cargo run Compiling branches v0.1.0 (file:///projects/branches) Finished dev [unoptimized + debuginfo] target(s) in 0.31s Running `target/debug/branches` condition was false  그리고 조건문은 반드시 bool타입이어야 한다는 것을 명심하세요.\n만약 조건이 bool이 아니라면 에러가 발생합니다.\n다음과 같은 코드가 그 예입니다.\nfn main() { let number = 3; if number { println!(\u0026quot;number was three\u0026quot;); } }  if조건이 3이 되었고, 에러가 발생합니다.\n$ cargo run Compiling branches v0.1.0 (file:///projects/branches) error[E0308]: mismatched types --\u0026gt; src/main.rs:4:8 | 4 | if number { | ^^^^^^ expected `bool`, found integer error: aborting due to previous error For more information about this error, try `rustc --explain E0308`. error: could not compile `branches` To learn more, run the command again with --verbose.  러스트는 bool 타입을 기대했지만 integer 타입이 들어왔기 때문에 에러가 발생했습니다.\n루비와 자바스크립트와는 달리, 러스트는 자동으로 non-boolean 타입을 boolean 으로 바꾸지 않습니다.\n항상 명시적으로 코드를 작성해야하며, if문에는 불리언(true or false)타입을 조건으로 넣어야합니다.\n예를 들어, 숫자가 0이 아닐때만 if코드 블록을 실행하려면 다음과 같이 if문을 바꿔볼수 있을겁니다.\nfn main() { let number = 3; if number != 0 { println!(\u0026quot;number was something other than zero\u0026quot;); } }  위 코드를 실행하면 결과가 이렇게 나오겠죠: number was something other than zero .\nHandling Multiple Conditions with else if if와 else 를 결합하여 else if 문을 사용하면 여러 조건을 사용할수 있습니다.\nfn main() { let number = 6; if number % 4 == 0 { println!(\u0026quot;number is divisible by 4\u0026quot;); } else if number % 3 == 0 { println!(\u0026quot;number is divisible by 3\u0026quot;); } else if number % 2 == 0 { println!(\u0026quot;number is divisible by 2\u0026quot;); } else { println!(\u0026quot;number is not divisible by 4, 3, or 2\u0026quot;); } }  이 프로그램은 4가지 가능한 경우가 존재합니다.\n결과는 다음과 같이 나올겁니다:\n$ cargo run Compiling branches v0.1.0 (file:///projects/branches) Finished dev [unoptimized + debuginfo] target(s) in 0.31s Running `target/debug/branches` number is divisible by 3  프로그램이 실행되면, 각각의 if조건을 차례대로 보면서\n가장 처음으로 조건을 충족하는 코드블록을 실행하게 됩니다.\n주의할점은 6은 2로 나눠지지만, number is divisible by 2라는 결과는 물론,\nelse블록의 number is not divisible by 4,3, or 2 역시도 확인할수 없습니다.\n러스트는 가장 처음으로 조건을 만족한 블록만 실행하기 때문입니다.\n조건을 만족한 블록을 일단 찾으면, 나머지는 체크하지 않습니다.\nelse if표현식을 너무 많이 쓰면 코드가 복잡해질수 있기 때문에,\n하나 이상의 조건을 써야하는 경우에는 코드를 리팩토링(refactor-최적화,수정)할 필요를 느낄수 있습니다.\n이러한 경우를 위해, 챕터 6에서 match 라는 러스트의 강력한 분기 구조를 다룹니다.\nUsing if in a let Statement Repetition with Loops Repeating Code with loop Returning Values from Loops Conditional Loops with while Summary ","date":"2021-08-02T14:19:54+09:00","permalink":"https://wadro.github.io/post/cs/rustlang/rust-book/chapter-3.-common-programming-concepts/","tags":["rust","러스트 튜토리얼"],"title":"Chapter 3  Common Programming Concepts"},{"categories":["cs"],"contents":"착한 반말 컨셉 Rust 튜토리얼  먼저 WSL2 설치 가이드 링크 설치 후 기초 예제 링크  terminal\n$ mkdir ~/projects $ cd ~/projects $ mkdir hello_world $ cd hello_world  hello_world.rs fn main() { println!(\u0026quot;Hello, world!\u0026quot;); }  output $ rustc main.rs $ ./main Hello, world!  cargo 버젼 체크 $ cargo --version  새로운 프로젝트 생성 $ cargo new hello_cargo $ cd hello_cargo  cargo.toml 파일 구성 [package] name = \u0026quot;hello_cargo\u0026quot; version = \u0026quot;0.1.0\u0026quot; authors = [\u0026quot;Your Name \u0026lt;you@example.com\u0026gt;\u0026quot;] edition = \u0026quot;2018\u0026quot; [dependencies]   note: edition key in Appendix E. -\u0026gt; 여기서 toml 파일 설정에 대해 좀더 알아볼 예정.\n  dependencies 는 rust 에서 crates 라는 이름으로 불림. (packages of code are referred to as crates) The top-level project directory is just for README files, license information, configuration files, and anything else not related to your code. 가장 탑레벨의 프로젝트 디렉토리에는 README 파일, 라이센스 정보, 설정 파일 등이 들어가.  이제 프로젝트 폴더에서 \u0026lt;폴더이름\u0026gt;/hello_cargo cargo build 를 하면 이렇게 나올거야.\n$ cargo build Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo) Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs  실행 할때는 폴더명이 좀 다른데, 현재 폴더에서 target/debug/ 아래에 실행 파일이 있을거야.\n$ ./target/debug/hello_cargo # or .\\target\\debug\\hello_cargo.exe on Windows Hello, world!  cargo build 후에 실행 파일을 실행하는 방법도 있지만, cargo run 으로 한번에 실행하는 방식도 있어.\n$ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs Running `target/debug/hello_cargo` Hello, world!  cargo check 라는 커맨드는 컴파일도 하지않고 그냥 코드가 제대로 잘 작성되었는지 체크하는 커맨드야. 언제 쓰냐고? 보통 cargo build 보다 cargo check 가 훨씬 빠르기 때문에, 중간 중간 체크하기 위해서 사용될수 있어. 실행할 준비가 되었다고 생각하면 cargo build 를 통해 컴파일해보고 실행하면 돼!\ncargo 를 사용하면서 부터는 어떤 운영체제든 상관없이 일관된 커맨드를 사용하기때문에 헷갈릴 일도 없지.\nRelease 할때는 cargo build --release 커맨드를 사용해. target/debug 대신 target/release 폴더에 파일을 생성하지. 컴파일은 느리게 되지만 빠른 실행이 될수 있도록 도와줘.\n이미 존재하는 프로젝트를 카피해서 빌드해보고 싶다면, 아래 커맨드를 입력하면돼.\n$ git clone example.org/someproject $ cd someproject $ cargo build  주의 챕터 2로 넘어가기 전에, 좀더 기초를 쌓고 프로젝트를 해보고 싶은 사람들(나를 포함)은 챕터 3를 먼저 하는걸 추천할게.\nChapter 3 다음 페이지에서 계속\u0026hellip;\n","date":"2021-08-02T12:05:34+09:00","permalink":"https://wadro.github.io/post/cs/rustlang/rust-book/hello-world-and-cargo/","tags":["rust","러스트 튜토리얼"],"title":"Hello, world! and Cargo"},{"categories":[""],"contents":"블록체인, 비트코인 뉴스체크 - NBA 탑샷, 플로우, NFT 최근 뉴스   가상화폐 거래소 셧다운 위기 거론\n 특금법 9월 24일 시행 시중은행의 실명계좌와 연동해야 가상화폐 거래소 이용가능 은행 제휴한 4대 거래소 제외, 중소 거래소는 셧다운 예상 투자금액이 만만치않은 여파 국민의 힘이 법안 시행, 3개월 유예 조명희 발의 줄폐업 위험, 상당 규모의 이용자 피해를 고려해 한시적 연장, 피해 최소화, 법 적용 기간을 확보할 필요가 있음을 언급    업권법\n 업권이란 영업이나 사업의 범위, 업권법이란 영업이나 사업을 할수 있게 법으로 제정 가상자산 세계에도 필요하다. 더불어민주당의 가상자산 tf 제도개선    2021 세법 개정안\n 국세청, 세금 체납자, 가상자산 압류, 거래소에서 바로 매각가능하도록 체납자에 압류된 것도 시장 자산으로 매각? 개인의 전자지갑에 있으면 압류 불복 경우가 많아서 징수가 어려움 한계점을 보완해서 가상자산에 탈세하려는 악의적 체납자를 위해 규정 보완 기대감    긍정적 전망\n 블룸버그 전략가, 인텔리전스 소속 시니어 상품 소속 마이클 맥킬런? 금, 미국 국채, 비트코인이 상승폭 전망, 강세장 진입을 위한 조정을 받고 있다. 하반기 큰 상승 폭 전망 분석\u0026hellip; 스위스 3대 은행 ceo, 고객들이 암호화폐 관심 가지고 있다. 블룸버그 티비에서 암호화폐 관심 고객은 특정 어플리케이션이 아닌, 암호화폐 기반 기술이 더 중요하다고 생각함 중앙화된 상대없이 신뢰창출가능한 유일한 기술이다라고 블록체인 기술을 긍정적으로 평가함.    데이터 분석업체 센티먼트 트위터\n 고래 주소, 폭락장 5월에서 비트코인을 매집중, 지난 5주간 13만 비트코인 매집, 지난 10일동안 4만 비트 이상 매집, 상승 반등 폭이 클수 있다.    골드만삭스, sec\n 호재, 블록체인, defi etf 신청 온라인 증권거래 플랫폼, 로빈후드, 암호화폐 변동성 투자자 보호를 위해 노력 기능 활성화 전에 주문 금액보다 적은 금액을 유도\u0026hellip; 플랫폼안에서 보완하겠다고 언급    IMF 공식적인 부정적 언급\n 국가 통화화폐로 하지말라. 광범위한 채택이 거시경제적으로 불안정성을 높힌다 상당한 자원 투입, 가격 변동을 야기할것. (신경쓸일이 많아진다\u0026hellip;) 범죄, 사기, 기반 기술은 매우 강력하지만 기술적 결함이 발견될수 있다 경제 안정성에 위협을 가져올수 있다.(?)    미국의 상원의원 제닉 엘런 공식 서한\n 주재 관련 촉구 DeFi 스테이블 코인 규제 탈중앙화 금융, 스테이블 코인 규제해야한다. 규제 시스템 없으면 심각한 위험 초래 가능 재무건전성 악화 가능성 암호화폐 어떤 이점이 있나? 금융 안전 감시 위원회는 권력을 이용해서 암호화폐 문제를 해결해야한다고 주장. 제닉 엘런 , 규제 촉구    거비르 구루알, sec 집행 국장으로 임명\n 가상화폐 산업에 강경한 태도 예상 크립토 시장 움직임을 어떻게 끌고 갈것인가    그밖의 글로벌 소식\n 인도의 대형은행, 핀테크, 분산원장 기술 상품개발을 위해 블록체인 기업 지분 인수 러시아 최대 이동통신사 MTS, 러시아 소재 무역 금융 플랫폼, 지분 51퍼센트 인수(블록체인 기업) 이탈리아 축구클럽 AS로마, 파트너쉽 3년, 선수관련 NFT 발행, 블록체인 사업 추진, 디지털 비트 로고 유니폼    플로우, NFT   개요\n 플로우란 데퍼랩스에서 만든 메인넷 2,3년 전에 nft 를 알린 크립토키티를 처음 제작한 회사 당시 nft 처음 알려지고 제작된 아이템들이 주목받음 당시 이더리움 위에서 돌렸을때 성능, 트랜젝션비용 한계를 느낌 만원 아이템을 전송하는데 2만원 들고\u0026hellip; 이런식 이더리움에서 dapp 으로 만드는게 지속가능하지않다. 그렇게 만든 플랫폼이 플로우    기술적 내용\n 메인넷 특징: 이더리움 극복하겠따! 스케일러빌리티관점에서 많은 케페시티를 가지도록 하는게 주요 어프로치 트랜젝션 비용이 싼 메인넷을 만들겠따고 선언한 메인넷 많은 경우에 레이어2 노드수를 줄이거나, 레이어 2솔루션 도입, 일반적 패턴, 플로우는 명시적으로 샤딩을 지지하지않는다. 레이어2 솔루션 X 스케일러빌리티의 솔루션이 될수 없다. 샤딩이 왜 안좋냐 본인들 관점에서는 이론적 tps 를 늘려주지만 눈속임일 뿐이다. 실제 어플리케이션 제작 관점에서는 tps 가 높아지는건 좋지만, 샤드간의 레이턴시, 지연이 발생하고 트랜잭션 실패 확률 커지고, 앱 제작 관점에서는 설계 리소스가 많이 들어가게됨. 신경쓸게 많아짐 간단한 크립트키티 에서 예를 들면, 샤딩 없는 체인에서는 블록하나 트랜잭션 하나, 샤딩 되어있는 메인넷에서는 파이널리티 보장하려면 트랜잭션이 12개, 7개 블록에 걸쳐 확정해야 보장 가능 샤딩 없는 메인넷을 지향한다고 언급 대안 네크워크 치고는 이론적 tps 가 높지않음. 상황에 따라 변동이 있지만, 100tps 정도가 목표 비트코인 보다는 20~30배 빠르고, 이더리움에 비해서는 6~10배 정도 어떻게 플로우는 빠른가 핵심 아이디어는 이더리움 기존 메인넷 분석, 노드들 간의 합의 과정 속에서 다양한 스텝이 있는데, 예를 들면 어떤 트랜젝션을 블록에 담고, 어떤 순서로 실행할건지, 결정된 트랜젝션 이후에, 결과에 대한 합의를 하는 단계 등등이 있음. 어떤 트랜젝션을 담을 것인가, 어떤 순서로 담을 것인가, 비결정적이라 노드별로 주관에 맞춰서 , ab 담고, bc 담는, 노드들 간 합의를 해야하는 스텝, 결정되면, 트랜젝션에 대한 합의는 어떤 노드가 해도 같은 결과, 전자와 후자를 모두 기다리지않고 트랜젝션에 대한 합의만 먼저하고, 실제 실행 결과에 대한 합의는 기다리는 시간을 줄이는 방법? 조금 모호함 기존의 하나의 노드에서 수행하던 역할을 ,네가지 롤로 나눠서 실행하면서 tps 높힐수 있었다.    사업쪽 이야기\n 첫 nft 스파크를 데퍼랩스에서 mba 탑샷 이라는 어플리케이션을 통해 만들어냄. nft디앱 사례 mba 탑샷? 보통 mba 농구는 카드 수집 매니아 층이 있음. 비싼 카드는 물리적인 카드가 몇억?! 덩크 장면이나 멋진 장면을 동영상 파일을 nft 파일로 소장 가능하도록 한게 nft 탑샷, 잘한것이 기술에만 포커스 두기 보단, 장면에 대한 라이센스를 획득하고, 흥행에 초점을 잘 맞춘 전략이 좋았다는 평가 사업적으로 빠르게 실행함. nft 사긴 했지만 플로우 메인넷이 연동 되지않았는데도 기대감만으로 nft 카드를 유저들이 받아들임 수백만 사람들이 들어와서, 판매된 금액에 맞춰서 대기타서 가격 구매, 가격 상승 작년부터 올해까지 nft 흐름 이어져옴    유의사항?\n 조심해야하는 부분은 올해 하반기 부터 앞으로 2~3년간 유통량이 엄청나게 풀린다는 점. 2019~말까지 커뮤니티 세일해서 0.1달러에 거래됨. 어제 가격기준으로 180배 이상 오름\u0026hellip; 벨류에이션 측면에서는 논란의 여지가 있음. 너무 많이 올라서 유통물량이 풀리면 버티지못할것이다 반대로 데퍼랩스에서 개척하는 시장이 커질거니까 이 에코시스템이 활성화 되면, 충분히 지탱 가능한 벨류에이션이다. 거품이다, 아니다 라는 두가지 관점. 후자의 시나리오에서 확인해야하는건 아직까지는 다른 게임회사에서 플로우 메인넷 기반으로 개발 하는 bsc, 솔라나도 아직 생태계 없음. cadence 라는 스마트 컨트랙트 언어도 생소함. 실제 현실에서 생태계가 만들어지는지를 모니터링 해야함 반대로 좀더 옹호하는 입장이라면 개발 환경이나 문서를 보면 다른 메인넷들에 비해 튜토리얼, 개발환경 들이 꽤 퀄리티 있게 나옴 양쪽 관점에서 균형 잡힌 시각이 필요함      쟁글 공시 체크해야함\n  블록워터 개발자 대화 다시 들어야함\n  샤딩은 블록체인 확장성 해결하기 위한 솔루션\n  빅데이터 저장 관리를 분산 한다\n  균등 분할\n  합의 노드를 분산해야 분산원장 정확성, 속도 활성화,\n  자체적인 특성\n  nft 시장의 확장성이 넓어질수 있다\n  mba 카드 , mlb 카드,\n  내가 좋아하는 캐릭터 상품 모으는, 이모티콘, 수집 욕구, 컬렉터 욕구\n  nft 발전 가능성\n  앨런, 아르고,\n  플로우가 생각하는 이더리움의 한계에 대해 공감\n  이더리움 gas fee\n  느린 처리속도\n  강력한 부의 생태계를 어떻게 할것인가?\n  토큰 시총이 커져봐야 이더리움이 너무 큼\n  (사견-개인 의견)윈도우랑 비슷한 듯.\n  결국 윈도우는 레거시 게임 앱들을 포용하면서 유저들을 많이 끌여들였다고 생각함.\n  사업적 측면에서 보면 이더리움을 무시할수는 없음\n  대안 네트워크가 기술적으로 뛰어나도\n  생태계를 복제하긴 힘듬.\n  솔리디티 조차 개발자 풀이 적은데 새로운건 더 더딤\n  메타버스\n  유저 풀 확보도 어려움\n  데퍼랩스가 한 영리한 정책은, 메인넷에 안 붙이고 흥행시킴\n  플로우 월렛 설치만 되면 다른 디앱 개발사들에게 메인넷 생태계를 위해 뭔가 만들려는 인센티브? 그런 기대감?\n  샤딩 관련 이슈는,\n  이더리움 2.0 에서 퍼포먼스를 좋게 만드는 양대 축\n  PoS, 샤딩,\n  플로우에서 100tps 가 현실적이다 라는 게 진짜 현실\n  이더리움 2.0 에서 빨라지고 싸진다는게 아직 메인넷이 실제 돌아가는게 아니기때문에\n  과한 기대일수도 있다는 관점\n  더 빨라진다고 해도 어플리케이션 개발자들에게 개발 난이도를 높히면서\n  더 적은 어플리케이션을 만들게 할수도 있고,\n  보안도 취약해질수 있는,\n  전체적으로 구조가 복잡해 지는것 아닌가? 하는 우려\n  결국 어느 플랫폼이든 trade-off 가 존재함.\n마지막 스피커 발언  개국 60주년 아카이브 by MBC 역사적 순간을 nft 로 만들어 발행 정말 싸게 발행함 60개 밖에 발행 안됨. nft 수집에 관심이 있으면 archive by mbc 컬러티비 송출, 개국\u0026hellip; 대한민국 역사와도 관련\u0026hellip; mbc 창고에 있던것을 디지털 복원해서 올라오는 것들, 필름, 아날로그에 관심이 있으면 소장용으로 그냥 재미삼아\u0026hellip;  검증된 데이터가 예술적으로 거래 가능한 시장이 열림\nnft 전시, 이런게 예쑬인가? 피카소, 앤디 워홀, 미술관에 많이 나옴\n","date":"2021-07-28T09:49:39+09:00","permalink":"https://wadro.github.io/note/blockchain-talk/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EB%89%B4%EC%8A%A4-2021-jul-28/","tags":[""],"title":"블록체인뉴스 2021 Jul 28"},{"categories":["cs"],"contents":"본 글은 doc.rust-lang-org 의 튜토리얼 내용을 정리한 글입니다. rust lang 특징  Rust programming language is fundamentally about empowerment “systems-level” without taking on the customary risk of crashes or security holes, and without having to learn the fine points of a fickle toolchain. the language is designed to guide you naturally towards reliable code that is efficient in terms of speed and memory usage. introducing parallelism in Rust is a relatively low-risk operation: the compiler will catch the classical mistakes for you Rust isn’t limited to low-level systems programming - CLI apps, web servers, and many other kinds of code  rust lang 사용처  Rust is proving to be a productive tool for collaborating among large teams of developers with varying levels of systems programming knowledge. - the compiler plays a gatekeeper role by refusing to compile code with these elusive bugs, including concurrency bugs  rust lang 목차  Hello, world! small toy code (project1) comparison with other languages (챕터 3 이후에 챕터 2로 돌아오는걸 권장 - 디테일하게 적용가능) ownership에 대해서 method enums, if,match, custom types module system for privacy, make API vectors, strings, hash maps error-handling generics, traits, lifetimes testing own implementation (project2) closure, iterators - came from functional programming cargo in more depth, sharing libraries with others smart pointers, traits different models of concurrent programming, multiple threads fearlessly rust idioms vs oop principles ref on patterns and pattern matching smorgasbord(뷔페?), unsafe-rust, macros, more about lifetimes,traits,functions,closures low-level multithreaded web server (project3)  Rustaceans  a silly nickname we call ourselves  진행상황  https://doc.rust-lang.org/book/ch01-03-hello-cargo.html cargo.toml 부터 다시  ","date":"2021-07-26T13:55:43+09:00","permalink":"https://wadro.github.io/post/cs/rustlang/rust-book/introduction-to-rust/","tags":["rust","러스트 튜토리얼"],"title":"Introduction to Rust"},{"categories":["graduate"],"contents":"읽은 논문 리스트  Caterpillar: A business process execution engine on the Ethereum Blockchain  새롭게 알게된 개념  bpmn - business process management notation bpmn 개념  그 외 진행 내용   golang - basic syntax, method, pointer, closure, etc - (스터디 내용 정리)\n  황용환 님과 대화\n  블록체인 플랫폼 조사 -\u0026gt; 솔라나, 아이오타, 홀로체인\n 조건1: DID method 가능한가 조건2: Smart Contract 가능한가    제6회 기업설명회(롯데정보통신,블록체인랩스,코인플러그) - 이노베이션 아카데미(42seoul)\n  https://www.youtube.com/watch?v=D8F0njjr9Mg 2021-07-26T11:43:56+09:00\n  보고 싶은 논문  Addressing Distributed Ledger Transaction Processing Limitations for the Internet-of-Things - IEEE Engineering Management Review -\u0026gt; IOTA 관련 논문 Thinking Out of the Blocks: Holochain for Distributed Security in IoT Healthcare - IEEE INTERNET OF THINGS JOURNAL -\u0026gt; Holochain 관련 논문  추후 진행 예정  golang 은 튜토리얼 까지만 진행 rust 언어 학습 (매일 1시 화면 공유로 진행)  현재 까지의 진행 상황은 slack 을 통해 기록됨    기타 참고 자료  토큰 경제와 블록체인의 미래 - 이슈 리포트 읽기(BPM 관련 한국어 글) Caterpillar: A Blockchain-Based Business Process Management System  노트   bpm, REA 체크 해야함\n  홀로체인 bpm, rea 체크해야함, token? fuel? did 체크 해야함\n  golang channel 까지 체크 완료\n  rust tutorial 시작 - cargo.toml 까지 체크 완료\n  REA and BPM keywords 2021-07-27T17:38:28+09:00 rea agent resource event flow lane \u0026ldquo;pool\u0026rdquo; business process management value\n곰이 사자에게 쿠키를 판다.\n곰 - 내부 에이전트 사자 - 외부 에이전트\n쿠키 - 리소스 (인벤토리)\n쿠키를 팔다(sale) - 이벤트\n돈을 받다(cash receipt) - 이벤트\n돈을 은행에 넣는다 - 이벤트 여기서 돈도 리소스에 속한다?! 엄밀히 말하면 사자가 곰에게 준것은 영수증이고 실제로 영수증 이벤트는 돈이라는 리소스와 연결된다?!\n쿠키\n돈\n 리소스\n참고 자료 2021-07-28T10:55:41+09:00\n about holochain  https://developer.holochain.org/concepts/8_calls_capabilities/   paper about holochain in IoT  https://arxiv.org/pdf/2103.01322    https://arxiv.org/abs/2103.01322\n","date":"2021-07-25T21:03:02+09:00","permalink":"https://wadro.github.io/slide/graduate/dcc/%EC%A7%84%ED%96%89%EC%83%81%ED%99%A9-2021-jul-25/","tags":["dcc"],"title":"진행상황 2021 Jul 25"},{"categories":["Computer Engineering"],"contents":"Go tutorials  📔📝본 내용은 tour.golang.org 에 있는 내용을 정리한 글입니다.  Hello, Go world! 3 codeblocks goroutines.go package main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func say(s string) { for i := 0; i \u0026lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(\u0026quot;goroutine0\u0026quot;) say(\u0026quot;main0\u0026quot;) // 순차 실행끼리는 순서 맞춰서 실행됨 say(\u0026quot;main1\u0026quot;) // goroutine 끼리는 독립적으로 비동기식으로 처리됨 () go say(\u0026quot;goroutine2\u0026quot;) // 나중에 나오는 순차 실행과 함께 실행됨 go say(\u0026quot;goroutine1\u0026quot;) // 여기서는 say(\u0026quot;main2\u0026quot;) say(\u0026quot;main2\u0026quot;) }  output main0 goroutine0 goroutine0 main0 main0 goroutine0 goroutine0 main0 main0 goroutine0 main1 main1 main1 main1 main1 goroutine1 main2 goroutine2 main2 goroutine1 goroutine2 goroutine1 main2 goroutine2 main2 goroutine1 goroutine2 goroutine1 main2  channels.go package main import \u0026quot;fmt\u0026quot; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u0026lt;- sum // send sum to c } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := \u0026lt;-c, \u0026lt;-c // receive from c // 아마 스택 개념? fmt.Printf(\u0026quot;%T, %v \\n\u0026quot;,c,c) fmt.Println(x, y, x+y) }  output chan int, 0xc000100060 -5 17 12  channels-reverse.go func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[len(s)/2:], c) go sum(s[:len(s)/2], c) x, y:= \u0026lt;-c, \u0026lt;-c // receive from c // 아마 channel은 스택 개념? fmt.Printf(\u0026quot;%T, %v \\n\u0026quot;,c,c) fmt.Println(x, y, x+y) }  output-reverse chan int, 0xc000062060 17 -5 12  channel-test.go func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) for index, _ := range s { go sum(s[index:index+1],c) } for i := range c { fmt.Println(i) } }  output-test 2 7 8 4 -9 0 [7] [2] [8] [-9] [4] [0] 7 8 2 -9 0 4 0 -9 4 8 2 7 0 2 7 -9 8 4 fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.main() /tmp/sandbox710675921/prog.go:20 +0x193  channels-close-test-1.go package main import \u0026quot;fmt\u0026quot; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u0026lt;- sum // send sum to c } func closechan(c chan int, iter []int) { for index, _ := range iter { go sum(iter[index:index+1],c) // 여기가 다름!! } close(c) } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go closechan(c,s) for i := range c {\tfmt.Println(i) } /* go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := \u0026lt;-c, \u0026lt;-c // receive from c fmt.Println(x, y, x+y) */ }  output /// goroutine 쓰면 아무것도 안뜬다!? Program exited.  channels-close-test-1.go package main import \u0026quot;fmt\u0026quot; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u0026lt;- sum // send sum to c } func closechan(c chan int, iter []int) { for index, _ := range iter { sum(iter[index:index+1],c) // 여기가 다름!! } close(c) } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go closechan(c,s) for i := range c {\tfmt.Println(i) } /* go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := \u0026lt;-c, \u0026lt;-c // receive from c fmt.Println(x, y, x+y) */ }  output /// goroutine 안쓰면 뜬다!? 7 2 8 -9 4 0   느낀점: goroutine 을 쓰면, 다른 execution 이라고 보는게 맞을 것 같다.\n참고: close(c) 없애고, goroutine 없으면 7 2 8 -9 4 0\n있으면 0 8 7 2 -9 4\n아래는 공통적으로 나오는 경고문\nfatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.main() /tmp/sandbox232678665/prog.go:26 +0x14c   test.go /* both are possible! c := make(chan int) go closechan(c,s) c := make(chan int, 10) closechan(c,s) */ package main import \u0026quot;fmt\u0026quot; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u0026lt;- sum // send sum to c } func closechan(c chan int, iter []int) { for index, _ := range iter { sum(iter[index:index+1],c) // 여기가 다름!! } close(c) } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go closechan(c,s) for i := range c {\tfmt.Println(i) } /* go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := \u0026lt;-c, \u0026lt;-c // receive from c fmt.Println(x, y, x+y) */ }  buffered-channels.go package main import \u0026quot;fmt\u0026quot; func chanfunc(c chan int,integer int) { c \u0026lt;- integer } func main() { ch := make(chan int) go chanfunc(ch,1)\tgo chanfunc(ch,2) go chanfunc(ch,3) fmt.Println(\u0026lt;-ch) fmt.Println(\u0026lt;-ch) fmt.Println(\u0026lt;-ch) }  no-buffered-channels-block.go func main() { ch := make(chan int) go chanfunc(ch,1)\tchanfunc(ch,2)\tfmt.Println(\u0026lt;-ch) }  no-buffered-channels-block-output fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.chanfunc(...) /tmp/sandbox977088187/prog.go:5 main.main() /tmp/sandbox977088187/prog.go:12 +0x87 goroutine 20 [chan send]: main.chanfunc(0xc00009c060, 0x1) /tmp/sandbox977088187/prog.go:5 +0x3f created by main.main /tmp/sandbox977088187/prog.go:10 +0x65 /// goroutine 없을때 fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.chanfunc(...) /tmp/sandbox473627473/prog.go:5 main.main() /tmp/sandbox473627473/prog.go:11 +0x65 /// print 없을때 fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.chanfunc(...) /tmp/sandbox473783957/prog.go:5 main.main() /tmp/sandbox473783957/prog.go:11 +0x57  range-and-close.go package main import ( \u0026quot;fmt\u0026quot; ) func fibonacci(n int, c chan int) { x, y := 0, 1 for i := 0; i \u0026lt; n; i++ { c \u0026lt;- x x, y = y, x+y } close(c) } func main() { c := make(chan int, 10) go fibonacci(cap(c), c) // fibonacci(10, c) // capacity 주면 goroutine 안써도 값 들어감 // go fibonacci(11, c) // goroutine 쓰면 capacity 초과해도 값 들어감 for i := range c { fmt.Println(i,\u0026quot; (i)\u0026quot;) v, ok:= \u0026lt;-c fmt.Println(v,ok) } v, ok:= \u0026lt;-c fmt.Println(\u0026quot;final check: \u0026quot;,v,ok) }  range-and-close-output 0 (i) 1 true 1 (i) 2 true 3 (i) 5 true 8 (i) 13 true 21 (i) 34 true final check: 0 false  channels-close-buffer-size-test.go package main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func fibonacci(n int, c chan int) { x, y := 0, 1 for i := 0; i \u0026lt; n; i++ { c \u0026lt;- x x, y = y, x+y } fmt.Println(\u0026quot;gogo\u0026quot;) close(c) } func main() { c := make(chan int, 1) // go fibonacci(cap(c), c) // fibonacci(10, c) // capacity 주면 goroutine 안써도 값 들어감 go fibonacci(10, c) // goroutine 쓰면 capacity 초과해도 값 들어감 for i := range c { fmt.Println(i,\u0026quot; (i)\u0026quot;) time.Sleep(1000*time.Millisecond) } v, ok:= \u0026lt;-c fmt.Println(\u0026quot;final check: \u0026quot;,v,ok) }  output 0 (i) 1 (i) 1 (i) 2 (i) 3 (i) 5 (i) 8 (i) 13 (i) 21 (i) gogo 34 (i) final check: 0 false  select 부터 다시! ","date":"2021-07-25T14:03:14+09:00","permalink":"https://wadro.github.io/memo/cs/go/lab-golang-study-tutorials-03/","tags":["golang","go"],"title":"lab golang study tutorials 03"},{"categories":["Computer Engineering"],"contents":"Go tutorials  📔📝본 내용은 tour.golang.org 에 있는 내용을 정리한 글입니다. method 부터 concurrency 전까지  Go method! package main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) type Vertex struct { X, Y float64 } func (v Vertex) AbsMethod() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func AbsFunc(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } type MyFloat float64 // 메소드 만들때 주의사항, 일반 타입 안되고 custom 타입만 가능함. 같은 패키지 내에 선언되어 있어야함. ~~(싫어하는 이유가 계속 늘어난다!)~~ func (f MyFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } func (v *Vertex) AbsPointer(n float64) float64 { v.X = v.X * n v.Y = v.Y * n return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (v Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) fmt.Println(Abs(v)) f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) v := Vertex{3, 4} fmt.Println(v.AbsPointer(2)) // 포인터를 안쓰면 각각 다른 객체(복사된 값 사용) // 포인터를 쓰면 같은 레퍼런스를 참조하니까 같은 객체 v.Scale(10) fmt.Println(v.AbsPointer(2)) }  노트   메소드 주의사항\n  함수는 인자 넣을때 포인터 구분함(\u0026amp;붙여야됨) 메소드는 인자 넣을때 포인터 알아서 판단함 진짜 참 일관적으로 속편한 언어\u0026hellip; 언어는 속이 편한데 개발자가 불편\u0026hellip; v.Scale(5) == (\u0026amp;v).Scale(5)\n다행히 참조와 역참조 둘다 같은 특징을 가짐 p.Abs() 라는 메서드는 (*p).Abs() 로도 사용가능 그니까 value receiver이든 reference receiver 이든 메소드는 아무 신경안씀 대신 반드시 주의할점은, 레퍼런스 리시버는 값을 바꾸고, 값 리시버는 복사본을 만듬\n일반적으로 특정 유형의 모든 방법에는 값이나 포인터 리시버가 있어야 하지만 둘 다 혼합되어서는 안됩니다.\ntype Abser interface { Abs() float64 } func main() { var a Abser f := MyFloat(-math.Sqrt2) v := Vertex{3, 4} a = f // a MyFloat implements Abser fmt.Println(a.Abs()) //1.4142135623730951 a = \u0026amp;v // a *Vertex implements Abser // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. // a = v fmt.Println(a.Abs()) // 5 } type MyFloat float64 func (f MyFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) }  여기서 또 애매한 사실은,\nfunc (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) }  이렇게 하면 redeclared 라고 하면서, 아까 예제의 상황에서는\nfunc main() { a = \u0026amp;v // a *Vertex implements Abser fmt.Println(a.Abs()) // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. a = v fmt.Println(a.Abs()) } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) }  이건 또 잘 실행 된다\u0026hellip; 값 리시버에서는 주소 넣어도 되고, 값 넣어도 되는데, 주소 리시버에서는 꼭 주소만 넣어야 된다. 이게 뭐야?\n    자바를 잘몰라서\u0026hellip; 무슨 뜻이지?\n 인터페이스의 암시적 구현  type implements는 메소드를 실행함으로써 인터페이스를 구현합니다.\n명시적 intent의 선언도, \u0026ldquo;implementation\u0026quot;의 키워드도 없습니다.\n암시적 인터페이스는 인터페이스의 정의를 구현으로부터 분리하며,\n이는 사전 정렬 없이 어떠한 패키지에 등장할 수 있습니다.\n?      아래 나온 main 은 패키지 이름일듯? ({Hello}, main.T) Hello (3.141592653589793, main.F)\n  영어공부\n Under the hood : 내부 concrete type? 구체적인 타입 이름을 말하는 거겠지? 추상 타입도 있나? auto 같은거? 튜플이라고 하니까 (value, type) 직관적으로는 무슨 말을 하려고 하는지 의도는 알겠는데, 말은 모르겠다. 아무튼 이름 같아도 타입 다르면 다른거라는 거지.    nil receiver 가 좋다고 하던데\ntype I interface { M() } type T struct { S string } func (t *T) M() { // if t == nil { // fmt.Println(\u0026quot;this is\u0026quot;,t) // return // } fmt.Println(t) } /* 주석 처리 하면 (\u0026lt;nil\u0026gt;, *main.T) \u0026lt;nil\u0026gt; (\u0026amp;{hello}, *main.T) \u0026amp;{hello} 주석 풀면 (\u0026lt;nil\u0026gt;, *main.T) this is \u0026lt;nil\u0026gt; (\u0026amp;{hello}, *main.T) \u0026amp;{hello} t 를 *t 로 하면 t.S 와 같은 에러 발생 panic: runtime error: invalid memory address or nil pointer dereference 니 멋대로 해라... 아래는 실행 잘됨. func (t *T) M() { if t == nil { fmt.Println(\u0026quot;this is\u0026quot;,t) return } fmt.Println(*t) } */ func main() { var i I var t *T i = t describe(i) i.M() i = \u0026amp;T{\u0026quot;hello\u0026quot;} describe(i) i.M() } func describe(i I) { fmt.Printf(\u0026quot;(%v, %T)\\n\u0026quot;, i, i) }    type assertion\nvar i interface{} = \u0026quot;hello\u0026quot; s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // panic fmt.Println(f)    type switch\nfunc do(i interface{}) { switch v := i.(type) { case int: fmt.Printf(\u0026quot;Twice %v(%T) is %v\\n\u0026quot;, v,v, v*2) case string: fmt.Printf(\u0026quot;%q(%T) is %v bytes long\\n\u0026quot;, v,v, len(v)) default: fmt.Printf(\u0026quot;I don't know about type %T!\\n\u0026quot;, v) } } func main() { do(21) do(\u0026quot;hello\u0026quot;) do(true) }    Stringers 함수를 만들어놓으면 print할때 설정한것 처럼 나옴 함수 주석처리하면 그냥 객체만 나옴(아래 설정한 문장이 아니라)\ntype Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(\u0026quot;%v (%v years)\u0026quot;, p.Name, p.Age) } func main() { a := Person{\u0026quot;Arthur Dent\u0026quot;, 42} z := Person{\u0026quot;Zaphod Beeblebrox\u0026quot;, 9001} fmt.Println(a, z) }    io.Reader 의 타입? 아마 다른 인터페이스 (*strings.Reader)\nerror, io.EOF 의 타입은 (*errors.errorString)\n// 진도는 strings까지 했음 image 까지 하긴 했는데,\nimage 라이브러리는 나중에 사용하게 되면 다시 보는게 나을듯\n","date":"2021-07-22T19:55:35+09:00","permalink":"https://wadro.github.io/memo/cs/go/lab-golang-study-tutorials-02/","tags":["golang","go"],"title":"lab golang study tutorials 02"},{"categories":[""],"contents":"논문 레퍼런스 정리 (아래 링크를 한국어로 번역하였습니다.)\nread://https_blockchain.intellectsoft.net/?url=https%3A%2F%2Fblockchain.intellectsoft.net%2Fblog%2Fconsensus-protocols-that-meet-different-business-demands%2F\nhttps://blockchain.intellectsoft.net/blog/consensus-protocols-that-meet-different-business-demands/\noverview In our our previous post we described different types of blockchain. However, they only characterize the environment in which blockchain can operate. The heart of distributed ledger technology (DLT) is the consensus protocol.\n이전 게시물에서 다양한 유형의 블록체인에 대해 설명했습니다. 그러나 그것들은 블록체인이 작동할 수 있는 환경만을 특징짓습니다. 분산 원장 기술(DLT)의 핵심은 합의 프로토콜입니다.\nInterestingly, mathematicians and engineers have been developing distributed networks and consensensus protocols for decades but only with the emergence of Bitcoin has this technology made a leap forward. It doesn’t give any sign of stopping either, and it’s this leap forward that has allowed the variants of new rules for machine consensus to evolve. We invite you to take a glance at the most important of them.\n흥미롭게도 수학자와 엔지니어는 수십 년 동안 분산 네트워크와 합의 프로토콜을 개발해 왔지만 비트코인이 등장하면서 이 기술이 도약했습니다. 멈출 기미도 보이지 않으며, 이러한 도약 덕분에 기계 합의에 대한 새로운 규칙의 변형이 진화할 수 있었습니다. 그 중 가장 중요한 것을 한 눈에 볼 수 있도록 초대합니다.\nWhy Consensus Algorithm What is \u0026ldquo;consensus\u0026rdquo; anyway? To give a broad definition, consensus is an agreement that satisfies each of the parties involved. It’s a key to democracy and decentralization in general and DLTs in particular. Look at Bitcoin: despite having a mysterious founder in Satoshi Nakamoto, he has no power over the community whatsoever. Bitcoin as a blockchain is fully transparent and open-source, and every node is equal on the network.\n어쨌든 \u0026ldquo;합의\u0026quot;란 무엇입니까? 넓은 의미로, 합의란 만족하는 관여된 각 당사자 들을 만족시키는 동의이다. 그것은 특히 민주주의와 일반적인 지방 분권(탈중앙화) 및 DLTs 의 핵심입니다. 비트코인을 보세요: 사토시 나카모토라는 신비한 창립자가 있음에도 불구하고 그는 커뮤니티에 대한 권한이 전혀 없습니다. 블록체인으로서의 비트코인은 완전히 투명하고 오픈 소스이며 모든 노드는 네트워크에서 평등합니다.\nIn the narrow meaning that we apply to cryptography, consensus is a voting procedure. Its goal is to ensure that all members of the network agree on its current state even after the addition of a new block or a package of transactions. In other words, a consensus protocol guarantees that the chain is true and that there are incentives to keep participants fair. It’s a major framework for preventing a single entity from controlling the entire system and makes sure everybody follows the rules.\n합의를 암호에 적용시켰을때 좁은 의미로서의 합의란, 투표 절차입니다. 그 목표는 새로운 블록이나 트랜잭션 패키지를 추가한 후에도 네트워크의 모든 구성원이 현재 상태에 동의하도록 하는 것입니다. 다르게 말하면, 합의 프로토콜은 체인이 사실이고 참가자를 공정하게 유지하기 위한 인센티브가 있음을 보장합니다. 이것이 단일 개체가 전체 시스템을 제어하지 못하도록 방지하고 모든 사람이 규칙을 따르도록 하는 주요한 특징입니다.\nQuick Review Protocol = a set of rules\nProtocols help to:\n • ensure the viability of transactions in the network • eliminate double spending • alidate that participants are honest  A protocol is the sum of:\n the deterministic logical conditions of the framework cryptographic encryption as a basis of security social encouragement to maintain the given protocol  So what are some of these protocols?\n프로토콜 = 일련의 규칙\n프로토콜은 다음을 지원합니다.\n • 네트워크에서 트랜잭션의 실행 가능성 보장 • 이중 지출을 없애다 • 참가자들이 정직하다는 것을 강조  프로토콜은 다음의 합계입니다.\n • 프레임워크의 결정론적 논리적 조건 • 보안 기반으로 암호화 • 주어진 프로토콜을 유지하기 위한 사회적 격려  그렇다면 이러한 프로토콜에는 어떤 것들이 있습니까?\nProof-of-Work protocol Proof-of-Work (PoW)    Concept: Proof-of-Work (PoW)     Principle: A difficult solution to find but easy to verify.   Speed: Low   DLT setup: Public/private blockchain   Finality: Probabilistic   Example of use: Bitcoin, Ethereum, Litecoin    The Bitcoin blockchain is perhaps the most replicated blockchain. The multiple nodes running it, order the transactions according to the PoW consensus algorithm. To add new blocks, each node has to prove that it has performed a certain amount of work. To be precise, they solve a hard hashing puzzle using a high computational input.\n비트코인 블록체인은 아마도 가장 많이 복제된 블록체인일 것입니다. 이를 실행하는 여러 노드는 PoW 합의 알고리즘에 따라 트랜잭션을 주문합니다. 새 블록을 추가하려면 각 노드가 일정량의 작업을 수행했음을 증명해야 합니다. 정확하게 말하면, 그들은 높은 계산 입력을 사용하여 어려운 해싱 퍼즐을 풉니다.\nAs a result, participation in PoW carries a cost but can be implemented in an environment without trust. Since it suits permissionless blockchains, anybody can join the network. Although the scalability of peer networks is high, the transaction speed remains low. Another concern is the decrease of the reward over time and low fees in future; generally, miners join to get rich, not to voluntarily support the network.\n결과적으로 PoW 참여에는 비용이 따르지만 신뢰가 없는 환경에서 구현할 수 있습니다. 무허가 블록체인에 적합하기 때문에 누구나 네트워크에 참여할 수 있습니다. 피어 네트워크의 확장성은 높지만 트랜잭션 속도는 여전히 낮습니다. 또 다른 문제는 시간이 지남에 따라 보상이 감소하고 향후 수수료가 낮아진다는 것입니다. 일반적으로 광부들은 네트워크를 자발적으로 지원하기 위해 가입하는 것이 아니라 부자가 되기 위해 가입합니다.\nProof-of-Stake protocols Proof-of-Stake (PoS)    Concept: Proof-of-Stake (PoS)     Principle: The network trusts the validator who stakes their own coins; the bigger the stake the higher the chances of validating transactions.   Speed: Low   DLT setup: Public/private blockchain   Finality: Probabilistic   Example of use: NXT, Tezos, soon Ethereum    Turing-complete, Ethereum’s main network, is running on PoW. However, the project plans to switch to a more efficient protocol known as Proof-of-Stake in 2018. The unique feature of PoS is the absence of difficult and unnecessary computation. Instead of competing with others, network members deposit their crypto-assets, like ether in Ethereum, and wait to be randomly picked to process a validation of the network.\n이더리움의 메인 네트워크인 Turing-complete가 PoW에서 실행되고 있습니다. 그러나 프로젝트는 2018년에 Proof-of-Stake로 알려진 보다 효율적인 프로토콜로 전환할 계획입니다. PoS의 고유한 특징은 어렵고 불필요한 계산이 없다는 것입니다. 다른 사람들과 경쟁하는 대신 네트워크 구성원은 이더리움과 같은 암호화 자산을 이더리움에 예치하고 네트워크 유효성 검사를 처리하기 위해 무작위로 선택되기를 기다립니다.\nIf they’ve followed the rules, the staker creates or “mints” additional coins for validating a block of transactions. An algorithm selects one of the minters based on the stake they own. So if a node has a 5% stake, it will validate 5% of the transactions. The idea is that the higher the stake of the validator in the underlying cryptocurrency, the less interest they have in corrupting the validation process.\n그들이 규칙을 따랐다면 스테이커는 거래 블록을 검증하기 위해 추가 코인을 생성하거나 \u0026ldquo;발행\u0026quot;합니다. 알고리즘은 그들이 소유한 지분을 기반으로 발행자 중 하나를 선택합니다. 따라서 노드에 5%의 지분이 있으면 트랜잭션의 5%를 검증합니다. 기본 암호 화폐에서 유효성 검사기의 지분이 높을수록 유효성 검사 프로세스를 손상시키는 데 관심이 적어집니다.\nJust like with PoW algorithm, transaction finality in PoS is probabilistic. Though transactions are relatively fast compared to those of Bitcoin, it still requires tokens to work. Furthermore, skeptics indicate that validators with high stakes will be selected more often and thus obtain even more tokens: the rich get richer.\nPoW 알고리즘과 마찬가지로 PoS의 트랜잭션 완결성은 확률적입니다. 거래는 비트코인에 비해 상대적으로 빠르지만 작동하려면 여전히 토큰이 필요합니다. 또한 회의론자들은 높은 지분을 가진 검증인이 더 자주 선택되어 더 많은 토큰을 얻게 될 것이라고 말합니다. 부자는 더 부자가 됩니다.\nHowever, the PoS algorithm doesn’t incentivize those who don’t expend any cryptocurrency. Consequently, they are likely to vote on multiple blocks to support “forks” — copies of the blockchain with a new set of rules — while seeking to maximize the reward. This is called “nothing at stake” problem. On the other hand, the primary incentive to support the algorithm while running own node is securing funds rather than assuming that exchanges will do this for you.\n그러나 PoS 알고리즘은 암호화폐를 사용하지 않는 사람들에게 인센티브를 제공하지 않습니다. 결과적으로, 그들은 보상을 최대화하는 동시에 \u0026ldquo;포크\u0026rdquo;(새로운 규칙 세트가 있는 블록체인의 사본)를 지원하기 위해 여러 블록에 투표할 가능성이 높습니다. 이것을 \u0026ldquo;위험하지 않은 문제(?)\u0026ldquo;라고 합니다. 반면에 자체 노드를 실행하는 동안 알고리즘을 지원하는 주요 인센티브는 거래소가 이를 수행할 것이라고 가정하기 보다는 자금을 확보하는 것입니다.\nDelegated Proof-of-Stake (DPoS)    Concept: Delegated Proof-of-Stake (DPoS)     Principle: The participants delegate production of new blocks to a small and fixed number of elected participants. Highly competitive but highly profitable.   Speed: High   DLT setup: Public/private blockchain   Finality: Probabilistic   Example of use: EOS, BitShares    In the meantime, developers offered an alternative economic incentive called the Delegated Proof-of-Stake or DPoS. It allows you to generate blocks at high speed and handle a large number of transactions per second compared to other consensus algorithms. The basic principle of DPoS is to divide the voting and validation procedure among a few delegated participants.\n그 동안 개발자들은 위임 지분 증명 또는 DPoS라는 대안적인 경제적 인센티브를 제공했습니다. 다른 합의 알고리즘에 비해 빠른 속도로 블록을 생성하고 초당 많은 수의 트랜잭션을 처리할 수 있습니다. DPoS의 기본 원칙은 투표 및 검증 절차를 위임된 소수의 참가자에게 나누는 것입니다.\nDuring voting, coin holders choose the validators of transactions that will form blocks. The weight of each vote is determined by the sum of the assets of the voter. Coin holders can re-vote candidates at any time. This determines the high resilience of the network: if most of the performers fail, the community will immediately vote for their replacement.\n투표하는 동안 코인 보유자는 블록을 형성할 거래의 유효성 검사기를 선택합니다. 각 투표의 가중치는 유권자 자산의 합계로 결정됩니다. 코인 보유자는 언제든지 후보자에게 재투표할 수 있습니다. 이것은 네트워크의 높은 탄력성을 결정합니다. 대부분의 수행자가 실패하면 커뮤니티는 즉시 교체에 투표합니다.\nThe generation of new blocks happens every 1 or 2 seconds. This protocol is not only faster, but more fair since the “delegated” validator shares newly minted coins with its voters later. However, confirmation is still needed from all validators. Therefore, a user may have to wait around twenty more blocks to ensure the validity of the transaction.\n새 블록의 생성은 1초 또는 2초마다 발생합니다. 이 프로토콜은 \u0026ldquo;위임된\u0026rdquo; 검증자가 나중에 유권자와 새로 발행된 코인을 공유하기 때문에 더 빠를 뿐만 아니라 더 공정합니다. 그러나 여전히 모든 검증인의 확인이 필요합니다. 따라서 사용자는 트랜잭션의 유효성을 확인하기 위해 약 20개의 블록을 더 기다려야 할 수 있습니다.\nDaniel Larimer developed DPoS in 2014. He first used it in his BitShares project, and later in Steemit and EOS. Larimer hypothesized that validators in DPoS will have a strong incentive to remain fair and offer the fastest and best service possible. After all, it would be silly to hack a network that pays you well. And if you stop doing a good job, there are other members that are ready and willing to take the place of the validator.\nDaniel Larimer는 2014년에 DPoS를 개발했습니다. 그는 BitShares 프로젝트에서 처음으로 DPoS를 사용했고 나중에는 Steemit과 EOS에서 사용했습니다. Larimer는 DPoS의 검증인이 공정성을 유지하고 가능한 가장 빠르고 최고의 서비스를 제공할 강력한 인센티브를 가질 것이라고 가정했습니다. 결국 돈을 잘 버는 네트워크를 해킹하는 것은 어리석은 일입니다. 그리고 당신이 좋은 일을 그만둔다면, 검증인을 대신할 준비가 되어 있고 기꺼이 하는 다른 구성원이 있습니다.\nByzantine Fault Tolerance (BFT) protocols So far we’ve been talking about public blockchains that operate in a trustless environment and aim at decentralization. What about private enterprise blockchains? What if participants can trust each other? It’s true that the fewer validators a blockchain has, the faster it is. In fact, the speed increases tenfold, from hundreds to thousands of transactions per second, which is a great fit for corporate blockchain solutions.\n지금까지 우리는 무신뢰 환경에서 작동하고 탈중앙화를 목표로 하는 퍼블릭 블록체인에 대해 이야기했습니다. 민간 기업 블록체인은 어떻습니까? 참가자들이 서로를 신뢰할 수 있다면 어떨까요? 블록체인에 검증인이 적을수록 더 빠른 것이 사실입니다. 실제로 속도는 초당 수백에서 수천 개의 트랜잭션으로 10배 증가하므로 기업 블록체인 솔루션에 매우 적합합니다.\nByzantine Fault Tolerance (BFT) protocol is a different class of protocols that does not require tokens during the voting as in a PoS algorithm. Furthermore, it allows signing of a block even when 1/3 of the actors fail or act maliciously. BFT resolves the problem of numerous faults in the system and the waiting time of up to 30 seconds for confirming a block.\nBFT(Byzantine Fault Tolerance) 프로토콜은 PoS 알고리즘에서와 같이 투표 중에 토큰이 필요하지 않은 다른 종류의 프로토콜입니다. 또한 액터의 1/3이 실패하거나 악의적으로 행동하더라도 블록에 서명할 수 있습니다. BFT는 시스템의 수많은 장애와 블록 확인을 위한 최대 30초의 대기 시간 문제를 해결합니다.\nIn fact, the algorithm refers to an old Byzantine Generals’ problem, based on a real historical event. Using the analogy, the protocol does not care if a “general” got sick or sabotaged the counterparts — the system will still function even when the node goes offline.\n사실, 알고리즘은 실제 역사적 사건을 기반으로 한 오래된 비잔틴 장군의 문제를 나타냅니다. 유추를 사용하면 프로토콜은 \u0026ldquo;장군\u0026quot;이 아프거나 상대방을 방해하는 경우 신경 쓰지 않습니다. 노드가 오프라인 상태가 된 경우에도 시스템은 계속 작동합니다.\nDelegated Byzantine Fault Tolerance (DBFT)    Concept: Delegated Byzantine Fault Tolerance (DBFT)     Principle: Preselected nodes maintain consensus even if some of them fail or are malicious.   Speed: Very high   DLT setup: Public/private blockchain   Finality: Immediate   Example of use: NEO, TON    So the BFT consensus protocol seems like salvation from the imperfections of PoW and PoS, but given thousands of validators, it would still struggle to resolve the speed issue. This is why developers offered a delegated model of BFT — the DBFT.\nPredefined validators in this consensus protocol allow it to far outstrip other protocols. Take Ethereum with 15-20 transactions per second and NEO with almost 10,000 t/s. It is indeed convenient to have a few known actors who validate transactions before releasing to other nodes. In case a validator betrays the network, participants can delegate a different node.\nNote: since NEO runs on PoS DBFT protocol, the network members not only delegate validators but also receive a native token GAS as part of their validator stake.\n따라서 BFT 합의 프로토콜은 PoW 및 PoS의 불완전함에서 구원받는 것처럼 보이지만 수천 명의 검증인을 고려할 때 속도 문제를 해결하는 데 여전히 어려움을 겪을 것입니다. 이것이 개발자들이 BFT의 위임 모델인 DBFT를 제안한 이유입니다.\n이 합의 프로토콜의 사전 정의된 검증자는 다른 프로토콜을 훨씬 능가합니다. 초당 15-20개의 트랜잭션으로 이더리움을, 거의 10,000t/s로 NEO를 사용하십시오. 다른 노드에 릴리스하기 전에 트랜잭션을 검증하는 알려진 행위자가 몇 명 있는 것이 참으로 편리합니다. 검증인이 네트워크를 배신하는 경우 참가자는 다른 노드를 위임할 수 있습니다.\n참고: NEO는 PoS DBFT 프로토콜에서 실행되기 때문에 네트워크 구성원은 검증인을 위임할 뿐만 아니라 검증인 지분의 일부로 기본 토큰 GAS를 받습니다.\nPractical Byzantine Fault Tolerance (PBFT)    Concept: Practical Byzantine Fault Tolerance (PBFT)     Principle: Standard blockchain for enterprise.   Speed: High   DLT setup: Private permissioned blockchain   Finality: Immediate   Example of use: Hyperledger, Chain    If one wants a scalable and fast blockchain, this is a way to go. PBFT protocol is very similar to DBFT, especially in regard to its more centralized nature. The only difference is that the former has a simpler implementation and is often a private blockchain with appointed signing nodes from the very beginning. Which is kind of practical, isn’t it?\nWhen a validator receives a message, it performs a computation, and then asks all other nodes in turn if the transaction is valid. After confirming validation, the first validator broadcasts the decision to the network of other validators. In this way, consensus is achieved based on the confirmation being submitted by all validators.\nPBFT is effective in low latency systems but sensitive to the number of validators and throughput. It fits well for private setups which don’t require a large amount of capacity, but demand many transactions. PBFT guarantees the accuracy of transaction records within the network.\nYou may also have encountered SIEVE protocol which is a type of PBFT. It handles non-deterministic chaincode execution. There is also Cross Fault Tolerance (XFT) protocol as well as Paxos and Raft protocols which are Crash Fault Tolerant (CFT). We might cover these deep technical characteristics in future articles but if it’s important to you, you could always ask us.\n확장 가능하고 빠른 블록체인을 원한다면 이것이 바로 갈 길입니다. PBFT 프로토콜은 특히 중앙 집중식 특성과 관련하여 DBFT와 매우 유사합니다. 유일한 차이점은 전자는 구현이 더 간단하고 처음부터 서명 노드가 지정된 프라이빗 블록체인인 경우가 많다는 것입니다. 어떤 것이 실용적이지 않습니까?\n유효성 검사기는 메시지를 수신하면 계산을 수행한 다음 트랜잭션이 유효한지 다른 모든 노드에 차례로 묻습니다. 유효성 검사를 확인한 후 첫 번째 유효성 검사자는 결정을 다른 유효성 검사자의 네트워크에 브로드캐스트합니다. 이러한 방식으로 모든 검증자가 제출한 확인을 기반으로 합의가 이루어집니다.\nPBFT는 대기 시간이 짧은 시스템에서 효과적이지만 검증인의 수와 처리량에 민감합니다. 많은 용량을 필요로 하지 않지만 많은 트랜잭션을 요구하는 개인 설정에 적합합니다. PBFT는 네트워크 내 거래 기록의 정확성을 보장합니다.\n또한 PBFT 유형인 SIEVE 프로토콜을 접했을 수도 있습니다. 비결정적 체인코드 실행을 처리합니다. XFT(Cross Fault Tolerance) 프로토콜과 CFT(Crash Fault Tolerant)인 Paxos 및 Raft 프로토콜도 있습니다. 우리는 향후 기사에서 이러한 심층적인 기술적 특성을 다룰 수 있지만 그것이 당신에게 중요하다면 언제든지 Google에 문의할 수 있습니다.\nFederated Byzantine Agreement (FBA)    Concept: Federated Byzantine Agreement (FBA)     Principle: Blocks are validated if signed by a specified quorum of signers.   Speed: High   DLT setup: Public or private permissionless blockchain   Finality: Immediate   Example of use: Stellar, Ripple    Here you have a permissionless BFT protocol as opposed to the permissioned PBFT and other variants of BFT. A Federated Byzantine Agreement (FBA) allows anybody to join the network but transactions are verified by a group instead of one node broadcasting the message to others.\nNotably, FBA has Gateways and Market-Makers which ensure the fairness and liquidity of the network. The former act as traditional banks holding the fiat funds and creating an equivalent in virtual tokens. Market-makers keep accounts with multiple Gateways and in several currencies.\n여기에는 허가된 PBFT 및 기타 BFT 변형과 달리 허가 없는 BFT 프로토콜이 있습니다. FBA(Federated Byzantine Agreement)를 통해 누구나 네트워크에 가입할 수 있지만 트랜잭션은 한 노드가 메시지를 다른 노드에 브로드캐스팅하는 대신 그룹에 의해 확인됩니다.\n특히 FBA에는 네트워크의 공정성과 유동성을 보장하는 게이트웨이 및 마켓 메이커가 있습니다. 전자는 명목 펀드를 보유하고 가상 토큰으로 이에 상응하는 것을 생성하는 전통적인 은행 역할을 합니다. 시장 조성자는 여러 게이트웨이와 여러 통화로 계정을 유지합니다.\nQuick Review   • Proof-of-Work has been the first and most reliable consensus protocol for public blockchains like Bitcoin and Ethereum, yet it is energy-inefficient.\n  • Proof-of-Stake does not require hard computation. Instead, it encourages users to stake their own funds to perform the equivalent quantity of transaction validations and assumes everyone will act rationally.\n  • BFT is an addition to PoS concept that makes it much faster and more tolerant to faulty nodes. It’s only practical to run on small and private setups though.\n  • PBFT is a proven solution for corporate blockchains. Fast and safe but relies on throughput.\n  • DBFT improves BFT by allowing participants of the BFT network to delegate their validators. Very fast but more centralized.\n  • While the abovementioned BFT variants are permissioned blockchains, FBA is federated and, thus, permissionless. But there are more protocols…\n  • 작업 증명은 비트코인 및 이더리움과 같은 공개 블록체인을 위한 최초이자 가장 신뢰할 수 있는 합의 프로토콜이지만 에너지 비효율적입니다.\n  • 지분 증명은 어려운 계산을 필요로 하지 않습니다. 대신, 사용자가 동일한 양의 거래 검증을 수행하기 위해 자신의 자금을 걸도록 권장하고 모든 사람이 합리적으로 행동할 것이라고 가정합니다.\n  • BFT는 PoS 개념에 추가된 것으로 결함이 있는 노드에 대해 훨씬 빠르고 관대합니다. 그러나 소규모 및 개인 설정에서만 실행하는 것이 실용적입니다.\n  • PBFT는 기업 블록체인을 위한 검증된 솔루션입니다. 빠르고 안전하지만 처리량에 의존합니다.\n  • DBFT는 BFT 네트워크 참가자가 검증인을 위임할 수 있도록 하여 BFT를 개선합니다. 매우 빠르지만 더 중앙 집중화되어 있습니다.\n  • 위에서 언급한 BFT 변종은 허가된 블록체인이지만 FBA는 연합되어 있으므로 허가가 없습니다. 그러나 더 많은 프로토콜이 있습니다 \u0026hellip;\n  Directed Acyclic Graph protocol Researcher Serguei Popov ran a thought experiment: what if we can avoid blocks completely?\nSerguei Popov 연구원은 사고 실험을 실행했습니다. 블록을 완전히 피할 수 있다면 어떨까요?\nDirected Acyclic Graph (DAG)    Concept: Directed Acyclic Graph (DAG)     Principle: No fixed blocks that are confirmed in a random order on a linear scale.   Speed: High   DLT setup: Public permissioned non-blockchain   Finality: Probabilistic   Example of use: IOTA, ByteBall    The major issue with blockchain is its synchronous nature. Blockchains cannot be parallel. One can change the size or frequency of blocks as well as the parties that approve them, but there will always be a waiting queue. Alternately, Directed Acyclic Graph (DAG) technology is asynchronous which gives the competitive advantage of simultaneous events.\nThe protocol in such systems lets participants confirm a block of transactions a few blocks away, since there will eventually be another participant proving it is correct. While this implies ultra high speeds for the network, it’s slow on a smaller scale. Additionally, there’s a danger of parasite “chains” of non-valid transactions and centralization due to preselected validators.\n블록체인의 주요 문제는 동기적 특성입니다. 블록체인은 병렬일 수 없습니다. 블록의 크기나 빈도와 블록을 승인하는 당사자를 변경할 수 있지만 항상 대기 대기열이 있습니다. 또는 DAG(Directed Acyclic Graph) 기술은 동시 이벤트의 경쟁 우위를 제공하는 비동기식입니다.\n이러한 시스템의 프로토콜을 사용하면 참가자가 몇 블록 떨어진 곳에서 트랜잭션 블록을 확인할 수 있습니다. 결국 다른 참가자가 그것이 옳다는 것을 증명할 것이기 때문입니다. 이것은 네트워크의 초고속 속도를 의미하지만 소규모에서는 느립니다. 또한 사전 선택된 유효성 검사기로 인해 유효하지 않은 거래 및 중앙 집중화의 기생 \u0026ldquo;체인\u0026quot;의 위험이 있습니다.\nHashGraph    Concept: HashGraph     Principle: Nodes communicate randomly using the ‘gossip about gossip’ protocol and agree on consensus after a certain communication round.   Speed: Very High   DLT setup: Private permissioned non-blockchain   Finality: Round based   Example of use: HashGraph    The developers of this protocol claim that blockchain is an outdated system. As a substitute, they also advocate for the DAG concept. However, the key difference of HashGraph is a “gossip to gossip” protocol, where a node receives a time-stamped set of transactions that the other node “knows” about. As a result, there is an endless hash tree — or a graph — that grows over time with millions of time-stamps, the leaves. Once the majority of the network agrees on a particular event, there is no doubt it is valid.\nThere are certain limitations however. First of all, there is little evidence of practical implementation on a large scale, especially when compared to working blockchain projects. Secondly, HashGraph technology is patented and acquiring a license costs money. This also leads to the third issue: the lack of a strong community (like those associated with open-source projects). Such a community can test the robustness of a protocol, its vulnerability towards hackers and issues of compatibility. HashGraph is currently available for private setup only.\n이 프로토콜의 개발자는 블록체인이 구식 시스템이라고 주장합니다. 대안으로서 그들은 또한 DAG 개념을 옹호합니다. 그러나 HashGraph의 주요 차이점은 \u0026ldquo;가십 대 가십\u0026rdquo; 프로토콜로, 한 노드가 다른 노드가 \u0026ldquo;알고 있는\u0026rdquo; 타임 스탬프 트랜잭션 집합을 수신합니다. 결과적으로 수백만 개의 타임 스탬프와 함께 시간이 지남에 따라 성장하는 끝없는 해시 트리 또는 그래프가 있습니다. 네트워크의 과반수가 특정 이벤트에 동의하면 그것이 유효하다는 데는 의심의 여지가 없습니다.\n그러나 특정 제한 사항이 있습니다. 우선, 특히 작업 중인 블록체인 프로젝트와 비교할 때 대규모로 실질적인 구현에 대한 증거가 거의 없습니다. 둘째, HashGraph 기술은 특허를 받았고 라이센스를 얻는 데 비용이 듭니다. 이것은 또한 세 번째 문제로 이어집니다. 강력한 커뮤니티(오픈 소스 프로젝트와 관련된 커뮤니티와 같은)의 부족입니다. 이러한 커뮤니티는 프로토콜의 견고성, 해커에 대한 취약성 및 호환성 문제를 테스트할 수 있습니다. HashGraph는 현재 비공개 설정에만 사용할 수 있습니다.\nOther Consensus Protocols for Specific Tasks As if that wasn’t enough, people have pushed technology and the imagination even further . More researchers and blockchain developers have experimented with new consensus models that would resolve different business challenges.\n그것으로 충분하지 않다는 듯이 사람들은 기술과 상상력을 더욱 밀어붙였습니다. 더 많은 연구원과 블록체인 개발자가 다양한 비즈니스 과제를 해결할 수 있는 새로운 합의 모델을 실험했습니다.\nProof-of-Activity (PoA)    Concept: Proof-of-Activity (PoA)     Principle: A hybrid of PoW and PoS   Speed: Low   DLT setup: Public permissionless blockchain   Finality: Probabilistic   Example of use: Decred    Proof-of-Activity (PoA) combines PoW and PoS protocols meaning that the participants can both mine and stake their coins to validate blocks. This way, the PoA protocol ensures a balance between miners and common participants of the network.\n활동 증명(PoA)은 PoW와 PoS 프로토콜을 결합하여 참가자가 블록을 검증하기 위해 코인을 채굴하고 스테이킹할 수 있음을 의미합니다. 이러한 방식으로 PoA 프로토콜은 광부와 네트워크의 일반 참가자 간의 균형을 보장합니다.\nProof-of-Location (PoL)    Concept: Proof-of-Location (PoL)     Principle: Use beacons to notice a node in a synchronized manner and then timestamp its presence.   Speed: Medium   DLT setup: Public permissionless blockchain   Finality: Immediate   Example of use: FOAM, Platin    Proof-of-Location (PoL) lets users privately record authenticated location data when they choose so, without GPS. Then, they can reveal this personal information at will.\nInterestingly, the protocol relies on the BFT of the beacons that record geolocation and timestamp it in the blockchain which prevents the system from failures and frauds.\n위치 증명(PoL)을 사용하면 사용자가 원하는 경우 GPS 없이 인증된 위치 데이터를 비공개로 기록할 수 있습니다. 그런 다음 이 개인 정보를 마음대로 공개할 수 있습니다.\n흥미롭게도 이 프로토콜은 지리적 위치를 기록하고 블록체인에 타임스탬프를 기록하는 비콘의 BFT에 의존하여 시스템 실패 및 사기를 방지합니다.\nProof-of-Importance (PoI)    Concept: Proof-of-Importance (PoI)     Principle: Like PoS but with additional properties that influence your ranking.   Speed: High   DLT setup: Public permissionless blockchain   Finality: Probabilistic   Example of use: NEM    The Proof-of-Importance (PoI) consensus algorithm acts almost like PoS but includes three components:\n • The number of tokens in the account • Account transaction activity • Time the has account spent in the network  While the first parameter plays a major role in the ranking for verifying transactions, the second and third parameters are rather weak but still help with establishing the “importance” of an account. The smaller the sum of tokens, the stronger influence of other parameters.\nThus, an account that “vested” hundreds of thousands of tokens can increase its significance factor up to 3 times due to its activity and consistent presence in the network. On the other hand, it doesn’t make any difference for those who possess hundreds of millions of tokens in their account.\nPoI(Proof-of-Importance) 합의 알고리즘은 PoS와 거의 비슷하게 작동하지만 세 가지 구성요소를 포함합니다.\n • 계정의 토큰 수 • 계정 거래 활동 • 네트워크에서 사용한 계정 시간  첫 번째 매개변수가 거래 검증 순위에서 중요한 역할을 하는 반면, 두 번째와 세 번째 매개변수는 다소 약하지만 여전히 계정의 \u0026ldquo;중요성\u0026quot;을 설정하는 데 도움이 됩니다. 토큰 합계가 작을수록 다른 매개변수의 영향이 더 강해집니다.\n따라서 수십만 개의 토큰을 \u0026ldquo;베팅\u0026quot;한 계정은 활동과 네트워크에서의 일관된 존재로 인해 중요도를 최대 3배까지 높일 수 있습니다. 반면에 계정에 수억 개의 토큰을 보유하고 있는 사람들에게는 아무런 차이가 없습니다.\nProof-of-Elapsed-Time (PoET)    Concept: Proof-of-Elapsed-Time (PoET)     Principle: Blocks are created in a trusted environment with equal periods   Speed: Medium   DLT setup: Private permissioned or permissionless blockchain   Finality: Probabilistic   Example of use: Intel    Chipmaker Intel didn’t lag behind and developed their own blockchain entitled IntelLedger. A consensus algorithm of IntelLedger is called Proof of Elapsed Time (PoET). Today, it is a HyperLedger consensus module.\nThis system is similar to Proof-of-Work, but consumes far less electricity. Instead of having participants solve a cryptographic puzzle, the algorithm operates in a Trusted Execution Environment (TEE), such as Intel’s Software Guard Extensions (SGX). The PoET protocol also assures blocks get created through a lottery but without any required work.\nIntel’s solution offers a guaranteed wait time due to the TEE. According to the company, the proof-of-elapsed-time algorithm can scale to thousands of nodes and will properly run on any Intel processor that supports SGX. Isn’t blockchain supposed to be helping us to get away from third parties rather than relying on them though?\n칩 제조업체 Intel은 뒤처지지 않고 IntelLedger라는 자체 블록체인을 개발했습니다. IntelLedger의 합의 알고리즘을 PoET(Proof of Elapsed Time)라고 합니다. 오늘은 HyperLedger 합의 모듈입니다.\n이 시스템은 작업 증명과 유사하지만 훨씬 적은 전력을 소비합니다. 참가자가 암호화 퍼즐을 풀도록 하는 대신 알고리즘은 Intel의 SGX(Software Guard Extensions)와 같은 TEE(신뢰할 수 있는 실행 환경)에서 작동합니다. PoET 프로토콜은 또한 복권을 통해 블록이 생성되지만 필요한 작업 없이도 보장합니다.\n인텔의 솔루션은 TEE로 인해 보장된 대기 시간을 제공합니다. 회사에 따르면 경과 시간 증명 알고리즘은 수천 개의 노드로 확장할 수 있으며 SGX를 지원하는 모든 인텔 프로세서에서 제대로 실행됩니다. 블록체인은 우리가 제3자에게 의존하기보다 제3자로부터 벗어날 수 있도록 도와야 하지 않을까요?\nBeyond the Mainstream Protocols There are more exotic protocols like Proof-of-Stake-Time (PoST) and Proof-of-Brain (PoB) that we just couldn’t fit in this article. Find them in Part II. Moreover, our Blockchain glossary will help you keep on top of the ever growing collection of Blockchain related terminology.\nPoST(Proof-of-Stake-Time) 및 PoB(Proof-of-Brain)와 같은 더 특이한 프로토콜이 있지만 이 기사에서는 다루지 못했습니다. 파트 II에서 찾으십시오. 또한, 블록체인 용어집을 통해 계속 증가하는 블록체인 관련 용어 모음을 파악하는 데 도움이 될 것입니다.\n◼[end]\n","date":"2021-07-15T13:30:26+09:00","permalink":"https://wadro.github.io/memo/graduate/references/consensus-protocols-that-meet-different-business-demands.-part-i/","tags":[""],"title":"Consensus Protocols That Meet Different Business Demands  Part I"},{"categories":["Computer Engineering"],"contents":"Go tutorials  📔📝본 내용은 tour.golang.org 에 있는 내용을 정리한 글입니다.  Hello, Go world! (전 튜토리얼을 하나로 모음) package main // 파일들(함수들)을 모아놓은 하나의 세트 import ( // 이런식으로 한번에 임포트 하는것이 권장됨(factored style) \u0026quot;fmt\u0026quot; // 표준 라이브러리 \u0026quot;time\u0026quot; // 시간 관련 라이브러리 \u0026quot;math/rand\u0026quot; // package rand 로 시작하는 파일들로 구성됨. \u0026quot;math/cmplx\u0026quot; // 복소수 라이브러리 \u0026quot;strings\u0026quot; // 문자열 관련 함수 모음 ) /* 함수 선언 방법: func 함수명(변수_이름 타입, ...) 출력_타입 { ... return 출력값 } */ func add(x int, y int) int { return x + y } /* 위와 같은 함수: func add(x, y int) int { // 같은 타입이면 묶어서 선언 가능 return x + y } */ func swap(x, y string) (string, string) { return y, x // 복수 개의 결과 출력 가능 } func split(sum int) (x, y int) { // 결과값에 이름 붙일수 있음 x = sum * 4 / 9 y = sum - x return // 아무것도 없으면 결과값으로 선언한 변수들이 출력됨 } func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { // if 변수 선언(스코프는 if 또는 else {}블록안에서만 유효함) return v } return lim } var c, python, java bool // 전역변수 var i, j int = 1, 2 // 초기값 선언 var ( // factored 선언 가능 ToBe bool = false MaxInt uint64 = 1\u0026lt;\u0026lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) const Pi = 3.14 // 상수는 := 표기법으로 선언 못함 func main() { fmt.Println(\u0026quot;Hello, 世界\u0026quot;) // \\n 포함된 함수 fmt.Println(\u0026quot;The time is\u0026quot;, time.Now()) // 현재 시각 출력 fmt.Println(math.pi) // 대문자로 시작하면 export 되고(다른 파일에서 사용가능), 소문자로 시작하면 export 안됨 fmt.Println(add(42, 13)) a, b := swap(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) var i int // 지역변수, i 초기화(0) var c, python, java = true, false, \u0026quot;no!\u0026quot; // 선언된 값으로 초기화 k := 3 // 함수 안에서는 짧은 표현식 가능, 함수 밖에서는 에러. var 로 시작해야함 fmt.Println(i,j,k, c, python, java) fmt.Printf(\u0026quot;Type: %T Value: %v\\n\u0026quot;, ToBe, ToBe) fmt.Printf(\u0026quot;Type: %T Value: %v\\n\u0026quot;, MaxInt, MaxInt) fmt.Printf(\u0026quot;Type: %T Value: %v\\n\u0026quot;, z, z) sum := 0 for i := 0; i \u0026lt; 10; i++ { sum += i } fmt.Println(sum) sum = 1 for ; sum \u0026lt; 1000; { sum += sum } fmt.Println(sum) sum = 1 for sum \u0026lt; 1000 { // for == while sum += sum if sum \u0026gt; 100 { break } } fmt.Println(sum) /* for { } // 무한 루프 */ // Go 의 switch문은 break 안해도 된다! switch os := runtime.GOOS; os { case \u0026quot;darwin\u0026quot;: fmt.Println(\u0026quot;OS X.\u0026quot;) case \u0026quot;linux\u0026quot;: fmt.Println(\u0026quot;Linux.\u0026quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(\u0026quot;%s.\\n\u0026quot;, os) } switch { // 조건 없으면 switch true 와 같음 case t.Hour() \u0026lt; 12: fmt.Println(\u0026quot;Good morning!\u0026quot;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026quot;Good afternoon.\u0026quot;) default: fmt.Println(\u0026quot;Good evening.\u0026quot;) } /* 1. defer 문은 자신이 포함된 함수 블록이 전부 실행되면 제일 마지막에 실행됨 2. stack 구조(defer 를 두개 하면 나중에 들어간 쪽이 먼저 실행됨) */ defer fmt.Println(\u0026quot;world\u0026quot;) for i := 0; i \u0026lt; 10; i++ { defer fmt.Println(i) } /* Go의 포인터는 포인터 연산없이 그냥 주소 ⊃ 값 의 관계, address ⊃ value 의 관계에서 address == \u0026amp;value 참조(주소\u0026lt;-값) *address == value 역참조(주소-\u0026gt;값) */ i, j := 42, 2701 p := \u0026amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = \u0026amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.Println(j) // see the new value of j type Vertex struct { // 구조체는 여러 타입을 하나로 모은 집합 X int Y int } fmt.Println(Vertex{1, 2}) v := Vertex{1, 2} v.X = 4 // .(dot) 오퍼레이터로 접근 가능 fmt.Println(v.X) v := Vertex{1, 2} p := \u0026amp;v // 원래는 주소값이니까 (*p).X 이렇게 써야하는데 p.X = 1e9 // 생략 가능함 /* c 에서는 -\u0026gt; (arrow) 오퍼레이터를 썼는데 Go 에서는 단순함을 위해서 그냥 생략한듯? 나중에 함수형을 지원하기 위해서일까? 아직까지도 안넣은거 보면 그냥 아예 생각이 없는듯 2021-07-18T16:24:50+09:00 */ fmt.Println(v) v1 = Vertex{1, 2} // has type Vertex v2 = Vertex{Y: 1} // X:0 is implicit? v3 = Vertex{} // X:0 and Y:0 p = \u0026amp;Vertex{1, 2} // has type *Vertex // 쉽게(?!) 기억하는 법 // type =\u0026gt; some value of some type ==\u0026gt; x: type // array =\u0026gt; n number of type ==\u0026gt; [n]type var a [10]int // declares a variable a as an array of **ten integers** // 주의: array 는 타입의 일종이므로 resize 불가 // array의 카피본인 slice 라는 개념이 있음 // 주의2: slice 는 레퍼런스를 공유함 // 즉, slice 수정하면 array 도 수정됨 // 그리고 같은 array를 레퍼런스를 가지는 slice 또한 레퍼런스를 공유함 primes := [6]int{2, 3, 5, 7, 11, 13} var s []int = primes[1:4] fmt.Println(s) // slice만 만들면 array는 자동 생성됨(일종의 레퍼런스) q := []int{2, 3, 5, 7, 11, 13} fmt.Println(q) q1 := q[0:4] q1[2] = 1000 r := []bool{true, false, true, true, false, true} fmt.Println(r) fmt.Println(q) s := []struct { i int b bool }{ {2, true}, {3, false}, {5, true}, {7, true}, {11, false}, {13, true}, } fmt.Println(s) s := []int{2, 3, 5, 7, 11, 13} s = s[1:4] fmt.Println(s) s = s[:2] fmt.Println(s) // 상한 하한 없으면 그냥 끝까지 s = s[1:] fmt.Println(s) s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length. s = s[:1] printSlice(s) // Extend its length. s = s[1:4] printSlice(s) s = s[:5] printSlice(s) // Drop its first two values. s = s[2:] printSlice(s) s = s[2:] printSlice(s) s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length. s = s[2:] printSlice(s) // Extend its length. s = s[1:2] printSlice(s) s = s[:3] printSlice(s) // Drop its first two values. s = s[2:] printSlice(s) s = s[1:] printSlice(s) s = s[:1] printSlice(s) var s []int var p *int fmt.Println( s, len(s), cap(s),p) if s == nil { fmt.Println(\u0026quot;nil slice\u0026quot;) } if p == nil { fmt.Println(\u0026quot;nil pointer\u0026quot;) } fmt.Printf(\u0026quot;%T, %T\u0026quot; ,s,p) a := make([]int, 5) printSliceAndString(\u0026quot;a\u0026quot;, a) b := make([]int, 0, 5) printSliceAndString(\u0026quot;b\u0026quot;, b) c := b[:2] printSliceAndString(\u0026quot;c\u0026quot;, c) d := c[2:5] printSliceAndString(\u0026quot;d\u0026quot;, d) board := [][]string{ []string{\u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;}, []string{\u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;}, []string{\u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;}, } // The players take turns. board[0][0] = \u0026quot;X\u0026quot; board[2][2] = \u0026quot;O\u0026quot; board[1][2] = \u0026quot;X\u0026quot; board[1][0] = \u0026quot;O\u0026quot; board[0][2] = \u0026quot;X\u0026quot; fmt.Println(len(board)) fmt.Println((board[0])) // strings.Join -\u0026gt; string // func append(s []T, vs ...T) []T for i := 0; i \u0026lt; len(board); i++ { fmt.Printf(\u0026quot;%s\\n\u0026quot;, strings.Join(board[i], \u0026quot; \u0026quot;)) } var s []int printSlice(s) if s == nil { fmt.Println(\u0026quot;nil slice!\u0026quot;) } // append works on nil slices. s = append(s, 0) printSlice(s) if s == nil { fmt.Println(\u0026quot;nil slice!\u0026quot;) } // The slice grows as needed. s = append(s, 1) printSlice(s) // We can add more than one element at a time. s = append(s, 2, 3, 4) printSlice(s) // range =\u0026gt; iterator // for 문 하고 같이 쓰이니까 그냥 하나의 문법이라고 보는게 맞을듯 var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} for i, v := range pow { fmt.Printf(\u0026quot;2**%d = %d\\n\u0026quot;, i, v) } for i:=0; i\u0026lt;len(pow); i++ { fmt.Printf(\u0026quot;2**%d = %d\\n\u0026quot;, i, pow[i]) } fmt.Printf(\u0026quot;this is range\\n\u0026quot;) for i, d := range pow { res := math.Pow(2, float64(i)) fmt.Printf(\u0026quot;2**%d = %d == %f\\n\u0026quot;, i,d,res) } fmt.Println() fmt.Printf(\u0026quot;this is just for loop\\n\u0026quot;) for i:=0; i\u0026lt;len(pow); i++ { res := math.Pow(2, float64(i)) fmt.Printf(\u0026quot;2**%d = %d == %f\\n\u0026quot;, i, pow[i], res) } // 이거 좋은 구문인듯, 2 거듭제곱을 이런식으로 구한다는게 비트연산이라서 좋을듯 // 확실히 이런 부분을 좀 배우면 좋을텐데... pow := make([]int, 10) for i := range pow { pow[i] = 1 \u0026lt;\u0026lt; uint(i) // == 2**i } for _, value := range pow { fmt.Printf(\u0026quot;%d\\n\u0026quot;, value) } type Gps struct { Lat, Long float64 } var m map[string]Gps m = make(map[string]Gps) m[\u0026quot;Bell Labs\u0026quot;] = Gps{ 40.68433, -74.39967, } fmt.Println(m[\u0026quot;Bell Labs\u0026quot;]) var m = map[string]Gps{ \u0026quot;Bell Labs\u0026quot;: Vertex{ 40.68433, -74.39967, }, \u0026quot;Google\u0026quot;: { 37.42202, -122.08408},} msi := make(map[string]int) msi[\u0026quot;Answer\u0026quot;] = 42 fmt.Println(\u0026quot;The value:\u0026quot;, msi[\u0026quot;Answer\u0026quot;]) msi[\u0026quot;Answer\u0026quot;] = 48 fmt.Println(\u0026quot;The value:\u0026quot;, msi[\u0026quot;Answer\u0026quot;]) delete(msi, \u0026quot;Answer\u0026quot;) fmt.Println(\u0026quot;The value:\u0026quot;, msi[\u0026quot;Answer\u0026quot;]) val, ok := msi[\u0026quot;Answer\u0026quot;] fmt.Println(\u0026quot;The value:\u0026quot;, val, \u0026quot;Present?\u0026quot;, ok) hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Printf(\u0026quot;type is %T\\n\u0026quot;,hypot) fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow)) pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println( pos(i), neg(-2*i), ) } /* 또 싫어하는 점 발견... 세미콜론은 강제하지 않으면서 struct 의 콤마는 강제 됨... 콤마 안하면 에러남... 콤마 대신 {} 중괄호 블록을 닫으면 에러 안남. 진짜 이상한데도 간단해서 사람들이 쓰는건가? javascript 나 lisp 처럼? 차라리 rust 를 쓰겠다. 웹은 대체제가 따로 없고 그냥 트랜스파일러? 트랜스 컴파일러만 있을뿐이고... lisp 는 문법이 워낙 단순하지만 해석하기가 좀 힘든 면이 있어서... 진짜 극도의 단순함을 추구하는 변태적인 언어라고 해야하나... haskell 도 따지고 보면 엄밀한 순수함을 따지는 변태고... 언어라는게 다 그렇지뭐... rust도 안해봐서 그렇지 막상 배우면 또 뭔가 있을지는 모르겠다. 근데 ownership 에 너무 반해서 또 빨리 배우고 싶은 마음도 공존함. */ /* A slice is formed by specifying two indices, a low and high bound, separated by a colon: a[low : high] #slice-2 아무튼 그래도 정리를 하자면, capacity 라는 개념은 low bound 에만 영향을 받는다 high bound 에는 아무런 영향이 없다 length 라는 개념은 low bound, high bound 모두의 영향을 받는다 The zero value of a slice is nil. A nil slice has a length and capacity of 0 and has no underlying array. */ /* #slice-1 여기서 내가 go를 싫어하는 이유 계산 방식이 통일되지않고 좌우가 다르다 어떤 느낌이냐면, 나중에 gob 이라는 라이브러리에서 인코딩 할때는 비어있는 버퍼를 인코더 영역으로 지정하고 b 라는 변수를 인코딩해서 저장한다 (여기서 b 는 Block이라는 타입의 포인터 =\u0026gt; 즉, 주소) var res bytes.Buffer encoder := gob.NewEncoder(\u0026amp;res) err := encoder.Encode(b) 그리고 디코딩 할때는 data의 스트림을 받아서 디코더 객체로 만듬 그리고나서 만들어진 객체를 디코딩하는데, 이때 비어있는 block 이라는 변수의 주소에 집어넣음 (여기서 block 은 Block이라는 타입의 값 =\u0026gt; 주소 아님) var block Block decoder := gob.NewDecoder(bytes.NewReader(data)) err := decoder.Decode(\u0026amp;block) 참고: binary 라이브러리 쓸떄, .BigEndian 은 인자 순서대로 들어가고, .LittleEndian 은 인자의 역순으로 들어감 그래서 랭귀지가 프로그래머에 맞추는게 아니라, 프로그래머가 랭귀지에 맞춰야하는 어이없는 상황이 생긴다 함수형 언어처럼 여러 제약에 적응해서 얻는게 많으면 몰라도, 이건 그냥 언어 자체가 주는 혼란때문에 얻는것도 없이 헷갈리게 된다 차라리 아예 자유도를 높이려면 clojure 처럼 아예 규칙이 몇개 없던지, (심플해서 코드는 빨리 읽는데, 코드를 이해하기가 어렵다 컴퓨터는 이해하기 쉬울듯) haskell이나 rust 처럼 아예 자유도를 제한해서 표현력을 잃는 대신, 깔끔함과 안정성을 확보하는게 낫다고 생각한다 (코드를 읽기는 어려운 대신, 이해하는건 상대적으로 쉽다 인간이 이해하기 쉬운 수학과 유사한 문법) */ } func compute(fn func(float64, float64) float64) float64 { return fn(3, 4) } func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func printSlice(s []int) { fmt.Printf(\u0026quot;len=%d cap=%d %v\\n\u0026quot;, len(s), cap(s), s) } func printSliceAndString(s string, x []int) { fmt.Printf(\u0026quot;%s len=%d cap=%d %v\\n\u0026quot;, s, len(x), cap(x), x) }   Note:\n  세미콜론 없음 기본 타입: bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // uint8의 별칭 rune // int32의 별칭 // 유니코드에서 code point를 의미합니다. float32 float64 complex64 complex128   초기값: zero value 는 다음과 같습니다. 숫자 type에는 0 boolean type에는 false string에는 \u0026quot;\u0026quot; (빈 문자열) 추가: slice 기본값은 nil slice ~~(넥 슬라이스!)~~ 포인터 기본값도 nil 포인터 \u0026lt;nil\u0026gt;   타입 변환 var i int = 42 var f float64 = float64(i) var u uint = uint(f) // 혹은 좀 더 간단히: i := 42 f := float64(i) u := uint(f)   반복문은 for 밖에 없음.  () 괄호 없고, {} 필수!    질문 리스트  이해가 100퍼센트 안됨. Numeric Constants Numeric constants are high-precision values. An untyped constant takes the type needed by its context. Try printing needInt(Big) too. (An int can store at maximum a 64-bit integer, and sometimes less.) 숫자형 상수 숫자형 상수는 매우 정확한 값 입니다. type이 정해지지 않은 상수는 그것의 문맥에서 필요한 type을 취합니다. needInt(Big) 을 출력해보세요. (int 는 최대 64-bit 혹은 때때로 더 작은 정수를 저장할 수 있습니다.)   클로저 좀더 해야됨  퀴즈  array 와 slice 차이는? range 문법을 map 에 적용하면? 아래 상황에서는 어떻게 될까?  var sum = 0 func adder() func(int) int { var sum = 0 return func(x int) int { sum += x return sum } } func main() { pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println( pos(i), neg(-2*i), ) } }  ","date":"2021-07-15T13:19:21+09:00","permalink":"https://wadro.github.io/memo/cs/go/lab-golang-study-tutorials-01/","tags":["golang","go"],"title":"lab golang study tutorials 01"},{"categories":["likelion"],"contents":"아이디어톤 PPT ideathon ideathon(remote control version)\n","date":"2021-05-16T17:11:49+09:00","permalink":"https://wadro.github.io/slide/likelion/likelion-week1/","tags":["ideathon"],"title":"likelion week1"},{"categories":["hugo"],"contents":"Introduction One morning, when Gregor Samsa woke from troubled dreams, he found himself transformed in his bed into a horrible vermin.\nMy Heading He lay on his armour-like back, and if he lifted his head a little he could see his brown belly, slightly domed and divided by arches into stiff sections. The bedding was hardly able to cover it and seemed ready to slide off any moment.\nMy Subheading A collection of textile samples lay spread out on the table - Samsa was a travelling salesman - and above it there hung a picture that he had recently cut out of an illustrated magazine and housed in a nice, gilded frame. It showed a lady fitted out with a fur hat and fur boa who sat upright, raising a heavy fur muff that covered the whole of her lower arm towards the viewer. Gregor then turned to look out the window at the dull weather. Drops\nhead6 heading1 heading2 anc1 head3 head4 head5 head6 heading2  Level 1 folder  Level 2 file Level 2 folder  Level 3 file Level 3 folder  Level 4 file   Level 3 folder  Level 4 file Level 4 file   Level 3 file   Level 2 folder  Level 3 file Level 3 file Level 3 file   Level 2 file   Level 1 file  \r   Syntax Description     Header Title   Paragraph Text     Selling point one Selling point two Selling point three  \r The Sun is the star at the center of the Solar System. It is a nearly perfect sphere of hot plasma, with internal convective motion that generates a magnetic field via a dynamo process. It is by far the most important source of energy for life on Earth. Credits.\n  latex 부호가 있는 경우, \\( -(2^{n-1}) \\) 부터 \\( 2^{n-1} \\)\n$$ -(2^{n-1}) $$ $$ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $$ $$ 2^2 $$\n","date":"2021-04-28T07:00:19+09:00","permalink":"https://wadro.github.io/post/heading/","tags":["hugo shortcuts"],"title":"Heading"},{"categories":["블로그"],"contents":"hugo 블로그 만들기 (windows \u0026amp; cupper theme 기준)    choco install hugo -confirm (powershell 관리자로 실행 후)\n  hugo new site (블로그 파일 모아 놓을 폴더 이름) e.g. hugo new site blog\n  cd (블로그 파일 모아 놓을 폴더 이름) e.g. cd blog\n  git init\n이 부분은 각자 쓰고 싶은 테마를 찾아볼것.여기서 -\u0026gt; git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git\nthemes/ananke\n  hugo new posts/(쓰고싶은이름).md\n  터미널(powershell)에 hugo 엔터 누르면 markdown 으로 작성된 파일이 알아서 html,css,js 파일로 변환됨.\n  hugo server 로 테스트 가능.\n  이후 각자 편한 방식으로 업로드 e.g. 아이디.github.io repository 로 업로드하면 홈페이지 완성!\n  config.toml 은 중요하기때문에 따로 포스팅 하도록 하겠음.\n  ","date":"2021-04-28T05:56:50+09:00","permalink":"https://wadro.github.io/post/hugo/hugo-tutorials/","tags":["hugo","tips"],"title":"Hugo Tutorials"},{"categories":null,"contents":"Hi! I\u0026rsquo;m studying Information Commucation, Electronics \u0026amp; Computer Science\nDetails   Information Technology\n 📌 Blockchain 📌 Operating System 📌 Network 📌 Electronics    Social Science\n 📌 Economics 📌 Accounting 📌 IPRs(Intellectual Property Rights) 📌 Philosophies(Western)    news/media/press\n newstof - http://www.newstof.com/ lemonde - https://www.ilemonde.com/ 데이터 저널리즘    languages\n korean english japanese (basic) franch (want to learn) (constructed language)    etc (interests)\n watching masterpiece(books, movies, animation) music (piano) water sports(swimming, skin\u0026amp;scuba diving) martial arts(boxing) comics    want to learn\n harmonica, drum, ukulele tackyeon, jujitsu biology mechanics mechatronics    ","date":"2021-04-28T05:52:11+09:00","permalink":"https://wadro.github.io/about/","tags":null,"title":"About"}]