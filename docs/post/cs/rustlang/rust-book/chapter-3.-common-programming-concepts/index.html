<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.86.0" />
  <link rel="canonical" href="/post/cs/rustlang/rust-book/chapter-3.-common-programming-concepts/">

  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <style>
    body {
      visibility: hidden;
      opacity: 0;
    }
  </style>

  <link rel="stylesheet" href="/css/prism.css" media="none" onload="this.media='all';">

  
  
  <link rel="stylesheet" type="text/css" href="/css/styles.css">

  
    <link rel="stylesheet" href="/css/custom.css">
  

  
  
  <title>Chapter 3  Common Programming Concepts | WADRO</title>
</head>

  <body>
    <a href="#main">skip to content</a>
    <noscript>
  <style>
    body {
      visibility: visible;
      opacity: 1;
    }
  </style>
</noscript>

    <svg style="display: none">
  <symbol id="bookmark" viewBox="0 0 40 50">
   <g transform="translate(2266 3206.2)">
    <path style="stroke:currentColor;stroke-width:3.2637;fill:none" d="m-2262.2-3203.4-.2331 42.195 16.319-16.318 16.318 16.318.2331-42.428z"/>
   </g>
  </symbol>

  <symbol id="w3c" viewBox="0 0 127.09899 67.763">
   <text font-size="83" style="font-size:83px;font-family:Trebuchet;letter-spacing:-12;fill-opacity:0" letter-spacing="-12" y="67.609352" x="-26.782778">W3C</text>
   <text font-size="83" style="font-size:83px;font-weight:bold;font-family:Trebuchet;fill-opacity:0" y="67.609352" x="153.21722" font-weight="bold">SVG</text>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m33.695.377 12.062 41.016 12.067-41.016h8.731l-19.968 67.386h-.831l-12.48-41.759-12.479 41.759h-.832l-19.965-67.386h8.736l12.061 41.016 8.154-27.618-3.993-13.397h8.737z"/>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m91.355 46.132c0 6.104-1.624 11.234-4.862 15.394-3.248 4.158-7.45 6.237-12.607 6.237-3.882 0-7.263-1.238-10.148-3.702-2.885-2.47-5.02-5.812-6.406-10.022l6.82-2.829c1.001 2.552 2.317 4.562 3.953 6.028 1.636 1.469 3.56 2.207 5.781 2.207 2.329 0 4.3-1.306 5.909-3.911 1.609-2.606 2.411-5.738 2.411-9.401 0-4.049-.861-7.179-2.582-9.399-1.995-2.604-5.129-3.912-9.397-3.912h-3.327v-3.991l11.646-20.133h-14.062l-3.911 6.655h-2.493v-14.976h32.441v4.075l-12.31 21.217c4.324 1.385 7.596 3.911 9.815 7.571 2.22 3.659 3.329 7.953 3.329 12.892z"/>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m125.21 0 1.414 8.6-5.008 9.583s-1.924-4.064-5.117-6.314c-2.693-1.899-4.447-2.309-7.186-1.746-3.527.73-7.516 4.938-9.258 10.13-2.084 6.21-2.104 9.218-2.178 11.978-.115 4.428.58 7.043.58 7.043s-3.04-5.626-3.011-13.866c.018-5.882.947-11.218 3.666-16.479 2.404-4.627 5.954-7.404 9.114-7.728 3.264-.343 5.848 1.229 7.841 2.938 2.089 1.788 4.213 5.698 4.213 5.698l4.94-9.837z"/>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m125.82 48.674s-2.208 3.957-3.589 5.48c-1.379 1.524-3.849 4.209-6.896 5.555-3.049 1.343-4.646 1.598-7.661 1.306-3.01-.29-5.807-2.032-6.786-2.764-.979-.722-3.486-2.864-4.897-4.854-1.42-2-3.634-5.995-3.634-5.995s1.233 4.001 2.007 5.699c.442.977 1.81 3.965 3.749 6.572 1.805 2.425 5.315 6.604 10.652 7.545 5.336.945 9.002-1.449 9.907-2.031.907-.578 2.819-2.178 4.032-3.475 1.264-1.351 2.459-3.079 3.116-4.108.487-.758 1.276-2.286 1.276-2.286l-1.276-6.644z"/>
  </symbol>

  <symbol id="tag" viewBox="0 0 177.16535 177.16535">
    <g transform="translate(0 -875.2)">
     <path style="fill-rule:evenodd;stroke-width:0;fill:currentColor" d="m159.9 894.3-68.79 8.5872-75.42 77.336 61.931 60.397 75.429-76.565 6.8495-69.755zm-31.412 31.835a10.813 10.813 0 0 1 1.8443 2.247 10.813 10.813 0 0 1 -3.5174 14.872l-.0445.0275a10.813 10.813 0 0 1 -14.86 -3.5714 10.813 10.813 0 0 1 3.5563 -14.863 10.813 10.813 0 0 1 13.022 1.2884z"/>
    </g>
  </symbol>

  <symbol id="balloon" viewBox="0 0 141.73228 177.16535">
   <g transform="translate(0 -875.2)">
    <g>
     <path style="fill:currentColor" d="m68.156 882.83-.88753 1.4269c-4.9564 7.9666-6.3764 17.321-5.6731 37.378.36584 10.437 1.1246 23.51 1.6874 29.062.38895 3.8372 3.8278 32.454 4.6105 38.459 4.6694-.24176 9.2946.2879 14.377 1.481 1.2359-3.2937 5.2496-13.088 8.886-21.623 6.249-14.668 8.4128-21.264 10.253-31.252 1.2464-6.7626 1.6341-12.156 1.4204-19.764-.36325-12.93-2.1234-19.487-6.9377-25.843-2.0833-2.7507-6.9865-7.6112-7.9127-7.8436-.79716-.20019-6.6946-1.0922-6.7755-1.0248-.02213.0182-5.0006-.41858-7.5248-.22808l-2.149-.22808h-3.3738z"/>
     <path style="fill:currentColor" d="m61.915 883.28-3.2484.4497c-1.7863.24724-3.5182.53481-3.8494.63994-2.4751.33811-4.7267.86957-6.7777 1.5696-.28598 0-1.0254.20146-2.3695.58589-5.0418 1.4418-6.6374 2.2604-8.2567 4.2364-6.281 7.6657-11.457 18.43-12.932 26.891-1.4667 8.4111.71353 22.583 5.0764 32.996 3.8064 9.0852 13.569 25.149 22.801 37.517 1.3741 1.841 2.1708 2.9286 2.4712 3.5792 3.5437-1.1699 6.8496-1.9336 10.082-2.3263-1.3569-5.7831-4.6968-21.86-6.8361-33.002-.92884-4.8368-2.4692-14.322-3.2452-19.991-.68557-5.0083-.77707-6.9534-.74159-15.791.04316-10.803.41822-16.162 1.5026-21.503 1.4593-5.9026 3.3494-11.077 6.3247-15.852z"/>
     <path style="fill:currentColor" d="m94.499 885.78c-.10214-.0109-.13691 0-.0907.0409.16033.13489 1.329 1.0675 2.5976 2.0723 6.7003 5.307 11.273 14.568 12.658 25.638.52519 4.1949.24765 14.361-.5059 18.523-2.4775 13.684-9.7807 32.345-20.944 53.519l-3.0559 5.7971c2.8082.76579 5.7915 1.727 8.9926 2.8441 11.562-11.691 18.349-19.678 24.129-28.394 7.8992-11.913 11.132-20.234 12.24-31.518.98442-10.02-1.5579-20.876-6.7799-28.959-.2758-.4269-.57803-.86856-.89617-1.3166-3.247-6.13-9.752-12.053-21.264-16.131-2.3687-.86369-6.3657-2.0433-7.0802-2.1166z"/>
     <path style="fill:currentColor" d="m32.52 892.22c-.20090-.13016-1.4606.81389-3.9132 2.7457-11.486 9.0476-17.632 24.186-16.078 39.61.79699 7.9138 2.4066 13.505 5.9184 20.562 5.8577 11.77 14.749 23.219 30.087 38.74.05838.059.12188.1244.18052.1838 1.3166-.5556 2.5965-1.0618 3.8429-1.5199-.66408-.32448-1.4608-1.3297-3.8116-4.4602-5.0951-6.785-8.7512-11.962-13.051-18.486-5.1379-7.7948-5.0097-7.5894-8.0586-13.054-6.2097-11.13-8.2674-17.725-8.6014-27.563-.21552-6.3494.13041-9.2733 1.775-14.987 2.1832-7.5849 3.9273-10.986 9.2693-18.07 1.7839-2.3656 2.6418-3.57 2.4409-3.7003z"/>
     <path style="fill:currentColor" d="m69.133 992.37c-6.2405.0309-12.635.76718-19.554 2.5706 4.6956 4.7759 9.935 10.258 12.05 12.625l4.1272 4.6202h11.493l3.964-4.4516c2.0962-2.3541 7.4804-7.9845 12.201-12.768-8.378-1.4975-16.207-2.6353-24.281-2.5955z"/>
     <rect style="stroke-width:0;fill:currentColor" ry="2.0328" height="27.746" width="22.766" y="1017.7" x="60.201"/>
    </g>
   </g>
  </symbol>

  <symbol id="info" viewBox="0 0 41.667 41.667">
   <g transform="translate(-37.035 -1004.6)">
    <path style="stroke-linejoin:round;stroke:currentColor;stroke-linecap:round;stroke-width:3.728;fill:none" d="m76.25 1030.2a18.968 18.968 0 0 1 -23.037 13.709 18.968 18.968 0 0 1 -13.738 -23.019 18.968 18.968 0 0 1 23.001 -13.768 18.968 18.968 0 0 1 13.798 22.984"/>
    <g transform="matrix(1.1146 0 0 1.1146 -26.276 -124.92)">
     <path style="stroke:currentColor;stroke-linecap:round;stroke-width:3.728;fill:none" d="m75.491 1039.5v-8.7472"/>
     <path style="stroke-width:0;fill:currentColor" transform="scale(-1)" d="m-73.193-1024.5a2.3719 2.3719 0 0 1 -2.8807 1.7142 2.3719 2.3719 0 0 1 -1.718 -2.8785 2.3719 2.3719 0 0 1 2.8763 -1.7217 2.3719 2.3719 0 0 1 1.7254 2.8741"/>
    </g>
   </g>
  </symbol>

  <symbol id="warning" viewBox="0 0 48.430474 41.646302">
    <g transform="translate(-1.1273 -1010.2)">
     <path style="stroke-linejoin:round;stroke:currentColor;stroke-linecap:round;stroke-width:4.151;fill:none" d="m25.343 1012.3-22.14 37.496h44.28z"/>
     <path style="stroke:currentColor;stroke-linecap:round;stroke-width:4.1512;fill:none" d="m25.54 1027.7v8.7472"/>
     <path style="stroke-width:0;fill:currentColor" d="m27.839 1042.8a2.3719 2.3719 0 0 1 -2.8807 1.7143 2.3719 2.3719 0 0 1 -1.718 -2.8785 2.3719 2.3719 0 0 1 2.8763 -1.7217 2.3719 2.3719 0 0 1 1.7254 2.8741"/>
    </g>
  </symbol>

  <symbol id="menu" viewBox="0 0 50 50">
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="0" x="0"/>
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="20" x="0"/>
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="40" x="0"/>
   </symbol>

   <symbol id="link" viewBox="0 0 50 50">
    <g transform="translate(0 -1002.4)">
     <g transform="matrix(.095670 0 0 .095670 2.3233 1004.9)">
      <g>
       <path style="stroke-width:0;fill:currentColor" d="m452.84 192.9-128.65 128.65c-35.535 35.54-93.108 35.54-128.65 0l-42.881-42.886 42.881-42.876 42.884 42.876c11.845 11.822 31.064 11.846 42.886 0l128.64-128.64c11.816-11.831 11.816-31.066 0-42.9l-42.881-42.881c-11.822-11.814-31.064-11.814-42.887 0l-45.928 45.936c-21.292-12.531-45.491-17.905-69.449-16.291l72.501-72.526c35.535-35.521 93.136-35.521 128.64 0l42.886 42.881c35.535 35.523 35.535 93.141-.001 128.66zm-254.28 168.51-45.903 45.9c-11.845 11.846-31.064 11.817-42.881 0l-42.884-42.881c-11.845-11.821-11.845-31.041 0-42.886l128.65-128.65c11.819-11.814 31.069-11.814 42.884 0l42.886 42.886 42.876-42.886-42.876-42.881c-35.54-35.521-93.113-35.521-128.65 0l-128.65 128.64c-35.538 35.545-35.538 93.146 0 128.65l42.883 42.882c35.51 35.54 93.11 35.54 128.65 0l72.496-72.499c-23.956 1.597-48.092-3.784-69.474-16.283z"/>
      </g>
     </g>
    </g>
  </symbol>

  <symbol id="doc" viewBox="0 0 35 45">
   <g transform="translate(-147.53 -539.83)">
    <path style="stroke:currentColor;stroke-width:2.4501;fill:none" d="m149.38 542.67v39.194h31.354v-39.194z"/>
    <g style="stroke-width:25" transform="matrix(.098003 0 0 .098003 133.69 525.96)">
     <path d="m220 252.36h200" style="stroke:currentColor;stroke-width:25;fill:none"/>
     <path style="stroke:currentColor;stroke-width:25;fill:none" d="m220 409.95h200"/>
     <path d="m220 488.74h200" style="stroke:currentColor;stroke-width:25;fill:none"/>
     <path d="m220 331.15h200" style="stroke:currentColor;stroke-width:25;fill:none"/>
    </g>
   </g>
 </symbol>

 <symbol id="tick" viewBox="0 0 177.16535 177.16535">
  <g transform="translate(0 -875.2)">
   <rect style="stroke-width:0;fill:currentColor" transform="rotate(30)" height="155" width="40" y="702.99" x="556.82"/>
   <rect style="stroke-width:0;fill:currentColor" transform="rotate(30)" height="40" width="90.404" y="817.99" x="506.42"/>
  </g>
 </symbol>
</svg>

    <div class="wrapper">
      <header class="intro-and-nav" role="banner">
  <div>
    <div class="intro">
      <a
        class="logo"
        href="https://wadro.github.io"
        aria-label="WADRO home page"
      >
        <img src="/images/oceandrop.png" alt="">
      </a>
      

      <p class="library-desc">
        
      </p>
    </div>
    
    <div id="clientSearch">
      <input id="searchInput" tabindex="0" placeholder="&#x1F50E;&#xFE0E;">
      <ul id="searchResults">
      </ul>
    </div>
    
    
    <nav id="patterns-nav" class="patterns" role="navigation">
  <h2 class="vh">Main navigation</h2>
  <button id="menu-button" aria-expanded="false">
    <svg viewBox="0 0 50 50" aria-hidden="true" focusable="false">
      <use xlink:href="#menu"></use>
    </svg>
    Menu
  </button>
  
  
  <ul id="patterns-list">
  
    <li class="pattern">
      
      
      
      
      <a href="/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Home</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="/post/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Post</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="/slide/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Slide</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="/categories/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Category</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="/tags/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Tag</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="/about/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">About</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="/index.xml" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">RSS</span>
      </a>
    </li>
  
  </ul>
</nav>

    
      <footer role="contentinfo">
  <div
  
  >
    <label for="themer">
      dark theme: <input type="checkbox" id="themer" class="vh">
      
      <span aria-hidden="true"></span>
    </label>
  </div>
  
  
    Here you can <a href="https://www.buymeacoffee.com/wadro">Support Me!</a>.
  
  
  
</footer>


    

  </div>
  
</header>

 
      <div class="main-and-footer line-numbers match-braces">
        <div id="topofpage">
          
  <main id="main">
    <h1>
      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
        <use xlink:href="#bookmark"></use>
      </svg>
      Chapter 3  Common Programming Concepts
    </h1>

    <div class="date">
      
      
      <strong>Publish date: </strong>Aug 2, 2021
      
        
      
    </div>

    
      <div class="tags">
        <strong>Categories: </strong>
        <ul aria-label="tags">
          
            <li>
              <svg class="tag-icon" aria-hidden="true" viewBox="0 0 177.16535 177.16535" focusable="false">
                <use xlink:href="#doc"></use>
              </svg>
              
              <a href="/categories/cs/">cs</a>
            </li>
          
        </ul>
      </div>
    

    
      <div class="tags">
        <strong>Tags: </strong>
        <ul aria-label="tags">
          
            <li>
              <svg class="tag-icon" aria-hidden="true" viewBox="0 0 177.16535 177.16535" focusable="false">
                <use xlink:href="#tag"></use>
              </svg>
              
              <a href="/tags/rust/">rust</a>
            </li>
          
            <li>
              <svg class="tag-icon" aria-hidden="true" viewBox="0 0 177.16535 177.16535" focusable="false">
                <use xlink:href="#tag"></use>
              </svg>
              
              <a href="/tags/%EB%9F%AC%EC%8A%A4%ED%8A%B8-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/">러스트 튜토리얼</a>
            </li>
          
        </ul>
      </div>
    

    
      <div class="tags">
        <strong>Series: </strong>
        <ul aria-label="tags">
          
            <li>
              <svg class="tag-icon" aria-hidden="true" viewBox="0 0 177.16535 177.16535" focusable="false">
                <use xlink:href="#balloon"></use>
              </svg>
              
              <a href="/series/rust-book/">rust book</a>
            </li>
          
        </ul>
      </div>
    
    
    
      

  <nav class="toc" aria-labelledby="toc-heading">
    <h2 id="toc-heading">Table of contents</h2>
    <ol>
      
        <li>
          
          
          
          
          <a href="#%eb%b3%80%ec%88%98-%ec%84%a0%ec%96%b8">
            변수 선언
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#%eb%8d%b0%ec%9d%b4%ed%84%b0-%ed%83%80%ec%9e%85">
            데이터 타입
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#functions">
            Functions
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#comments">
            Comments
          </a>
        </li>
      
        <li>
          
          
          
          
          <a href="#control-flow">
            Control Flow
          </a>
        </li>
      
    </ol>
  </nav>


    

    

    <h2 id="변수-선언">변수 선언</h2>
<p>기본적으로 rust 의 변수는 immutable 합니다. 즉, 변하지 않는 값이 되죠.<br>
(c 나 여러 언어에서 const 키워드를 사용하는 것과 같습니다. 기본 변수 타입이 const 인 셈이죠.)</p>
<p>이걸 통해 안전성과 쉬운 병렬성을 달성할수가 있게됩니다.(왜 그런지는 배우면서 차차 알수 있겠죠. 저도 아직 모름&hellip;)<br>
물론, 변하는 값으로 설정하는 방법도 있습니다.<br>
이제부터 왜 그렇게 설계했는지를 살펴봅시다.</p>
<p>먼저 변수를 선언하고나면, 그 이름을 가진 변수의 값을 바꿀수 없습니다.<br>
한번 예시를 통해 살펴 볼게요.</p>
<pre><code class="language-rust">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}

</code></pre>
<p><code>cargo check</code> (또는 <code>cargo run</code>)을 해보면, 에러메세지가 나올겁니다.<br>
앞으로는 물론, 아마도 평생(?!) 러스트 코드를 짜다보면 에러메세지를 만날텐데요,<br>
실망하지마세요. 이건 아직 우리의 코드가 원하는 동작을 하기 위해 준비가 필요하다는 의미에 불과합니다.<br>
보다 안전한 실행을 위해 꼼꼼히 체크하는 것입니다.</p>
<p>에러메세지는 이렇게 나올텐데요,<br>
<code>cannot assign twice to immutable variable x</code><br>
우리가 x 변수에 다른 값을 넣으려고 해서 그렇습니다.</p>
<p>우리가 불변값으로 지정했던 값을 바꾸려고 할때 컴파일-타임 에러는 중요합니다.<br>
바로 이런 상황이 버그로 이어질수 있기 때문이죠.<br>
만약 우리 코드 중 일부가, 값이 절대 변하지 않을거야! 라는 가정 하에 실행되는데<br>
다른 코드가 그 값을 바꾸려고 한다면, 원래 예상했던 동작이 일어나지 않겠죠.<br>
이런 종류의 버그는 발생하고 나면 추적하기 어려울수도 있는게,<br>
값을 바꾸는 일이 정말 가끔씩만 일어나기 때문입니다.</p>
<p>우리가 이 값은 절대 바뀌지 않을거야! 라고 한다면, 진짜 바뀌지 않습니다.<br>
러스트에서는 컴파일러가 이런 일들을 보장해줍니다.</p>
<p>이게 뭘 의미하냐면,<br>
우리가 코드를 읽고, 쓸때,<br>
값이 언제 변할지를 신경쓰지 않아도 된다는 의미입니다.<br>
따라서 코드를 추론하기가 더 쉬워지는 것이죠.</p>
<p>하지만 변하는 값도 아주 유용하죠.<br>
<del>(사실 실제 하드웨어에서는 메모리가 수시로 바뀌니까요)</del><br>
변수가 불변하는게 기본이지만, <code>mut</code> 키워드를 쓰면 변하게 만들수도 있습니다.<br>
단지 변하게 하는것 외에도, <code>mut</code> 키워드는 마치 책갈피 처럼,<br>
내가 가리키는 지금 이 부분이 변할거야! 라는 의도를,<br>
코드를 읽는 독자에게 전달해 줄수도 있습니다.</p>
<p>코드를 이렇게 바꿔볼까요?</p>
<h6 class="codeblock" id="mutablers"><strong><code>mutable.rs</code></strong></h6>
<pre><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}

</code></pre>
<p>결과는 이렇게 나오겠죠.</p>
<pre><code>$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6

</code></pre>
<p><code>mut</code> 키워드를 쓰면 <code>x</code>가 들고 있던 값을 <code>5</code> 에서 <code>6</code> 으로 변하게 할수 있도록 해줍니다.<br>
몇몇 경우에서 우리는 굉장히 편리하다는 이유로,<br>
불변하는 값만 쓰기보다는,<br>
변하는 변수를 쓰는 유혹을 많이 받으실텐데요. <del>(근데 변수 원래 뜻이 변할수 있는 수 아니야?)</del></p>
<p>단지 버그를 방지하기 위해서뿐만 아니라,<br>
고려해야할 몇가지 트레이드 오프(일장일단, 절충안)가 있습니다.</p>
<p>예를 들면 큰 데이터 구조를 사용하는 경우에는<br>
복사하고 다시 새로 할당된 인스턴스를 리턴 하기 보다,<br>
그 자리에서 바로 값을 바꿔버리는게 빠를수도 있습니다.</p>
<p>작은 데이터 구조에서는,<br>
새로운 인스턴스를 만들고, 함수형 프로그래밍 스타일로 작성하는것이 더 생각를 이어가기에 쉬울수 있기때문에,<br>
조금 성능을 희생하더라도, 명확성을 얻을수 있다는 장점을 가져갈수 있습니다.</p>
<h3 id="변수와-상수의-차이">변수와 상수의 차이</h3>
<p>변수의 값을 바꿀수 없다는 개념은, &ldquo;상수&quot;에 대해서 다시 생각해보게 합니다.<br>
불변하는 변수와 같이, 상수도 어떤 이름에 할당된 변하지않는 값이지만,<br>
조금 다른 점들이 있습니다.</p>
<p>가령, <code>mut</code> 키워드를 상수에는 적용할수 없습니다.<br>
그냥 상수는 항상 불변합니다.</p>
<p>상수는 <code>const</code> 키워드로 선언할수 있습니다.<br>
그리고 반드시 타입을 지정해줘야합니다.<br>
타입에 대한 얘기는 다음 절에 나오니 우선 넘어갑시다.</p>
<p>상수는 전역 변수든 어디 위치에서든 선언 될수 있습니다.<br>
코드의 많은 부분에서 알아야하는 값일 경우 유용합니다.</p>
<p>마지막으로 다른 점은,<br>
상수로 선언하는 방식 외에,<br>
함수 호출의 결과나<br>
런타임시에 계산해야만 알수있는 값은 상수가 될수 없다는 점입니다.</p>
<p>예를 볼까요.<br>
<code>MAX_POINTS</code> 라는 이름의 상수가 100,000 이라는 값을 가지고 있습니다.<br>
(러스트에서 상수 이름을 만들때는 전부 대문자를 사용하고 단어 사이에 언더스코어(_)를 사용합니다.)<br>
(숫자에 대한 가독성을 높히기 위해 사용되기도 합니다.)</p>
<pre><code class="language-rust">#![allow(unused)]
fn main() {
const MAX_POINTS: u32 = 100_000;
}
</code></pre>
<p>상수는 프로그램이 실행되는 동안, 선언된 스코프 내에서 유효하기때문에,<br>
애플리케이션 영역에서, 프로그램의 여러 파트에서 알아야할 값들,<br>
게임 플레이어가 모아야하는 최대 점수라던가, 빛의 속도와 같은 경우에 유용합니다.</p>
<p>의미있는 이름으로 하드코딩된 값은<br>
다른 메인테이너(코드 유지 보수하는 사람)에게 코드를 보여줄때 요긴하게 사용될수 있습니다.</p>
<p>또한 나중에 하드코딩된 값을 바꿔야 할 경우에, 한 부분만 바꾸면 되는 이점을 제공합니다.</p>
<h3 id="쉐도잉">쉐도잉</h3>
<p>원래 선언했던 변수 이름으로 다시 설정 가능합니다.<br>
이럴때 러스트에서는 shadowed(가려졌다) 되었다고 말합니다.<br>
예시를 보면서 설명해볼까요.</p>
<pre><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}

</code></pre>
<p>처음에 <code>x</code> 는 <code>5</code> 라는 값에 묶이죠.<br>
그리고 다시 <code>let</code> 키워드를 통해서 <code>x</code>에 1을 더한 6 이라는 값에 묶입니다.<br>
마지막으로 세번째 선언을 통해 그 값을 2배 하면서 다시 <code>x</code>에는 12 라는 값으로 묶입니다.</p>
<p>쉐도잉(shadowing) 은 <code>mut</code>키워드로 선언된 변수와는 다른데요,<br>
<code>let</code> 키워드를 사용하지않으면 재할당되지 않기 때문입니다.<br>
<code>let</code> 키워드를 사용한 할당 뒤에는 그 값은 불변합니다.</p>
<p>또 다른 <code>mut</code>와 shadowing 의 차이점이라면,<br>
<code>let</code>키워드로 너무나 효과적으로 새로운 변수를 만들수 있기때문에,<br>
같은 이름을 사용한, 다른 타입의 변수를 만들수가 있습니다.</p>
<p>예를 들어, 유저에게 공백문자를 넣어 텍스트 사이에 몇 개의 공백을 원하는지 보여달라는 프로그램이 있을때, 그 입력을 숫자로 저장하고 싶다고 생각해봅시다.</p>
<pre><code class="language-rust">let spaces = &quot;   &quot;;
let spaces = spaces.len();
</code></pre>
<p>첫번째 변수는 문자열 타입이고, 두번째 변수는 숫자 타입입니다.<br>
쉐도잉을 사용하면, space_str, space_num 과 같이<br>
다른 이름을 사용하지 않아도 됩니다.</p>
<p>하지만 <code>mut</code> 키워드를 사용해서 위와 같은 작업을 실행하면 에러가 납니다.</p>
<pre><code class="language-rust">let mut spaces = &quot;   &quot;;
spaces = spaces.len();
</code></pre>
<pre><code>$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables`

To learn more, run the command again with --verbose.

</code></pre>
<p>즉, <code>mut</code>키워드를 사용해도 타입은 바꿀수 없다는 겁니다.</p>
<p>자, 이제는 타입에 대한 내용을 다뤄보겠습니다.</p>
<h2 id="데이터-타입">데이터 타입</h2>
<p>러스트에서 모든 변수는 특정한 타입을 가지고 있습니다.<br>
어떤 종류의 데이터가 지정되었는지 알려줌으로써,<br>
어떻게 그 데이터를 처리할지를 알려주는 것이죠.</p>
<p>데이터 타입를 두가지로 나눠서 살펴보겠습니다:<br>
스칼라와 컴파운드</p>
<p>러스트는 정적 타입 언어 라는 사실을 명심하세요.<br>
컴파일 타임에 모든 변수의 타입을 알고 있어야한다는 사실입니다.<br>
컴파일러는 보통 변수의 값과 어떻게 그것을 사용할것인지에 따라 어떤 타입인지를 유추할수 있습니다.</p>
<p>많은 타입이 유추 가능할 경우에,<br>
예를 들면 <code>parse</code>를 사용하여 문자열 타입에서 숫자형 타입으로 바꾸는 경우,<br>
타입 어노테이션(힌트,설명)을 추가해야합니다:</p>
<pre><code class="language-rust">let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
</code></pre>
<p>2021-08-04T14:28:27+09:00
2021-08-05T13:11:53+09:00</p>
<p>만약 타입 어노테이션을 추가하지 않으면 에러가 납니다.<br>
어떤 타입을 사용할것인지 우리에게 물어보는 것이죠.</p>
<pre><code>$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ consider giving `guess` a type

error: aborting due to previous error

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations`

To learn more, run the command again with --verbose.

</code></pre>
<p>다른 데이터 타입들에 대한 어노테이션을 볼까요.</p>
<h3 id="스칼라-타입">스칼라 타입</h3>
<p>스칼라 타입은 단일 값을 나타냅니다.<br>
러스트는 네 가지 기초 스칼라 타입이 있습니다.<br>
integers, floating-point numbers, booleans, characters.<br>
아마 다른 프로그래밍 언어에서 많이 접했을 개념입니다.<br>
하나씩 살펴보죠.</p>
<h4 id="integer-타입">integer 타입</h4>
<p><em>integer</em> 는 소수점이 없는 숫자 입니다.<br>
i32 는 signed integer, u32 는 unsigned integer 입니다.<br>
32비트의 공간을 차지하고, 부호가 있느냐 없느냐의 차이입니다.</p>
<p>Table 3-1: Integer Types in Rust</p>
<table>
<thead>
<tr>
<th>Length</th>
<th>Signed</th>
<th>Unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td>8-bit</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr>
<td>16-bit</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr>
<td>32-bit</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>64-bit</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>128-bit</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>arch</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody>
</table>
<p>명시적인 크기를 가지고, 부호가 있거나 없거나 하는 식의 변형이 있습니다.<br>
부호가 있는 숫자는 <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two&rsquo;s complement</a>(2의 보수) 표기법으로 저장됩니다.</p>
<p>부호가 있는 경우, \( -(2^{n-1}) \) 부터 \( 2^{n-1}-1 \) 이하(포함) 의 값을 저장할수 있습니다.</p>
<p><code>i8</code>의 경우는 -128~127 까지의 값을 저장하죠.</p>
<p>부호가 없는 경우, 0부터 \( 2^{n}-1 \) 의 값을 저장합니다.<br>
<code>u8</code>이면 0 부터 255 까지요.</p>
<p><code>isize</code> ,<code>usize</code> 같은  ~size 의 타입은 사용하는 아키텍처에 따라 달라집니다.<br>
가령, 64비트 아키텍처라면 i64,u64가 되는 것이죠.</p>
<p>정수 표현하는 방식은 아래 표에 나온 것과 같습니다.<br>
바이트 정수를 제외하고 모든 표기에는 접미사(suffix)를 허용합니다.<br>
<code>57u8</code> 이런 식으로요.<br>
그리고 언더스코어(_) 는 구분자로 사용가능합니다.<br>
<code>1_000</code> 이렇게 말이죠.</p>
<p>Table 3-2: Integer Literals in Rust</p>
<table>
<thead>
<tr>
<th>Number literals</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Decimal</td>
<td>98_222</td>
</tr>
<tr>
<td>Hex</td>
<td>0xff</td>
</tr>
<tr>
<td>Octal</td>
<td>0o77</td>
</tr>
<tr>
<td>Binary</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>Byte (u8 only)</td>
<td>b&rsquo;A'</td>
</tr>
</tbody>
</table>
<p>어떤 타입을 사용할지 모르겠다고요?<br>
그렇다면 디폴트 타입인 <code>i32</code> 가 일반적으로 좋은 선택일겁니다.<br>
(제일 빠릅니다(심지어 64비트 시스템에서도))</p>
<p>일종의 컬렉션을 인덱싱할때 주로 <code>isize</code> 나 <code>usize</code>를 사용합니다.<br>
(나중에 이 부분은 다시 살펴 보도록 합시다.)</p>
<blockquote>
<p> </p>
<h4 id="integer-overflow">Integer Overflow</h4>
<p>0에서 255까지 저장할수 있는 <code>u8</code> 타입의 변수를 사용한다고 해볼까요.<br>
만약, 이 범위 밖의 값, 예를 들면 256을 저장하려고 한다면,<br>
<em>integer overflow</em> 가 발생합니다.<br>
러스트에는 이것과 관련된 흥미로운 규칙이 있습니다.<br>
디버그 모드에서 컴파일 할때, 러스트는 integer overflow 를 체크합니다.<br>
만약 런타임에 일어나게 된다면 프로그램이 <em>패닉</em> 에 빠지게 될수 있으니까 말이죠.<br>
러스트는 프로그램이 에러로 종료되면 패닉에 빠졌다는 표현을 사용하는데,<br>
챕터 9에서 이 부분을 좀더 다뤄보도록 하겠습니다.</p>
<p><code>--release</code> 플래그를 붙여서 릴리즈 모드로 컴파일하게 되면,<br>
integer overflow 를 체크하지 않습니다.<br>
대신, 오버플로우가 일어나면, <em>two&rsquo;s complement wrapping</em> 을 실행합니다.<br>
간단히 말해서, 변수가 담을수 있는 최댓값보다 큰 값은, 최솟값으로 &ldquo;감싸집니다(wrapping)&rdquo;.<br>
<code>u8</code>의 경우, 256은 0이 디고, 257은 1이 되는 식입니다. (0 1 &hellip; 255 0 1 &hellip;)<br>
프로그램은 패닉에 빠지지않지만, 원래 예상했던 동작을 하지 않을수도 있습니다.<br>
랩핑에 의존하는것은 에러로 간주됩니다.</p>
<p>명시적으로 오버플로우 가능성을 처리하기 위해,<br>
표준 라이브러리가 기본 숫자 타입에 제공하는 메소드 모음을 사용할수 있습니다.</p>
<ul>
<li>◼ <code>wrapping_add</code>처럼, 모든 모드에서 랩핑하는 <code>wrapping_*</code></li>
<li>◼ 오버플로우가 있으면 <code>None</code> 값을 반환하는 <code>checked_*</code></li>
<li>◼ 값과 오버플로우 여부를 알려주는 boolean 을 반환하는 <code>overflowing_*</code></li>
<li>◼ 값의 최소와 최대값으로 고정되는 (포화) <code>saturating_*</code>
 <br>
 </li>
</ul>
</blockquote>
<h4 id="floating-point-타입">floating-point 타입</h4>
<p>러스트는 부동소수점 숫자를 위한 두가지 기본 타입이 있습니다.<br>
<code>f32</code>와 <code>f64</code> 인데, 각각 32비트와 64비트의 사이즈를 가지고 있습니다.<br>
현대 cpu의 대부분이 64비트를 채용하고 있고, 속도는 비슷한데 더 정밀하기 때문입니다.</p>
<p>예제를 보면서 설명해보죠.</p>
<pre><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre>
<p>부동소수점 숫자는  IEEE-754 표준에 따라 표기 됩니다.<br>
<code>f32</code> 타입은 단일-정밀도 이고, <code>f64</code> 더블-정밀도 입니다.<br>
(이 부분 용어 설명은 나중에 포스팅하기로 할게요.)</p>
<h4 id="numeric-operations">Numeric Operations</h4>
<p>러스트는 간단한 숫자 연산을 지원합니다.<br>
덧셈, 뺄셈, 곱셈, 나눗셈, 모듈러(나머지) 연산 등이죠.</p>
<pre><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}

</code></pre>
<p>위의 예시에서 각 연산의 결과값은 변수에 바인딩(묶임)됩니다.<br>
<a href="https://doc.rust-lang.org/book/appendix-02-operators.html">Appendix B</a> 에서 모든 연산의 종류를 확인할수 있습니다.</p>
<h4 id="boolean-type">Boolean type</h4>
<p>대부분의 프로그래밍 언어에서 다루는, <code>true</code>, <code>false</code> 값을 가지는 불리언 타입입니다.<br>
Boolean 타입은 1바이트의 사이즈를 가집니다.</p>
<pre><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}

</code></pre>
<p>주로 <code>if</code>문에서 사용하죠.<br>
이후에 <a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html#control-flow">control flow</a> 챕터에서 다뤄보도록 합시다.</p>
<h4 id="character-type">character type</h4>
<p>지금까지는 숫자에 대해서만 다뤘지만, 러스트는 문자도 지원합니다.<br>
<code>char</code> 타입은 문자열 타입과는 다르게 '' 단따옴표를 사용하여 표기합니다.</p>
<pre><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}

</code></pre>
<p><code>char</code>타입은 4 바이트이며, 유니코드 값을 나타낼수 있습니다.<br>
ASCII 말고도 수많은 표현이 가능하다는 얘기입니다.<br>
강조 문자, 중국어, 일본어, 한국어, 이모지, 공백문자 까지 모두 가능합니다.<br>
유니코드는 <code>U+0000</code> 부터 <code>U+D7FF</code>, 그리고 <code>U+E000</code> 부터 <code>U+10FFFF</code> 까지(포함) 가능합니다.<br>
일반적으로 &lsquo;character&rsquo;라고 하면 유니코드랑은 좀 개념이 맞지않아서 직관적으로 다소 이해되지 않을수 있습니다.<br>
이러한 부분은 <a href="https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">storing UTF-8 Encoded text with strings</a>에서 좀더 살펴보겠습니다.</p>
<h3 id="compound-types">Compound Types</h3>
<p>컴파운드 타입은 여러개의 값을 하나의 타입으로 묶을수 있습니다.<br>
러스트는 두개의 기본 컴파운드 타입이 있습니다:<br>
tuples 와 arrays 입니다.</p>
<h4 id="tuple-type">Tuple type</h4>
<p>튜플은 여러개의 다양한 타입을 가진 값들을 하나로 묶는 일반적인 방법입니다.<br>
튜플은 고정 길이를 가집니다:<br>
즉, 한번 선언되면 늘어나거나 줄어들지 않습니다.</p>
<p>괄호안에 쉼표로 구분하는 리스트를 만들어서 튜플을 생성할수 있습니다.<br>
각 위치는 타입을 가질수 있으며, 타입이 꼭 전부 같을 필요는 없습니다.<br>
아래 예제에서는 타입 어노테이션(선택 가능: 해도 되고 안해도 됨)을 붙여봤습니다.</p>
<h6 class="codeblock" id="mainrs"><strong><code>main.rs</code></strong></h6>
<pre><code class="language-rust">fn main() {
  let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre>
<p><code>tup</code> 이라는 변수는 전체 튜플을 잡아둡니다.<br>
튜플은 전체가 하나의 요소로 취급되기 때문입니다.<br>
튜플로부터 각각의 값을 가져오려면, 패턴 매칭을 사용하여 아래와 같이 튜플 값을 분해할수 있습니다.</p>
<pre><code class="language-rust">fn main(){
  let tup = (500, 6.4, 1);
  let (x, y, z) = tup;
  println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre>
<p>이 프로그램은 먼저 튜플을 만들고 <code>tup</code>이라는 변수에 묶습니다.<br>
<code>let</code>키워드와 함께 패턴을 사용해서 <code>tup</code> 변수를 받아서 3개의 분리된 값으로 바꿉니다.<br>
이것을 <code>destructuring(해체)</code> 이라고 부릅니다.<br>
하나의 튜플을 세 부분으로 나누기 때문이죠.<br>
마지막으로 프로그램은 <code>y</code>의 값인 <code>6.4</code>를 프린트하게 됩니다.</p>
<p>패턴 매칭으로 해체하는 방식 외에도,<br>
마침표(.)를 이용하여 바로 튜플 요소에 접근할수 있습니다.</p>
<blockquote>
<p>튜플.{순서}</p>
</blockquote>
<p>예제를 한번 봅시다.</p>
<pre><code class="language-rust">fn main() {
  let tup2: (i32, f64, u8) = (500, 6.4, 1);
  let five_hundred = tup2.0;
  let six_point_four = tup2.1;
  let one = tup2.2;
}
</code></pre>
<p>먼저 <code>tup2</code>라는 변수를 만들고, 튜플의 인덱스(순서)를 고려하여 새로운 변수에 넣었습니다.<br>
대부분의 프로그래밍 언어가 그렇듯, 인덱스는 0 부터 시작합니다.</p>
<h4 id="array-타입">Array 타입</h4>
<p>또 다른 방식으로, array 를 이용하면 여러 값의 집합을 만들수 있습니다.<br>
tuple 과는 다르게 array의 모든 요소는 같은 타입을 가져야 합니다.</p>
<p>다른 프로그래밍 언어들과는 다르게 러스트의 array는 고정된 길이만을 갖습니다.<br>
대괄호[] 안에 쉼표로 구분하여 적습니다.</p>
<pre><code class="language-rust">fn main() {
  let a = [1, 2, 3, 4, 5];
}
</code></pre>
<p>어레이는 힙 보다는 스택에 데이터를 지정하고 싶을때 유용합니다.<br>
(스택과 힙에 대해서는 챕터 4에서 좀더 알아보도록 합시다.)<br>
또는 항상 고정된 갯수의 요소를 가질것이라고 확신할수 있을때 사용합니다.</p>
<p>어레이는 벡터 타입 만큼 유연하지 않습니다.<br>
벡터는 표준 라이브러리를 통해 제공되는 집합(collection) 타입이고, 사이즈가 늘어나거나 줄어드는 것이 가능합니다!<br>
만약 어레이를 쓸지 벡터를 쓸지 확실하지 않다면 벡터를 사용하게 될겁니다.<br>
(챕터 8 에서 벡터에 대해 좀더 알아보도록 합시다.)</p>
<p>프로그램에서 벡터 대신 어레이를 쓰게될 상황에 대한 예로는,<br>
월별 이름을 알아야 할때가 있습니다.<br>
새로운 달이 추가되거나 사라질 일이 왠만해서는 없기때문에,<br>
어레이를 사용할수 있습니다. 항상 12개의 요소를 가질 것이기 때문이죠.</p>
<pre><code class="language-rust">let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
</code></pre>
<p>아래 처럼 어레이의 타입을 적는 경우,<br>
대괄호안에 요소의 타입을 적고, 세미콜론을 붙인 다음,<br>
그 옆에 어레이의 사이즈를 적어주면 됩니다.</p>
<pre><code class="language-rust">let a: [i32; 5] = [1, 2, 3, 4, 5];
</code></pre>
<p>여기에서 <code>i32</code>는 각 원소들의 타입이고 <code>5</code>는 어레이가 5개의 원소를 포함한다는 의미입니다.</p>
<p>동일한 원소로 어레이를 만들려면 타입 대신 해당 원소를 적어주면 됩니다.</p>
<pre><code class="language-rust">let a = [3; 5];
</code></pre>
<p>이렇게 하면 3이 5개 들어있는 어레이가 생성됩니다.</p>
<h5 id="어레이-원소-접근">어레이 원소 접근</h5>
<p>어레이는 스택에서 하나의 메모리 덩어리로 지정됩니다.<br>
어레이의 원소는 아래 처럼 인덱스로 접근할수 있습니다:</p>
<pre><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];  // 1
    let second = a[1]; // 2
}
</code></pre>
<p>참고: 어레이의 인덱스도 0부터 시작합니다.</p>
<h5 id="잘못된-어레이-원소-접근">잘못된 어레이 원소 접근</h5>
<p>만약 맨 마지막 원소를 지나서 접근을 하려고 한다면 어떻게 될까요?</p>
<p>(챕터 2를 하고 온 다음에 다시 보기)<br>
(사용자 입력을 받아서, 어레이의 해당 인덱스의 원소를 출력하는 프로그램)</p>
<pre><code class="language-bash">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>이러한 결과는 런타임 에러로, 잘못된 인덱스를 가리켰을때 나타납니다.<br>
프로그램은 마지막 프린트문을 출력하지 못한채로 종료됩니다.</p>
<p>이런식으로 사용자가 어떤 값을 입력할지 모르는 경우, 컴파일러가 컴파일 전에 체크할수가 없기때문에 런타임 에러가 발생할수가 있습니다.</p>
<p>바로 이것이 현실에서 일어날수 있는<br>
러스트의 안전 원칙 중 첫번째 예입니다.<br>
많은 저레벨 언어들에서 이런 종류의 체크는 수행되지 않고,<br>
잘못된 인덱스를 넣으면 잘못된 메모리 주소에 접근할수가 있습니다.<br>
러스트에서는 이러한 종류의 에러를 미연에 방지하는 방법으로 프로그램을 바로 종료시키게 됩니다.<br>
챕터 9에서 러스트의 에러 핸들링을 좀더 알아보기로 합시다.</p>
<h2 id="functions">Functions</h2>
<p>러스트 코드에는 함수가 널리 퍼져있습니다(?).<br>
그 중에서도 가장 중요한 함수를 이미 우리는 알고 있죠: 많은 언어에서 엔트리 포인트(시작점) 으로 사용되는 <code>main</code> 함수입니다.<br>
새로운 함수를 선언하는 <code>fn</code>키워드도 한번 본적이 있습니다.</p>
<p>러스트 코드는 함수나 변수 이름을 만들때 관습적으로 <em>snake case</em> 를 사용합니다.<br>
<em>snake case</em> 에서는 모든 문자가 소문자이고, 언더스코어(_)로 단어들을 구별합니다.<br>
예시를 봅시다:</p>
<pre><code class="language-rust">fn main() {
  println!(&quot;Hello, world!&quot;);

  another_function();
}

fn another_function() {
  println!(&quot;Another function.&quot;);
}
</code></pre>
<p>러스트에서 함수를 선언할때는 <code>fn</code> 키워드로 시작하고,<br>
함수 이름 뒤에 괄호를 붙입니다.<br>
중괄호는 컴파일러에게 함수 바디(body)의 시작과 끝을 알려줍니다.</p>
<p>함수 이름을 쓰고 뒤에 괄호를 붙이면 우리가 정의한 어떤 함수든 호출할수 있습니다.</p>
<p>노트:<br>
유의할점은, 소스코드에서는 <code>main</code>함수 뒤에 <code>another_function</code>을 정의하였지만, 앞에서 정의해도 상관없습니다.<br>
어딘가에만 정의되어 있으면 됩니다.</p>
<p>함수를 실행해보면 다음과 같은 결과가 나옵니다:</p>
<pre><code>$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.

</code></pre>
<p><code>main</code> 함수 내에서 호출된 순서대로, <code>Hello, world!</code> 다음에 <code>Another function.</code> 이 차례로 호출되는것을 확인할 수 있습니다.</p>
<h3 id="function-parameters">Function Parameters</h3>
<p>함수의 시그니처(함수의 구성요소) 중 하나로서,<br>
특별한 변수로 사용되는 &ldquo;parameter&rdquo; 를 가지도록 함수를 정의할 수도 있습니다.</p>
<p>함수가 parameter 를 가지고 있을때, 구체적인 값을 가지도록 할수도 있습니다.<br>
기술적으로는, 구제척인 값을 &ldquo;argument&rdquo; 라고 하지만(함수에서 정의된 변수가 아닌 구체적인 값: example ➜ funcion1(2) ➜ 여기서 2를 말함),<br>
일상 대화에서 우리가 parameter 와 argument를 사용할때는 딱히 구분없이 말하기도 합니다.</p>
<p>다음 예를 보면서 설명해볼까요.</p>
<pre><code class="language-rust">fn main() {
  another_function(5);
}
fn another_function(x: i32) {
  println!(&quot;The Value of x is: {}&quot;,x);
}
</code></pre>
<p>실행해보면 아래와 같이 나올겁니다.</p>
<pre><code>$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>another_function</code> 함수를 선언할때, 파라미터는 <code>x</code> 하나이고 타입은 <code>i32</code>입니다.<br>
<code>5</code>라는 값이 함수로 들어가면, <code>println!</code>이라는 매크로가 형식 문자열(format string) 내에서 중괄호가 있는 위치에 <code>5</code>를 넣습니다.</p>
<p>함수 시그니처(구성요소)에서, 파라미터의 타입은 <em>반드시</em> 지정해줘야 합니다.<br>
이런 특징은 러스트 언어를 디자인할때 의도적으로 고려된 결정입니다:<br>
함수 정의할때 미리 타입을 선언한다는 것은,<br>
컴파일러가 어떤 의미로 코드를 짰는지 알기위해<br>
해당 변수를 사용한 곳들을 찾아갈 필요가 거의 전혀 없다는 의미입니다.</p>
<p>함수가 여러개의 파라미터를 갖기를 원한다면,<br>
쉼표로 파라미터를 구분하여 선언하면 됩니다. 이렇게요:</p>
<pre><code class="language-rust">fn main() {
  another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
  println!(&quot;The value of x is : {}&quot;, x);
  println!(&quot;The value of y is : {}&quot;, y);
}
</code></pre>
<p>이 예제는 두개의 파라미터를 갖는 함수를 만들었습니다. 같은 <code>i32</code>타입을 가지고 있네요.<br>
그리고선 두개 파라미터가 가지는 값을 바로 출력합니다.<br>
당연한 얘기지만, 모든 파라미터가 같은 타입을 가져야만 할 이유는 1도~~(하나도)~~ 없습니다.<br>
그냥 예제가 그럴뿐이죠.</p>
<p>예제를 실행하면 아래처럼 나올겁니다.</p>
<pre><code>$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
</code></pre>
<p>익히 예상할수 있는것처럼<br>
차례로 <code>5</code>와 <code>6</code>을 넣었기 때문에,<br>
출력되는 문자열도 똑같은 순서로 나오는 것을 확인할수 있습니다.</p>
<h3 id="function-bodies-contain-statements-and-expressions">Function Bodies Contain Statements and Expressions</h3>
<p>함수 본문은 선택적으로는 표현식으로 끝나는, 일련의 문장으로 구성됩니다.<br>
지금까지는 종료 표현식이 없는 함수만 다루었지만, 표현식은 명령문의 일부로 보았습니다.<br>
러스트는 표현식 기반 언어이기 때문에, 이런 내용은 꼭 이해해야할 중요한 차이점 입니다.<br>
다른 언어에는 이러한 구분이 없기때문에, 명령문장과 표현식이 무엇이고,<br>
그 차이가 함수 본문에 어떤 영향을 미치는지 한번 살펴보겠습니다.</p>
<p>우리는 사실 이미 명령식과 표현식을 사용했습니다.<br>
<em>명령식(statement)</em> 은 값을 리턴하지않으면서 어떤 행위를 수행하는 지시문입니다.<br>
<em>표현식(Expressions)</em> 은 결과값을 도출합니다.<br>
예제를 통해 살펴봅시다.</p>
<p>변수를 만들고 <code>let</code>키워드로 값을 할당하는 이런 형태는 <em>Statement(명령식)</em> 입니다.<br>
아래 예제 코드에서 <code>let y = 6;</code> 이 문장이 명령식입니다.</p>
<pre><code class="language-rust">fn main() {
  let y = 6;
}
</code></pre>
<p><small>Listing 3-1: A main function declaration containing one statement</small></p>
<p>함수 정의 또한 Statement 입니다.<br>
앞서 나온 전체 예제는 그 자체로 statement 입니다.</p>
<p>Statements 는 값을 리턴하지 않습니다.<br>
따라서 <code>let</code> statement 를 다른 변수에 다시 할당할수 없습니다.<br>
다음 예제를 실행하면 에러가 발생합니다.</p>
<pre><code class="language-rust">fn main() {
  let x = (let y = 6);
}
</code></pre>
<p>실제로 프로그램을 실행하면 다음과 같은 에러가 나올겁니다.</p>
<pre><code>$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0658]: `let` expressions in this position are experimental
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information
  = help: you can write `matches!(&lt;expr&gt;, &lt;pattern&gt;)` instead of `let &lt;pattern&gt; = &lt;expr&gt;`

error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^^^^^^^^^^^ help: remove these parentheses
  |
  = note: `#[warn(unused_parens)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0658`.
error: could not compile `functions`

To learn more, run the command again with --verbose.

</code></pre>
<p><code>let y = 6</code> statement 는 값을 반환하지 않다보니, <code>x</code>에 묶어놓을 값이 없습니다.<br>
이런 특징이, 할당을 하면 할당된 값을 반환하는 다른 언어(C,Ruby 등)들과 다른 점입니다.<br>
만약 <code>x = y = 6</code> 이런식으로 쓰면 <code>x</code> 와 <code>y</code>는 모두 <code>6</code>이라는 값을 가집니다.<br>
러스트에서는 이런 경우가 없습니다.</p>
<p>Expressions 는 어떤 값을 도출해내고, 러스트에서 작성할 코드의 나머지 대부분을 차지합니다.<br>
간단한 수학 연산을 생각해볼까요.<br>
<code>5+6</code>이라는 표현식에서 결과는 <code>11</code>이 나옵니다.<br>
표현식(expressions)은 선언식(statement) 의 일부가 될수 있습니다:<br>
위 예제 3-1 의 <code>let y=6</code>에서 <code>6</code>은 <code>6</code>이라는 값으로 도출되는 표현식입니다.<br>
함수를 호출하는 것도 표현식입니다.<br>
매크로를 호출하는 것도 표현식입니다.<br>
새로운 스코프를 만들때 사용하는 블록,{},도 표현식입니다.<br>
예를 들면 이렇습니다.</p>
<pre><code class="language-rust">fn main() {
  let x = 5;

  let y = {
    let x = 3;
    x + 1
  };
  println!(&quot;The value of y is : {}&quot;, y);
}
</code></pre>
<p>아래 표현식을 보세요:</p>
<pre><code class="language-rust">{
    let x = 3;
    x + 1
}
</code></pre>
<p>이 블록은 <code>4</code>라는 결과로 나타납니다.<br>
이 값은 <code>y</code>에 묶이게 되고(bound to) <code>let</code>문장의 일부분입니다.<br>
여기서 주의할점은 <code>x+1</code> 에는 세미콜론; 이 마지막에 없습니다.<br>
지금까지 본적없는 형태이죠.<br>
expressions(표현식)은 마지막 세미콜론을 포함하지 않습니다.<br>
마지막에 세미콜론을 찍으면, 그 문장은 statement(선언식)으로 바뀌게 되고, 값을 반환하지 않게 됩니다.<br>
이것을 명심하시고, 다음부터 배울 함수 값반환과 표현식으로 넘어가보도록 합시다.</p>
<h3 id="functions-with-return-values">Functions with Return Values</h3>
<p>함수는 자신을 부른 코드에 값을 반환할수 있습니다.<br>
반환하는 값의 이름을 붙이진않지만, 타입은 지정할수 있습니다.<br>
화살표(-&gt;) 뒤에 붙입니다.<br>
러스트에서, 반환값은 함수 본문의 블록에서 가장 마지막 표현식의 값과 같습니다.<br>
값을 지정해서 <code>return</code> 키워드로 먼저 끝내버릴수도 있지만, 대부분의 함수는 암시적으로 마지막 표현식을 반환합니다.<br>
아래는 값을 반환하는 함수의 예입니다.</p>
<pre><code class="language-rust">fn five() -&gt; i32 {
  5
}

fn main() {
  let x = five();

  println!(&quot;The value of x is : {}&quot;, x);
}
</code></pre>
<p>여기에 있는 <code>five</code>함수안에는 함수 호출도 없고, 매크로도, 심지어 let statement도 없습니다 — 그냥 숫자 <code>5</code>가 들어있을 뿐이죠.<br>
러스트에서는 완벽하게 유효한 함수입니다.<br>
함수의 반환 타입도 명시되어 있다는 것에 주목하세요. (<code>-&gt; 32</code>)<br>
위 코드를 실행하면 아래와 같이 나올겁니다.</p>
<pre><code>$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5

</code></pre>
<p><code>five</code>함수의 <code>5</code>는 함수의 반환 값이고, 리턴 타입이 <code>i32</code>인 이유입니다.<br>
좀더 자세히 살펴봅시다.<br>
두가지 중요한 부분이 있습니다.<br>
첫번째로, <code>let x = five();</code> 이 줄에서 변수를 초기화하기 위해서 함수의 반환값을 이용하였습니다.<br>
<code>five</code>함수가 <code>5</code>를 반환했기때문에, 아래와 같은 줄이 됩니다.</p>
<pre><code class="language-rust">let x = 5;
</code></pre>
<p>두번째로, <code>five</code>함수는 파라미터가 없고, 반환 타입만 정의하였습니다.<br>
함수 본문에는 외로이 <code>5</code>가 있을뿐이고, 세미콜론;도 없습니다.<br>
선언식이 아닌 표현식이기 때문이며, 반환하고 싶은 값이기 때문입니다.</p>
<p>다른 예제를 살펴보죠.</p>
<pre><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>위 코드를 실행하면 <code>The value of x is: 6</code> 이 나올겁니다.<br>
하지만 <code>x+1</code>이 있는 이 줄에 세미콜론을 추가한다면, statement로 바뀌면서 에러가 나게 됩니다.</p>
<pre><code class="language-rust">
fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}

</code></pre>
<p>이 코드를 컴파일 하면 아래처럼 에러가 나올 겁니다.</p>
<pre><code>$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions`

To learn more, run the command again with --verbose.

</code></pre>
<p>주요 에러 메세지는 &ldquo;타입 미스매치(타입이 잘못 매칭되었음)&rdquo; 입니다.<br>
<code>plus_one</code> 함수의 정의를 보면, <code>i32</code>타입을 반환한다고 되어있습니다.<br>
하지만 statement선언식은 값으로 도출되지않고 비어있는 튜플()로 표현될 뿐입니다.<br>
그러므로, 아무것도 반환되지 않으며, 함수 정의에 위배되므로, 에러가 발생하게 됩니다.<br>
이 결과에서 러스트는 문제를 수정하는데 도움이 될수 있는 메세지를 제공합니다:<br>
세미콜론을 제거하면 문제를 해결할수 있을거라고&hellip;</p>
<h2 id="comments">Comments</h2>
<p>모든 프로그래머들은 자신의 코드를 이해하기 쉽게 만들기 위해 노력하지만, 때때로 추가적인 설명이 필요합니다.<br>
이런 경우에 노트를 남기거나, <em>코멘트</em> 를 남깁니다:<br>
컴파일러는 소스코드의 코멘트를 무시하지만 코드를 읽는 사람들에게는 매우 유용할수 있습니다.<br>
간단한 코멘트를 볼까요.</p>
<pre><code class="language-rust">// hello, world
</code></pre>
<p>러스트에서는 관용적으로 두개의 슬래쉬// 로 코멘트를 시작하고 그 줄의 끝까지를 주석으로 간주합니다.<br>
여러줄에 주석을 적으려면 이렇게 합니다:</p>
<pre><code class="language-rust">// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
</code></pre>
<p>각 줄에 두개의 술래쉬//를 적으면 됩니다.</p>
<p>주석은 코드를 포함한 줄에도 사용 가능합니다.</p>
<pre><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
</code></pre>
<p>하지만 아래와 같이<br>
설명하려는 코드 윗줄에 주석을 적는 것이 보통입니다.</p>
<pre><code class="language-rust">fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
</code></pre>
<p>러스트에는 <em>documentation comments</em> 라는 다른 종류의 주석도 있는데,<br>
이 내용은 챕터 14의 &ldquo;Publishing a Crate to Crates.io&rdquo; 섹션에서 더 다뤄보도록 하겠습니다.</p>
<h2 id="control-flow">Control Flow</h2>
<p>&ndash; 다음에 계속&hellip;</p>

  </main>
  
  <div id="disqus-container">
  
</div>



          
          
          <div style="text-align: center;">
            <a id="toparrow" href="#topofpage">🔝</a>
          </div>
          
          
        </div>
      </div>
    </div>

    

<script src="/js/dom-scripts.js"></script>  

<script src="/js/prism.js"></script>



<script src="/js/search.da4e0819db35e5fc5289562d46cf4a2173684e337d69d997639a24b79ecd6416.js"></script>

<link rel="stylesheet" href="/css/search.54f9a90ceddfdaa3e66698090e7d4a7e7a7f217c85bc79c48ed09c8cb3ee6777.css"></link>




  <script src="/js/custom.js"></script>

  <script src="/js/fuse.js"></script>

  <script src="/js/viz.js"></script>

  <script src="/js/full.render.js"></script>


    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css" integrity="sha384-dbVIfZGuN1Yq7/1Ocstc1lUEm+AT+/rCkibIcC/OmWo5f0EA48Vf8CytHzGrSwbQ" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js" integrity="sha384-2BKqo+exmr9su6dir+qCw08N2ZKRucY4PrGQPPWU1A7FtlCGjmEGFqXCv5nyM5Ij" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

    
  


    <script data-name="BMC-Widget" data-cfasync="false" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="wadro" data-description="Support me on Buy me a coffee!" data-message="thank you for your help..." data-color="#5F7FFF" data-position="Right" data-x_margin="18" data-y_margin="18"></script>



  </body>
</html>
